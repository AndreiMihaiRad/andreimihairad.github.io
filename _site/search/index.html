<!--
 __  __                         _____                   
|  \/  |                       / ____|                  
| \  / |_   ____   ___ __ ___ | |     _ __ ___  ___ ___ 
| |\/| \ \ / /\ \ / / '_ ` _ \| |    | '__/ _ \/ __/ __|
| |  | |\ V /  \ V /| | | | | | |____| | | (_) \__ \__ \
|_|  |_| \_/    \_/ |_| |_| |_|\_____|_|  \___/|___/___/
========================================================
                                    © 2017 MvvmCross.com
-->

<!DOCTYPE html>
<html lang="">
<!-- head -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/assets/img/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <!-- stylesheets -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css">
    <link rel="stylesheet" href="/assets/main.css">
    <link rel="stylesheet" href="/assets/richleland-pygments-css/vs.css">
    <!-- jekyll-seo-tag -->
    <!-- Begin Jekyll SEO tag v2.2.3 -->
<title>Andrei Rad’s Blog | MvvmCross is a convention based MVVM framework for Xamarin and Windows, with strong community support, filled to the brim with useful features.</title>
<meta property="og:title" content="Andrei Rad’s Blog" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="MvvmCross is a convention based MVVM framework for Xamarin and Windows, with strong community support, filled to the brim with useful features." />
<meta property="og:description" content="MvvmCross is a convention based MVVM framework for Xamarin and Windows, with strong community support, filled to the brim with useful features." />
<link rel="canonical" href="http://localhost:4000/search/" />
<meta property="og:url" content="http://localhost:4000/search/" />
<meta property="og:site_name" content="Andrei Rad’s Blog" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@rad_andrei29" />
<script type="application/ld+json">
{"@context":"http://schema.org","@type":"WebPage","headline":"Andrei Rad’s Blog","description":"MvvmCross is a convention based MVVM framework for Xamarin and Windows, with strong community support, filled to the brim with useful features.","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/assets/img/logo/MvvmCross-avatar.png"}},"url":"http://localhost:4000/search/"}</script>
<!-- End Jekyll SEO tag -->

    <!-- favicons and rss -->
    <link rel="alternate" type="application/rss+xml" title="Andrei Rad&#39;s Blog" href="/feed.xml">
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/assets/img/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicon/favicon-16x16.png">
    <link rel="manifest" href="/assets/img/favicon/manifest.json">
</head>
<body>
    <!-- header -->
    <header class="header" role="banner" aria-label="Header">
    <button class="hamburger-button" onclick="hamburgerMenu();" role="button" aria-label="Hamburger menu button">
        <i class="fa fa-bars fa-2x" aria-hidden="true"></i>
    </button>
    <a href="/" class="logo" role="link" aria-label="Home">
        <img alt="Andrei Rad&#39;s Blog" src="/assets/img/logo/MvvmCross-logo.png" role="img" aria-label="Logo"/>
    </a>
    <nav class="navigation" role="navigation" aria-label="Navigation">
        <ul role="menu" aria-hidden="true" aria-label="Navigation menu">
            <li role="menuitem" aria-label="Navigation menu item">
                <a href="/" class="logo" role="menuitem" aria-label="Home">
                    <img alt="Andrei Rad&#39;s Blog" src="/assets/img/logo/MvvmCross-logo.png" role="img" aria-label="Logo"/>
                </a>
            </li>
            
            <li role="menuitem"><a href="/devops" role="menuitem" aria-label="DevOps">DevOps</a></li>
            
            <li role="menuitem"><a href="/java" role="menuitem" aria-label="Java">Java</a></li>
            
            <li role="menuitem"><a href="/python" role="menuitem" aria-label="Python">Python</a></li>
            
        </ul>
    </nav>
    <div class="searchbox" role="search" aria-label="Search">
        <form action="/search" id="searchthis" method="get" role="form" aria-label="Search form">
            <i class="fa fa-search" aria-hidden="true"></i>
            <input type="search" id="search" name="query" placeholder="Search..." role="textbox" aria-label="Search textbox"/>
        </form>
    </div>
</header>
<nav id="hamburger-menu" role="navigation" aria-label="Hamburger menu">
    <div class="searchbox" role="search" aria-label="Search">
        <form action="/search" id="searchthis" method="get" role="form" aria-label="Search form">
            <i class="fa fa-search" aria-hidden="true"></i>
            <input type="search" id="search" name="query" placeholder="Search..." role="textbox" aria-label="Search textbox"/>
        </form>
    </div>
    <div class="home-nav" role="navigation" aria-label="Site navigation">
        <a href="/" role="menuitem" aria-label="Home">Home</a>
        
        <a href="/devops" role="menuitem" aria-label="DevOps">DevOps</a>
        
        <a href="/java" role="menuitem" aria-label="Java">Java</a>
        
        <a href="/python" role="menuitem" aria-label="Python">Python</a>
        
    </div>
    <div class="doc-nav" role="navigation" aria-label="Documentation navigation">
        
        
        
        <p role="presentation" aria-label="Category name">Getting-started</p>
        <ul role="menu" aria-hidden="true" aria-label="Navigation menu">
        
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/getting-started/getting-started" class="doc-link" role="link" aria-label="Getting Started with MvvmCross">Getting Started with MvvmCross</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/getting-started/debugging-with-symbols" class="doc-link" role="link" aria-label="Debugging with Symbols">Debugging with Symbols</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/getting-started/mvvmcross-packages" class="doc-link" role="link" aria-label="MvvmCross Packages">MvvmCross Packages</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/getting-started/netstandard" class="doc-link" role="link" aria-label=".NET Standard & MvvmCross">.NET Standard & MvvmCross</a></li>
        
        </ul>
        
        
        <p role="presentation" aria-label="Category name">Fundamentals</p>
        <ul role="menu" aria-hidden="true" aria-label="Navigation menu">
        
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/fundamentals/app-lifecycle" class="doc-link" role="link" aria-label="App lifecycle">App lifecycle</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/fundamentals/custom-data-binding" class="doc-link" role="link" aria-label="Custom Data Binding">Custom Data Binding</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/fundamentals/customize-app" class="doc-link" role="link" aria-label="Customize app">Customize app</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/fundamentals/mvvmcross-overview" class="doc-link" role="link" aria-label="MvvmCross Overview">MvvmCross Overview</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/fundamentals/data-binding" class="doc-link" role="link" aria-label="Data binding">Data binding</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/fundamentals/navigation" class="doc-link" role="link" aria-label="Navigation">Navigation</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/fundamentals/value-converters" class="doc-link" role="link" aria-label="Value converters">Value converters</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/fundamentals/value-combiners" class="doc-link" role="link" aria-label="Value combiners">Value combiners</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/fundamentals/viewmodel-lifecycle" class="doc-link" role="link" aria-label="ViewModel Lifecycle">ViewModel Lifecycle</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/fundamentals/dependency-injection" class="doc-link" role="link" aria-label="Dependency injection">Dependency injection</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/fundamentals/inversion-of-control-ioc" class="doc-link" role="link" aria-label="Inversion of Control">Inversion of Control</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/fundamentals/portable-class-library-pcl" class="doc-link" role="link" aria-label="Portable Class Library (PCL)">Portable Class Library (PCL)</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/fundamentals/Customizing-using-App-and-Setup" class="doc-link" role="link" aria-label="Customizing using App and Setup">Customizing using App and Setup</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/fundamentals/analysis" class="doc-link" role="link" aria-label="Code Analysis">Code Analysis</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/fundamentals/mvxinteraction" class="doc-link" role="link" aria-label="ViewModel to View Interaction">ViewModel to View Interaction</a></li>
        
        </ul>
        
        
        <p role="presentation" aria-label="Category name">Platform specifics</p>
        <ul role="menu" aria-hidden="true" aria-label="Navigation menu">
        
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/platform/android-support-library" class="doc-link" role="link" aria-label="Android support library">Android support library</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/platform/ios-support-library" class="doc-link" role="link" aria-label="iOS Support Library">iOS Support Library</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/platform/ios-tables-and-cells" class="doc-link" role="link" aria-label="iOS Tables and Cells">iOS Tables and Cells</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/platform/universal-windows-platform-uwp/universal-windows-platform-uwp" class="doc-link" role="link" aria-label="Universal Windows platform (UWP)">Universal Windows platform (UWP)</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/platform/xamarin-forms" class="doc-link" role="link" aria-label="Xamarin.Forms with MvvmCross">Xamarin.Forms with MvvmCross</a></li>
        
        </ul>
        
        
        <p role="presentation" aria-label="Category name">Presenters</p>
        <ul role="menu" aria-hidden="true" aria-label="Navigation menu">
        
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/presenters/android-view-presenter" class="doc-link" role="link" aria-label="Android View Presenter">Android View Presenter</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/presenters/ios-view-presenter" class="doc-link" role="link" aria-label="iOS View Presenter">iOS View Presenter</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/presenters/mac-view-presenter" class="doc-link" role="link" aria-label="Mac View Presenter">Mac View Presenter</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/presenters/view-presenters" class="doc-link" role="link" aria-label="View Presenters">View Presenters</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/presenters/wpf-view-presenter" class="doc-link" role="link" aria-label="WPF View Presenter">WPF View Presenter</a></li>
        
        </ul>
        
        
        <p role="presentation" aria-label="Category name">Plugins</p>
        <ul role="menu" aria-hidden="true" aria-label="Navigation menu">
        
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/plugins/3rd-party-plugins" class="doc-link" role="link" aria-label="3rd party plugins">3rd party plugins</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/plugins/accelerometer" class="doc-link" role="link" aria-label="Accelerometer">Accelerometer</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/plugins/color" class="doc-link" role="link" aria-label="Color">Color</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/plugins/downloadcache" class="doc-link" role="link" aria-label="DownloadCache">DownloadCache</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/plugins/email" class="doc-link" role="link" aria-label="Email">Email</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/plugins/fieldbinding" class="doc-link" role="link" aria-label="FieldBinding">FieldBinding</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/plugins/file" class="doc-link" role="link" aria-label="File">File</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/plugins/json" class="doc-link" role="link" aria-label="Json">Json</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/plugins/jsonlocalisation" class="doc-link" role="link" aria-label="JsonLocalization">JsonLocalization</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/plugins/location" class="doc-link" role="link" aria-label="Location">Location</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/plugins/messenger" class="doc-link" role="link" aria-label="Messenger">Messenger</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/plugins/methodbinding" class="doc-link" role="link" aria-label="MethodBinding">MethodBinding</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/plugins/network" class="doc-link" role="link" aria-label="Network">Network</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/plugins/phonecall" class="doc-link" role="link" aria-label="PhoneCall">PhoneCall</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/plugins/picturechooser" class="doc-link" role="link" aria-label="PictureChooser">PictureChooser</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/plugins/resourceloader" class="doc-link" role="link" aria-label="ResourceLoader">ResourceLoader</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/plugins/resxlocalization" class="doc-link" role="link" aria-label="ResxLocalization">ResxLocalization</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/plugins/share" class="doc-link" role="link" aria-label="Share">Share</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/plugins/visibility" class="doc-link" role="link" aria-label="Visibility">Visibility</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/plugins/webbrowser" class="doc-link" role="link" aria-label="WebBrowser">WebBrowser</a></li>
        
        </ul>
        
        
        <p role="presentation" aria-label="Category name">Testing</p>
        <ul role="menu" aria-hidden="true" aria-label="Navigation menu">
        
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/testing/testing" class="doc-link" role="link" aria-label="Testing">Testing</a></li>
        
        </ul>
        
        
        <p role="presentation" aria-label="Category name">Samples</p>
        <ul role="menu" aria-hidden="true" aria-label="Navigation menu">
        
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/samples/samples" class="doc-link" role="link" aria-label="Samples">Samples</a></li>
        
        </ul>
        
        
        <p role="presentation" aria-label="Category name">Upgrading</p>
        <ul role="menu" aria-hidden="true" aria-label="Navigation menu">
        
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/upgrading/upgrade-to-mvvmcross-40" class="doc-link" role="link" aria-label="Upgrade from 3 to MvvmCross 4">Upgrade from 3 to MvvmCross 4</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/upgrading/upgrade-to-mvvmcross-50" class="doc-link" role="link" aria-label="Upgrade from 4 to MvvmCross 5">Upgrade from 4 to MvvmCross 5</a></li>
        
        </ul>
        
        
        <p role="presentation" aria-label="Category name">TipCalc Tutorial</p>
        <ul role="menu" aria-hidden="true" aria-label="Navigation menu">
        
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/tipcalc-tutorial/the-tip-calc-tutorial" class="doc-link" role="link" aria-label="The Tip Calc tutorial">The Tip Calc tutorial</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/tipcalc-tutorial/the-core-project" class="doc-link" role="link" aria-label="The Core Project">The Core Project</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/tipcalc-tutorial/the-tip-calc-navigation" class="doc-link" role="link" aria-label="The TipCalc navigation">The TipCalc navigation</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/tipcalc-tutorial/a-xamarinandroid-ui-project" class="doc-link" role="link" aria-label="A Xamarin.Android UI Project">A Xamarin.Android UI Project</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/tipcalc-tutorial/a-xamarinios-ui-project" class="doc-link" role="link" aria-label="A Xamarin.iOS UI Project">A Xamarin.iOS UI Project</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/tipcalc-tutorial/a-windows-universal-app-platform-project" class="doc-link" role="link" aria-label="A Windows Universal App Platform Project">A Windows Universal App Platform Project</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/tipcalc-tutorial/a-universal-windows-app-ui-project" class="doc-link" role="link" aria-label="A Universal Windows App UI Project">A Universal Windows App UI Project</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/tipcalc-tutorial/a-wpf-ui-project" class="doc-link" role="link" aria-label="A Wpf UI Project">A Wpf UI Project</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/tipcalc-tutorial/tip-calculator-a-recap" class="doc-link" role="link" aria-label="Tip Calculator - A recap">Tip Calculator - A recap</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/tipcalc-tutorial/a-note-about-views-and-viewmodels" class="doc-link" role="link" aria-label="A note about Views and ViewModels">A note about Views and ViewModels</a></li>
        
        </ul>
        
        
        <p role="presentation" aria-label="Category name">Contributing</p>
        <ul role="menu" aria-hidden="true" aria-label="Navigation menu">
        
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/contribute/acknowledgements" class="doc-link" role="link" aria-label="Acknowledgements">Acknowledgements</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/contribute/contribute" class="doc-link" role="link" aria-label="New contributions">New contributions</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/contribute/mvvmcross-docs-style-guide" class="doc-link" role="link" aria-label="Style Guide">Style Guide</a></li>
        
        </ul>
        
        
        <p role="presentation" aria-label="Category name">Licensing</p>
        <ul role="menu" aria-hidden="true" aria-label="Navigation menu">
        
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/licensing/licensing" class="doc-link" role="link" aria-label="Licensing">Licensing</a></li>
        
        <li role="menuitem" aria-label="Navigation menu item"><a href="/documentation/licensing/references" class="doc-link" role="link" aria-label="References">References</a></li>
        
        </ul>
        
    </div>
</nav>
    <!-- main content -->
    <main class="container" role="main">
        
<ul id="search-results">
    <h2 class="searching-text">Searching.....</h2>
</ul>
<script>
  window.store = {
    
        
          "documentation-upgrading-upgrade-to-mvvmcross-40" :{
            "title": "Upgrade from 3 to MvvmCross 4",
            "content": "NuGet package changesSince MvvmCross 4, the NuGet package names have changed. All packages containing the name HotTuna or Cirrious have been renamed. If you update the packages using Nuget to a version greater than 4, the new NuGet packages will be automatically installed. However, you should delete the old HotTuna or Cirrious packages from your solution after the update.            old NuGet package      new NuGet package                  MvvmCross.HotTuna.AutoViews      MvvmCross.AutoView              MvvmCross.HotTuna.Binding      MvvmCross.Binding              MvvmCross.HotTuna.CrossCore      MvvmCross.Platform              MvvmCross.HotTuna.Droid.AutoViews      MvvmCross.AutoView.Droid              MvvmCross.HotTuna.Droid.Dialog      MvvmCross.Dialog.Droid              MvvmCross.HotTuna.MvvmCrossLibraries      MvvmCross.Core              MvvmCross.HotTuna.StarterPack      MvvmCross.StarterPack              MvvmCross.HotTuna.Tests      MvvmCross.Tests              MvvmCross.HotTuna.Touch.AutoViews      MvvmCross.AutoView.iOS              MvvmCross.HotTuna.Touch.Dialog      MvvmCross.Dialog.iOS              MvvmCross      MvvmCross      Additionally, the JsonLocalisation plugin has been renamed to JsonLocalization.The package MvvmCross.StarterPack contains sample code and should be removed manually from the packages.config files after adding it to your project (its dependencies will remain there). For an empty project, it is suggested you install MvvmCross.StarterPack. For an existing project or if you don’t want the sample code, it is suggested you install MvvmCross.Namespace changesThe namespaces beginning with Cirrious have had the Cirrious part removed from them. Cirrious.CrossCore has been moved to MvvmCross.Platform and Cirrious.MvvmCross has moved to MvvmCross.Core. All namespaces named Touch have been renamed to iOS since MonoTouch has since been renamed to Xamarin.iOS. If you are maintaining a plugin and have a project ending in .Touch you should also rename it to .iOS.Type changesAll classes, methods, and properties containing the term Touch were replaced with Ios. For example, the class MvxTouchSetup is now called MvxIosSetup.Mac supportAll Nugets now support Xamarin.Mac (Unified API). Add the MvvmCross.StarterPack NuGet to an empty Xamarin.Mac project in Xamarin Studio to help you get started with sample code.",
            "url": "/documentation/upgrading/upgrade-to-mvvmcross-40"
          }
          ,
        
          "documentation-upgrading-upgrade-to-mvvmcross-50" :{
            "title": "Upgrade from 4 to MvvmCross 5",
            "content": "NuGet package changesSince MvvmCross 5.0 some packages have been changed or moved.            old NuGet package      new NuGet package                  MvvmCross.Droid.Support.V4      MvvmCross.Droid.Support.Core.UI, MvvmCross.Droid.Support.Core.Utils, MvvmCross.Droid.Support.Fragment              MvvmCross.Droid.Support.V7.Fragging      MvvmCross.Droid.Support.Fragment              MvvmCross.Forms.Presenter      MvvmCross.Forms      CoreTo make sure your navigation stays up-to-date change all your ShowViewModel&lt;&gt;() calls to the new navigation explained in the documentationExample before:private IMvxCommand _navigateCommand;public IMvxCommand NavigateCommand{    get    {        _navigateCommand = _navigateCommand ?? new MvxCommand(() =&gt; ShowViewModel&lt;TViewModel&gt;());        return _navigateCommand;    }}After:private IMvxAsyncCommand _navigateCommand;public IMvxAsyncCommand NavigateCommand{    get    {        _navigateCommand = _navigateCommand ?? new MvxAsyncCommand(() =&gt; _navigationService.Navigate&lt;TViewModel&gt;());        return _navigateCommand;    }}Also your public void Init() won’t be called anymore. This is because this was done using reflection. With the new navigation a method called public override async Task Initialize() will be called. This method is typed and async.iOSiOS View Presenter and Tab bar controlWith version 5 of MvvmCross the iOS View Presenter received a major overhaul. This results in a few changes especially when using the tab bar control.  The IMvxTabBarPresenter (and its implementation MvxTabsViewPresenter) have been removed and are now fully integrated with the MvxIosViewPresenter class. When you are using the tab bar control, please replace the MvxTabsViewPresenter with the MvxIosViewPresenter;  Like in the previous versions you would still decorate your view controllers with the MvxTabPresentationAttribute attribute, however it has now moved to a new namespace. Namely from MvvmCross.iOS.Support.Presenters to MvvmCross.iOS.Views.Presenters.Attributes.  The MvxTabPresentationAttribute no longer accepts the MvxTabPresentationMode enum as a parameter. These options have now been replaced by their own attributes. See following table (all attributes are located in the MvvmCross.iOS.Views.Presenters.Attributes namespace):            MxvTabPresentationMode      new Attribute                  Root      MvxRootPresentationAttribute              Tab      MvxTabPresentationAttribute              Child      MvxChildPresentationAttribute              Modal      MvxModalPresentationAttribute      Detailed information regarding the new iOS View Presenter and the above attributes can be found in the iOS View Presenter section of the documentation.Xamarin.FormsUpdate your code to use the new base classes, support for MvvmCross bindings and improved presenters. Information about this can be found in: Xamarin.Forms  MvxFormsApp has changed to MvxFormsApplicationChanges to testThe following things are recommended to test  iOS Presenters and navigation  Plugins you used that are removed now",
            "url": "/documentation/upgrading/upgrade-to-mvvmcross-50"
          }
          
        
        ,
    
        
          "documentation-tipcalc-tutorial-a-note-about-views-and-viewmodels" :{
            "title": "A note about Views and ViewModels",
            "content": "This tutorial used MvvmCross’s support for naming conventions to associate the View with the ViewModel.  With a view named TipView, MvvmCross can locate it’s ViewModel as long as it’s named TipViewModel.  The base classes we used for views (e.g. MvxViewController) have MvxViewModel properties named ViewModel.We can however link Views with ViewModels that have different names and have the Views’s ViewModel property and have the ViewModel property be typed with the actual ViewModel’s type rather than the MvxViewModel base class.  There are actually two approaches to this…Generic base classesInstead of using the normal view base classes, there are generic versions available for use.  For example, we could have used MvxViewController&lt;TipViewModel&gt; instead of MvxViewController.  Unfortunately on Windows you can’t use generic types within XAML.  You therefore need an extra class such as this:public class TipViewBase : MvxWindowsPage&lt;TipViewModel&gt;{}The TipView class can then derive from this class and the following XAML can be used:&lt;views:TipViewBase    xmlns:views=\"using:MvvmCross.WindowsUWP.Views\"    ...&lt;/views:TipViewBase&gt;Explicit ViewModel propertiesThe ViewModel property of a View can be explicitly defined.  In the case of TipView, you would use the following code:public new TipViewModel ViewModel{    get {        return (TipViewModel)base.ViewModel;    }    set {        base.ViewModel = value;    }}",
            "url": "/documentation/tipcalc-tutorial/a-note-about-views-and-viewmodels"
          }
          ,
        
          "documentation-tipcalc-tutorial-a-universal-windows-app-ui-project" :{
            "title": "A Universal Windows App UI Project",
            "content": "We started with the goal of creating an app to help calculate what tip to leave in a restaurantWe had a plan to produce a UI based on this concept:To satisfy this we built a ‘Core’ Portable Class Library project which contained:  our ‘business logic’ - ICalculation  our ViewModel - TipViewModel  our App which contains the application wiring, including the start instructions.We then added User Interfaces for Xamarin.Android, Xamarin.iOS and Windows UWP.While UWP is the recommended approach for Windows and Windows Mobile development, you can also target Windows and Windows Phone using Windows 8.1 Universal Windows Apps.  Feel free to skip this section if you don’t need to work with Windows 8.1 Universal Windows Apps.A Universal Windows App is actually a set of three projects.  A Windows Phone 8.1 WinRT project, A Windows 8.1 project and a Shared project.  Unlike normal projects, the Shared project does not build to an assembly.  It’s actually a set of files which are accessible within the Windows Phone and Windows projects as if they existed within those projects.  If you are familiar with file linking, it’s pretty much the same thing with an improved UI.You could follow all the steps below creating two separate Windows 8.1 and Windows Phone 8.1 RT projects but the code which gets placed in the Universal Shared project gets placed in both the Windows 8.1 and the Windows Phone 8.1 RT projects instead.Obviously, to work with Windows and Windows Phone, we will need to switch back to working on the PC with Visual Studio.Create the new Universal Windows Apps ProjectsAdd a new project to your solution - a ‘Blank App (Universal Apps)’ application with name TipCalc.UI.WindowsCommonNote that three projects have been added to your solution.  TipCalc.UI.WindowsCommon.Windows, TipCalc.UI.WindowsCommon.WindowsPhone and TipCalc.UI.WindowsCommon.Shared.Within the WindowsCommon.Windows and WindowsCommon.WindowsPhone projects, you’ll find the normal Universal Windows App UI application constructs:  the ‘Assets’ folder, which contains the default images  the MainPage.Xaml and MainPage.Xaml.cs files that define the default Page for this app  the ‘Package.appxmanifest’ configuration file  the debug private key for your development (WindowsCommon.Windows project only)Within the Shared project, you’ll find the normal Universal Windows App shared application constructs:  the App.Xaml ‘application’ objectDelete MainPage.xamlNo-one really needs a MainPage :)This needs to be removed from both the WindowsCommon.Windows and WindowsCommon.WindowsPhone projects.Install MvvmCrossIn the Package Manager Console, enter…Install-Package MvvmCross.Core…for both the WindowsCommon.Windows and WindowsCommon.WindowsPhone projects.Add a reference to TipCalc.Core.csprojAdd a reference to your TipCalc.Core project - the project we created in the last step which included:  your Calculation service,  your TipViewModel  your App wiring.This needs to be added to both the WindowsCommon.Windows and WindowsCommon.WindowsPhone projectsAdd a Setup classJust as we said during the construction of the other UI projects, Every MvvmCross UI project requires a Setup classThis class sits in the root namespace (folder) of our UI project and performs the initialization of the MvvmCross framework and your application, including:  the Inversion of Control (IoC) system  the MvvmCross data-binding  your App and its collection of ViewModels  your UI project and its collection of ViewsMost of this functionality is provided for you automatically. Within your WindowsCommon.Shared UI project all you have to supply are:  your App - your link to the business logic and ViewModel contentFor TipCalc here’s all that is needed in Setup.cs:using Windows.UI.Xaml.Controls;using MvvmCross.Core.ViewModels;using MvvmCross.WindowsCommon.Platform;namespace TipCalc.UI.WindowsCommon{    public class Setup : MvxWindowsSetup    {        public Setup(Frame rootFrame) : base(rootFrame)        {        }        protected override IMvxApplication CreateApp()        {            return new Core.App();        }    }}Modify the App.xaml.cs to use SetupYour App.xaml.cs provides the Universal Windows App ‘main application’ object - an object which owns the User Interface and receives some callbacks from the operating system during some key events in your application’s lifecycle.To modify this App.xaml.cs for MvvmCross, we need to:      modify the OnLaunched callback        remove these lines  // When the navigation stack isn't restored navigate to the first page,// configuring the new page by passing required information as a navigation// parameterif (!rootFrame.Navigate(typeof(MainPage), e.Arguments)){   throw new Exception(\"Failed to create initial page\");}  add these lines to allow it to create Setup, and to then initiate the IMvxAppStart Start navigationvar setup = new Setup(rootFrame);setup.Initialize();var start = Mvx.Resolve&lt;IMvxAppStart&gt;();start.Start();To do this, you will need to add these using lines:using MvvmCross.Core.ViewModels;using MvvmCross.Platform;Add your ViewCreate an initial Page for the WindowsCommon.Windows projectCreate a Views folder in the WindowsCommon.Windows projectWithin this folder, add a new ‘Basic Page’ and call it TipView.xamlYou will be asked if you want to add the missing ‘Common’ files automatically in order to support this ‘Basic Page’ - answer YesThe page will generate:  TipView.xaml  TipView.xaml.csA Common folder will be added containing:  NavigationHelper.cs  ObservableDictionary.cs  RelayCommand.cs  SuspensionManager.csConvert TipView into an MvvmCross base viewChange TipView so that it inherits from MvxWindowsPageChange:public class TipView : Pageto:public class TipView : MvxWindowsPageThis requires the addition of:using MvvmCross.WindowsCommon.Views;Persuade TipView to cooperate more reasonably with the MvxWindowsPage base classChange the OnNavigatedTo and OnNavigatedFrom methods so that they call their base class implementations:base.OnNavigatedTo(e);andbase.OnNavigatedFrom(e);Altogether this looks like:using TipCalc.UI.WindowsCommon.Common;using Windows.UI.Xaml.Navigation;using MvvmCross.WindowsCommon.Views;// The Basic Page item template is documented at http://go.microsoft.com/fwlink/?LinkId=234237namespace TipCalc.UI.WindowsCommon.Views{    /// &lt;summary&gt;    /// A basic page that provides characteristics common to most applications.    /// &lt;/summary&gt;    public sealed partial class TipView : MvxWindowsPage    {        private NavigationHelper navigationHelper;        private ObservableDictionary defaultViewModel = new ObservableDictionary();        /// &lt;summary&gt;        /// This can be changed to a strongly typed view model.        /// &lt;/summary&gt;        public ObservableDictionary DefaultViewModel        {            get { return this.defaultViewModel; }        }        /// &lt;summary&gt;        /// NavigationHelper is used on each page to aid in navigation and         /// process lifetime management        /// &lt;/summary&gt;        public NavigationHelper NavigationHelper        {            get { return this.navigationHelper; }        }        public TipView()        {            this.InitializeComponent();            this.navigationHelper = new NavigationHelper(this);            this.navigationHelper.LoadState += navigationHelper_LoadState;            this.navigationHelper.SaveState += navigationHelper_SaveState;        }        /// &lt;summary&gt;        /// Populates the page with content passed during navigation. Any saved state is also        /// provided when recreating a page from a prior session.        /// &lt;/summary&gt;        /// &lt;param name=\"sender\"&gt;        /// The source of the event; typically &lt;see cref=\"Common.NavigationHelper\"/&gt;        /// &lt;/param&gt;        /// &lt;param name=\"e\"&gt;Event data that provides both the navigation parameter passed to        /// &lt;see cref=\"Frame.Navigate(Type, Object)\"/&gt; when this page was initially requested and        /// a dictionary of state preserved by this page during an earlier        /// session. The state will be null the first time a page is visited.&lt;/param&gt;        private void navigationHelper_LoadState(object sender, LoadStateEventArgs e)        {        }        /// &lt;summary&gt;        /// Preserves state associated with this page in case the application is suspended or the        /// page is discarded from the navigation cache.  Values must conform to the serialization        /// requirements of &lt;see cref=\"Common.SuspensionManager.SessionState\"/&gt;.        /// &lt;/summary&gt;        /// &lt;param name=\"sender\"&gt;The source of the event; typically &lt;see cref=\"Common.NavigationHelper\"/&gt;&lt;/param&gt;        /// &lt;param name=\"e\"&gt;Event data that provides an empty dictionary to be populated with        /// serializable state.&lt;/param&gt;        private void navigationHelper_SaveState(object sender, SaveStateEventArgs e)        {        }        #region NavigationHelper registration        /// The methods provided in this section are simply used to allow        /// NavigationHelper to respond to the page's navigation methods.        ///         /// Page specific logic should be placed in event handlers for the          /// &lt;see cref=\"Common.NavigationHelper.LoadState\"/&gt;        /// and &lt;see cref=\"Common.NavigationHelper.SaveState\"/&gt;.        /// The navigation parameter is available in the LoadState method         /// in addition to page state preserved during an earlier session.        protected override void OnNavigatedTo(NavigationEventArgs e)        {            base.OnNavigatedTo(e);            navigationHelper.OnNavigatedTo(e);        }        protected override void OnNavigatedFrom(NavigationEventArgs e)        {            base.OnNavigatedFrom(e);            navigationHelper.OnNavigatedFrom(e);        }        #endregion    }}Edit the XAML layoutDouble click on the XAML fileThis will open the XAML editor within Visual Studio.I won’t go into much depth at all here about how to use the XAML or do the Windows data-binding. I’m assuming most readers are already coming from at least a little XAML background.To make the XAML inheritance match the MvxWindowsPage inheritance, change the outer root node of the Xaml file from:&lt;Page     ... &gt;    &lt;!-- content --&gt;&lt;/Page&gt;to:&lt;views:MvxWindowsPage    xmlns:views=\"using:MvvmCross.WindowsCommon.Views\"    ... &gt;    &lt;!-- content --&gt;&lt;/views:MvxWindowsPage&gt;To add the XAML user interface for our tip calculator, we will add a ContentPanel Grid just above the final &lt;/Grid&gt; in the existing XAML.  This will contain:  a StackPanel container, into which we add:          some TextBlock static text      a bound TextBox for the SubTotal      a bound Slider for the Generosity      a bound TextBlock for the Tip      This will produce XAML like:&lt;Grid x:Name=\"ContentPanel\" Grid.Row=\"1\" Margin=\"12,0,12,0\"&gt;    &lt;StackPanel&gt;        &lt;TextBlock            Text=\"SubTotal\" /&gt;        &lt;TextBox             Text=\"{Binding SubTotal, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\" /&gt;        &lt;TextBlock            Text=\"Generosity\" /&gt;        &lt;Slider             Value=\"{Binding Generosity,Mode=TwoWay}\"             SmallChange=\"1\"             LargeChange=\"10\"             Minimum=\"0\"             Maximum=\"100\" /&gt;        &lt;TextBlock            Text=\"Tip\" /&gt;        &lt;TextBlock             Text=\"{Binding Tip}\" /&gt;    &lt;/StackPanel&gt;&lt;/Grid&gt;Note that in XAML, OneWay binding is generally the default. To provide TwoWay binding we explicitly add Mode to our binding expressions: e.g. Value=\"{Binding Generosity, Mode=TwoWay}\"Note the binding for the TextBox uses UpdateSourceTrigger=PropertyChanged so that the SubTotal property of TipViewModel is updated immediately rather than when the TextBox loses focus.In the designer, this will look like:Create an initial Page for the WindowsCommon.WindowsPhone projectCreate a Views folder in the WindowsCommon.WindowsPhone projectWithin this folder, add a new ‘Basic Page’ and call it TipView.xamlYou will be asked if you want to add the missing ‘Common’ files automatically in order to support this ‘Basic Page’ - answer YesThe page will generate:  TipView.xaml  TipView.xaml.csA Common folder will be added containing:  NavigationHelper.cs  ObservableDictionary.cs  RelayCommand.cs  SuspensionManager.csConvert TipView into an MvvmCross base viewChange TipView so that it inherits from MvxWindowsPageChange:public class TipView : Pageto:public class TipView : MvxWindowsPageThis requires the addition of:using MvvmCross.WindowsCommon.Views;Persuade TipCalc to cooperate more reasonably with the MvxWindowsPage base classChange the OnNavigatedTo and OnNavigatedFrom methods so that they call their base class implementations:base.OnNavigatedTo(e);andbase.OnNavigatedFrom(e);Altogether this looks like:using TipCalc.UI.WindowsCommon.Common;using Windows.UI.Xaml.Navigation;using MvvmCross.WindowsCommon.Views;// The Basic Page item template is documented at http://go.microsoft.com/fwlink/?LinkID=390556namespace TipCalc.UI.WindowsCommon.Views{    /// &lt;summary&gt;    /// An empty page that can be used on its own or navigated to within a Frame.    /// &lt;/summary&gt;    public sealed partial class TipView : MvxWindowsPage    {        private NavigationHelper navigationHelper;        private ObservableDictionary defaultViewModel = new ObservableDictionary();        public TipView()        {            this.InitializeComponent();            this.navigationHelper = new NavigationHelper(this);            this.navigationHelper.LoadState += this.NavigationHelper_LoadState;            this.navigationHelper.SaveState += this.NavigationHelper_SaveState;        }        /// &lt;summary&gt;        /// Gets the &lt;see cref=\"NavigationHelper\"/&gt; associated with this &lt;see cref=\"Page\"/&gt;.        /// &lt;/summary&gt;        public NavigationHelper NavigationHelper        {            get { return this.navigationHelper; }        }        /// &lt;summary&gt;        /// Gets the view model for this &lt;see cref=\"Page\"/&gt;.        /// This can be changed to a strongly typed view model.        /// &lt;/summary&gt;        public ObservableDictionary DefaultViewModel        {            get { return this.defaultViewModel; }        }        /// &lt;summary&gt;        /// Populates the page with content passed during navigation.  Any saved state is also        /// provided when recreating a page from a prior session.        /// &lt;/summary&gt;        /// &lt;param name=\"sender\"&gt;        /// The source of the event; typically &lt;see cref=\"NavigationHelper\"/&gt;        /// &lt;/param&gt;        /// &lt;param name=\"e\"&gt;Event data that provides both the navigation parameter passed to        /// &lt;see cref=\"Frame.Navigate(Type, Object)\"/&gt; when this page was initially requested and        /// a dictionary of state preserved by this page during an earlier        /// session.  The state will be null the first time a page is visited.&lt;/param&gt;        private void NavigationHelper_LoadState(object sender, LoadStateEventArgs e)        {        }        /// &lt;summary&gt;        /// Preserves state associated with this page in case the application is suspended or the        /// page is discarded from the navigation cache.  Values must conform to the serialization        /// requirements of &lt;see cref=\"SuspensionManager.SessionState\"/&gt;.        /// &lt;/summary&gt;        /// &lt;param name=\"sender\"&gt;The source of the event; typically &lt;see cref=\"NavigationHelper\"/&gt;&lt;/param&gt;        /// &lt;param name=\"e\"&gt;Event data that provides an empty dictionary to be populated with        /// serializable state.&lt;/param&gt;        private void NavigationHelper_SaveState(object sender, SaveStateEventArgs e)        {        }        #region NavigationHelper registration        /// &lt;summary&gt;        /// The methods provided in this section are simply used to allow        /// NavigationHelper to respond to the page's navigation methods.        /// &lt;para&gt;        /// Page specific logic should be placed in event handlers for the          /// &lt;see cref=\"NavigationHelper.LoadState\"/&gt;        /// and &lt;see cref=\"NavigationHelper.SaveState\"/&gt;.        /// The navigation parameter is available in the LoadState method         /// in addition to page state preserved during an earlier session.        /// &lt;/para&gt;        /// &lt;/summary&gt;        /// &lt;param name=\"e\"&gt;Provides data for navigation methods and event        /// handlers that cannot cancel the navigation request.&lt;/param&gt;        protected override void OnNavigatedTo(NavigationEventArgs e)        {            base.OnNavigatedTo(e);            this.navigationHelper.OnNavigatedTo(e);        }        protected override void OnNavigatedFrom(NavigationEventArgs e)        {            base.OnNavigatedFrom(e);            this.navigationHelper.OnNavigatedFrom(e);        }        #endregion    }}Edit the XAML layoutDouble click on the XAML fileThis will open the XAML editor within Visual Studio.Again, I won’t go into much depth at all here about how to use the XAML or do the Windows data-binding. I’m assuming most readers are already coming from at least a little XAML background.To make the XAML inheritance match the MvxWindowsPage inheritance, change the outer root node of the Xaml file from:&lt;Page     ... &gt;    &lt;!-- content --&gt;&lt;/Page&gt;to:&lt;views:MvxWindowsPage    xmlns:views=\"using:MvvmCross.WindowsCommon.Views\"    ... &gt;    &lt;!-- content --&gt;&lt;/views:MvxWindowsPage&gt;To add the XAML user interface for our tip calculator, we will add a ContentPanel Grid in place of the ContentRoot Grid in the existing XAML.This Content Panel will include exactly the same XAML as we added to the WindowsCommon.WindowsPhone project except for the margins:  a StackPanel container, into which we add:          some TextBlock static text      a bound TextBox for the SubTotal      a bound Slider for the Generosity      a bound TextBlock for the Tip      This will produce XAML like:&lt;Grid Grid.Row=\"1\" x:Name=\"ContentRoot\" Margin=\"19,9.5,19,0\"&gt;    &lt;StackPanel&gt;        &lt;TextBlock            Text=\"SubTotal\" /&gt;        &lt;TextBox             Text=\"{Binding SubTotal, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\" /&gt;        &lt;TextBlock            Text=\"Generosity\" /&gt;        &lt;Slider             Value=\"{Binding Generosity,Mode=TwoWay}\"             SmallChange=\"1\"             LargeChange=\"10\"             Minimum=\"0\"             Maximum=\"100\" /&gt;        &lt;TextBlock            Text=\"Tip\" /&gt;        &lt;TextBlock             Text=\"{Binding Tip}\" /&gt;    &lt;/StackPanel&gt;&lt;/Grid&gt;Note that in XAML, OneWay binding is generally the default. To provide TwoWay binding we explicitly add Mode to our binding expressions: e.g. Value=\"{Binding Generosity, Mode=TwoWay}\"Note the binding for the TextBox uses UpdateSourceTrigger=PropertyChanged so that the SubTotal property of TipViewModel is updated immediately rather than when the TextBox loses focus.In the designer, this will look like:The navigation cacheUniversal Windows Phone apps seem to differ from Silverlight Windows Phone apps in that the default page navigation cache mechanism has changed. While Silverlight Windows Phone apps have built-in support for caching pages in forward/backward navigation, universal Windows Phone apps do not and need the NavigationHelper class and setting the NavigationCacheMode property of a Page to “Required” to provide this. This tutorial already showed you how to make use of the NavigationHelper and it is recommended that you do this even if you plan not to cache a view.If you do enable caching by setting the NavigationCacheMode property of a Page to “Required” and navigate backwards or forwards, the view is retrieved from the cache. This includes the ViewModel property of the view. While this doesn’t create a problem when navigating backwards, it does when you navigate forward! If you already have cached a view with a particular state (loading from the init parameters into the viewmodel), that state is also retrieved from the cache and you’ll end up with a view with an ‘old’ viewmodel state.To counter this, you must set the viewmodel to null when navigating to a page:protected override void OnNavigatedTo(NavigationEventArgs e){    if (e.NavigationMode == NavigationMode.New)        ViewModel = null;    base.OnNavigatedTo(e);    this.navigationHelper.OnNavigatedTo(e);}The Universal Windows App is complete!At this point you should be able to run your application.When you run the WindowsCommon.Windows project… you should see:When you run the WindowsCommon.WindowsPhone project… you should see:Moving on…There’s more we could do to make this User Interface nicer and to make the app richer… but for this first application, we will leave it here for now.But there are other ways of building Windows apps…",
            "url": "/documentation/tipcalc-tutorial/a-universal-windows-app-ui-project"
          }
          ,
        
          "documentation-tipcalc-tutorial-a-windows-universal-app-platform-project" :{
            "title": "A Windows Universal App Platform Project",
            "content": "We started with the goal of creating an app to help calculate what tip to leave in a restaurantWe had a plan to produce a UI based on this concept:To satisfy this we built a ‘Core’ Portable Class Library project which contained:  our ‘business logic’ - ICalculation  our ViewModel - TipViewModel  our App which contains the application wiring, including the start instructions.We then added User Interfaces for Xamarin.Android and Xamarin.iOS For our next project, let’s look at Windows, specifically Universal Windows Platform (UWP) Apps which run on Windows 10 and Windows 10 Mobile.To create a Windows UWP MvvmCross UI, you can use the Visual Studio project template wizards, but here we’ll instead build up a new project ‘from empty’, just as we did for the Core and other UI projects.Create a new Windows UWP ProjectAdd a new project to your solution - a ‘Blank App (Universal Windows)’ application with name TipCalc.UI.UWPWithin this, you’ll find the normal WindowsStore application constructs:  the ‘Properties’ folder with just the ‘AssemblyInfo’ file  the ‘Assets’ folder  the ‘Common’ folder  the App.Xaml ‘application’ object  the MainPage.Xaml and MainPage.Xaml.cs files that define the default Page for this app  the ‘Package.appxmanifest’ configuration file  the ‘project.json’  the debug private key for your developmentDelete MainPage.xamlNo-one really needs a MainPage :)Install MvvmCrossIn the Package Manager Console, enter…Install-Package MvvmCross.CoreAdd a reference to TipCalc.Core.csprojAdd a reference to your TipCalc.Core project - the project we created in the last step which included:  your Calculation service,  your TipViewModel  your App wiring.Add a Setup classJust as we said during the Android, iOS and WO construction Every MvvmCross UI project requires a Setup classThis class sits in the root namespace (folder) of our UI project and performs the initialization of the MvvmCross framework and your application, including:  the Inversion of Control (IoC) system  the MvvmCross data-binding  your App and its collection of ViewModels  your UI project and its collection of ViewsMost of this functionality is provided for you automatically. Within your Windows UWP UI project all you have to supply is:  your App - your link to the business logic and ViewModel content.For TipCalc here’s all that is needed in Setup.cs:using Windows.UI.Xaml.Controls;using MvvmCross.Core.ViewModels;using MvvmCross.WindowsUWP.Platform;namespace TipCalc.UI.UWP{public class Setup : MvxWindowsSetup{    public Setup(Frame rootFrame) : base(rootFrame)    {    }    protected override IMvxApplication CreateApp()    {        return new Core.App();    }}}Modify the App.xaml.cs to use SetupYour App.xaml.cs provides the Windows UWP ‘main application’ object - an object which owns the User Interface and receives some callbacks from the operating system during some key events in your application’s lifecycle.To modify this App.xaml.cs for MvvmCross, we need to:      modify the OnLaunched callback        replace this lines  // When the navigation stack isn't restored navigate to the first page,// configuring the new page by passing required information as a navigation// parameterrootFrame.Navigate(typeof(MainPage), e.Arguments);  with these lines to allow it to create Setup, and to then initiate the IMvxAppStart Start navigationvar setup = new Setup(rootFrame);setup.Initialize();var start = Mvx.Resolve&lt;IMvxAppStart&gt;();start.Start();After you’ve done this your code might look like:using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Runtime.InteropServices.WindowsRuntime;using Windows.ApplicationModel;using Windows.ApplicationModel.Activation;using Windows.Foundation;using Windows.Foundation.Collections;using Windows.UI.Xaml;using Windows.UI.Xaml.Controls;using Windows.UI.Xaml.Controls.Primitives;using Windows.UI.Xaml.Data;using Windows.UI.Xaml.Input;using Windows.UI.Xaml.Media;using Windows.UI.Xaml.Navigation;using MvvmCross.Core.ViewModels;using MvvmCross.Platform;namespace TipCalc.UI.UWP{/// &lt;summary&gt;/// Provides application-specific behavior to supplement the default Application class./// &lt;/summary&gt;sealed partial class App : Application{    /// &lt;summary&gt;    /// Initializes the singleton application object.  This is the first line of authored code    /// executed, and as such is the logical equivalent of main() or WinMain().    /// &lt;/summary&gt;    public App()    {        Microsoft.ApplicationInsights.WindowsAppInitializer.InitializeAsync(            Microsoft.ApplicationInsights.WindowsCollectors.Metadata |            Microsoft.ApplicationInsights.WindowsCollectors.Session);        this.InitializeComponent();        this.Suspending += OnSuspending;    }    /// &lt;summary&gt;    /// Invoked when the application is launched normally by the end user.  Other entry points    /// will be used such as when the application is launched to open a specific file.    /// &lt;/summary&gt;    /// &lt;param name=\"e\"&gt;Details about the launch request and process.&lt;/param&gt;    protected override void OnLaunched(LaunchActivatedEventArgs e)    {#if DEBUG        if (System.Diagnostics.Debugger.IsAttached)        {            this.DebugSettings.EnableFrameRateCounter = true;        }#endif        Frame rootFrame = Window.Current.Content as Frame;        // Do not repeat app initialization when the Window already has content,        // just ensure that the window is active        if (rootFrame == null)        {            // Create a Frame to act as the navigation context and navigate to the first page            rootFrame = new Frame();            rootFrame.NavigationFailed += OnNavigationFailed;            if (e.PreviousExecutionState == ApplicationExecutionState.Terminated)            {                //TODO: Load state from previously suspended application            }            // Place the frame in the current Window            Window.Current.Content = rootFrame;        }        if (rootFrame.Content == null)        {            //// When the navigation stack isn't restored navigate to the first page,            //// configuring the new page by passing required information as a navigation            //// parameter            //rootFrame.Navigate(typeof(MainPage), e.Arguments);            var setup = new Setup(rootFrame);            setup.Initialize();            var start = Mvx.Resolve&lt;IMvxAppStart&gt;();            start.Start();        }        // Ensure the current window is active        Window.Current.Activate();    }    /// &lt;summary&gt;    /// Invoked when Navigation to a certain page fails    /// &lt;/summary&gt;    /// &lt;param name=\"sender\"&gt;The Frame which failed navigation&lt;/param&gt;    /// &lt;param name=\"e\"&gt;Details about the navigation failure&lt;/param&gt;    void OnNavigationFailed(object sender, NavigationFailedEventArgs e)    {        throw new Exception(\"Failed to load Page \" + e.SourcePageType.FullName);    }    /// &lt;summary&gt;    /// Invoked when application execution is being suspended.  Application state is saved    /// without knowing whether the application will be terminated or resumed with the contents    /// of memory still intact.    /// &lt;/summary&gt;    /// &lt;param name=\"sender\"&gt;The source of the suspend request.&lt;/param&gt;    /// &lt;param name=\"e\"&gt;Details about the suspend request.&lt;/param&gt;    private void OnSuspending(object sender, SuspendingEventArgs e)    {        var deferral = e.SuspendingOperation.GetDeferral();        //TODO: Save application state and stop any background activity        deferral.Complete();    }}}Add your ViewCreate an initial PageCreate a Views folderWithin this folder, add a new ‘Blank Page’ and call it TipView.xamlYou will be asked if you want to add the missing ‘Common’ files automatically in order to support this ‘Basic Page’ - answer YesThe page will generate:  TipView.xaml  TipView.xaml.csTurn TipView into the MvvmCross View for TipViewModelChange:public class TipView : PageTo:public class TipView : MvxWindowsPageThis requires the addition of:```using MvvmCross.Uwp.Views;``Altogether this looks like:using MvvmCross.Uwp.Views;// The Blank Page item template is documented at http://go.microsoft.com/fwlink/?LinkId=234238namespace TipCalc.UI.UWP.Views{/// &lt;summary&gt;/// An empty page that can be used on its own or navigated to within a Frame./// &lt;/summary&gt;public sealed partial class TipView : MvxWindowsPage{    public TipView()    {        this.InitializeComponent();    }}}Edit the XAML layoutDouble click on the XAML fileThis will open the XAML editor within Visual Studio.I won’t go into much depth at all here about how to use the XAML or do the Windows data-binding. I’m assuming most readers are already coming from at least a little XAML background.To add the XAML user interface for our tip calculator, we will add a StackPanel within the existing Grid.  a StackPanel container, into which we add:          some TextBlock static text      a bound TextBox for the SubTotal      a bound Slider for the Generosity      a bound TextBlock for the Tip      The full page will look like:&lt;views:MvxWindowsPage    x:Class=\"TipCalc.UI.UWP.Views.TipView\"    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"    xmlns:local=\"using:TipCalc.UI.UWP.Views\"    xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"    xmlns:views=\"using MvvmCross.Uwp.Views\"    mc:Ignorable=\"d\"&gt;    &lt;Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\"&gt;        &lt;StackPanel Margin=\"12,0,12,0\"&gt;            &lt;TextBlock Text=\"SubTotal\" /&gt;            &lt;TextBox Text=\"{Binding SubTotal, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\" /&gt;            &lt;TextBlock Text=\"Generosity\" /&gt;            &lt;Slider Value=\"{Binding Generosity,Mode=TwoWay}\"                 SmallChange=\"1\"                 LargeChange=\"10\"                 Minimum=\"0\"                 Maximum=\"100\" /&gt;            &lt;TextBlock Text=\"Tip\" /&gt;            &lt;TextBlock Text=\"{Binding Tip}\" /&gt;        &lt;/StackPanel&gt;    &lt;/Grid&gt;&lt;/views:MvxWindowsPage&gt;Note that in XAML, OneWay binding is generally the default. To provide TwoWay binding we explicitly add Mode to our binding expressions: e.g. Value=\"{Binding Generosity,Mode=TwoWay}\"Note the binding for the TextBox uses UpdateSourceTrigger=PropertyChanged so that the SubTotal property of TipViewModel is updated immediately rather than when the TextBox loses focus.In the designer, this will look like:The Store UI is complete!At this point you should be able to run your application either on the Local Machine or in a Mobile emulator.When it starts… you should see this for the local machine:and in the mobile emulator:Moving on…There’s more we could do to make this User Interface nicer and to make the app richer… but for this first application, we will leave it here for now.Let’s move on to the next piece of Windows!",
            "url": "/documentation/tipcalc-tutorial/a-windows-universal-app-platform-project"
          }
          ,
        
          "documentation-tipcalc-tutorial-a-wpf-ui-project" :{
            "title": "A Wpf UI Project",
            "content": "We started with the goal of creating an app to help calculate what tip to leave in a restaurantWe had a plan to produce a UI based on this concept:To satisfy this we built a ‘Core’ Portable Class Library project which contained:  our ‘business logic’ - ICalculation  our ViewModel - TipViewModel  our App which contains the application wiring, including the start instructions.We then added User Interfaces for Xamarin.Android, Xamarin.iOS, Windows UWP, Windows 8.1 Univeral, Windows 8.1 and Windows Phone Silverlight apps.For our next project, let’s shift to Windows Desktop - via WPF - Windows Presentation Framework.Here we’ll build up a new project ‘from empty’, just as we did for the Core, Android, iOS, Windows Universal Apps, Windows Phone Silverlight and Windows Store projects.Obviously, to work with WPF, you will need to be working on the PC with Visual StudioCreate a new WPF ProjectAdd a new project to your solution - a ‘WPF Application’ with name TipCalc.UI.WpfImportant - make sure this is at least .Net4.5 - as this is the version required for PCL Profile259 - goodbye, XP!Within this, you’ll find the normal Wpf application constructs:  the ‘Properties’ folder with the ‘AssemblyInfo’ file, some resources and a settings file  the ‘App.Config’ configuration file  the App.Xaml ‘application’ object  the MainWindow.Xaml and MainWindows.Xaml.cs files that define the default Window for this appKeep MainWindow.xamlWe do actually want a MainWindow for this app :)Install MvvmCrossIn the Package Manager Console, enter…Install-Package MvvmCross.CoreAdd a reference to TipCalc.Core.csprojAdd a reference to your TipCalc.Core project - the project we created in the last step which included:  your Calculation service,  your TipViewModel  your App wiring.Add a Setup classJust as we said during the construction of the other UI projects Every MvvmCross UI project requires a Setup classThis class sits in the root namespace (folder) of our UI project and performs the initialization of the MvvmCross framework and your application, including:  the Inversion of Control (IoC) system  the MvvmCross data-binding  your App and its collection of ViewModels  your UI project and its collection of ViewsMost of this functionality is provided for you automatically. Within your Wpf UI project all you have to supply is:  your App - your link to the business logic and ViewModel contentFor TipCalc here’s all that is needed in Setup.cs:using System.Windows.Threading;using MvvmCross.Core.ViewModels;using MvvmCross.Wpf.Platform;using MvvmCross.Wpf.Views;namespace TipCalc.UI.Wpf{public class Setup : MvxWpfSetup{    public Setup(Dispatcher uiThreadDispatcher, IMvxWpfViewPresenter presenter) : base(uiThreadDispatcher, presenter)    {    }    protected override IMvxApplication CreateApp()    {        return new Core.App();    }}}Modify the App.xaml.cs to use SetupThere are other lifecycles and display techniques that you can use to write Wpf apps.However, here we will just use a ‘one window with one view’ approach.To achieve this, add some lines to the WPF App class that:  provide a private flag to determine if setup has already been donebool _setupComplete;  perform the setup - using a Simple presenter based on MainWindowvoid DoSetup(){    var presenter = new MvxSimpleWpfViewPresenter(MainWindow);    var setup = new Setup(Dispatcher, presenter);    setup.Initialize();    var start = Mvx.Resolve&lt;IMvxAppStart&gt;();    start.Start();    _setupComplete = true;}  override the OnActivated event to perform this startupprotected override void OnActivated(System.EventArgs e){    if (!_setupComplete)        DoSetup();    base.OnActivated(e);}After you’ve done this your App.xaml.cs might look like:using System.Windows;using MvvmCross.Core.ViewModels;using MvvmCross.Platform;using MvvmCross.Wpf.Views;namespace TipCalc.UI.Wpf{public partial class App : Application{    bool _setupComplete;    void DoSetup()    {        var presenter = new MvxSimpleWpfViewPresenter(MainWindow);        var setup = new Setup(Dispatcher, presenter);        setup.Initialize();        var start = Mvx.Resolve&lt;IMvxAppStart&gt;();        start.Start();        _setupComplete = true;    }    protected override void OnActivated(System.EventArgs e)    {        if (!_setupComplete)            DoSetup();        base.OnActivated(e);    }}}Add your ViewCreate the UserControlCreate a Views folderWithin this folder, add a new ‘User Control (WPF)’ and call it TipView.xamlThe page will generate:  TipView.xaml  TipView.xaml.csTurn TipView into the MvvmCross View for TipViewModelOpen the TipView.xaml.cs file.Change the class to inherit from MvxWpfViewpublic partial class TipView : MvxWpfViewAltogether this looks like:using MvvmCross.Wpf.Views;namespace TipCalc.UI.Wpf.Views{/// &lt;summary&gt;/// Interaction logic for TipView.xaml/// &lt;/summary&gt;public partial class TipView : MvxWpfView{    public TipView()    {        InitializeComponent();    }}}Edit the XAML layoutDouble click on the XAML fileThis will open the XAML editor within Visual Studio.Just as with Windows Uwp, I won’t go into much depth at all here about how to use the XAML or do the Windows data-binding. I’m assuming most readers are already coming from at least a little XAML background.Change the root node from:&lt;UserControl          ...&lt;/UserControl&gt;to:&lt;views:MvxWpfView \txmlns:views=\"clr-namespace:MvvmCross.Wpf.Views;assembly=MvvmCross.Wpf\"                          ...&lt;/views:MvxWpfView&gt;To add the XAML user interface for our tip calculator, we will add exactly the same XAML as we added inside the ContentPanel grid for the Windows UWP example. This includes:  a StackPanel container, into which we add:          some TextBlock static text      a bound TextBox for the SubTotal      a bound Slider for the Generosity      a bound TextBlock for the Tip      This will produce finished XAML like:&lt;views:MvxWpfView    x:Class=\"TipCalc.UI.Wpf.Views.TipView\"    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"     xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"     xmlns:local=\"clr-namespace:TipCalc.UI.Wpf.Views\"    xmlns:views=\"clr-namespace:MvvmCross.Wpf.Views;assembly=MvvmCross.Wpf\"    mc:Ignorable=\"d\"     d:DesignHeight=\"300\" d:DesignWidth=\"300\"&gt;    &lt;Grid&gt;        &lt;StackPanel&gt;            &lt;TextBlock Text=\"SubTotal\" /&gt;            &lt;TextBox Text=\"{Binding SubTotal, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}\" /&gt;            &lt;TextBlock Text=\"Generosity\" /&gt;            &lt;Slider                 Value=\"{Binding Generosity, Mode=TwoWay}\"                 SmallChange=\"1\"                 LargeChange=\"10\"                 Minimum=\"0\"                 Maximum=\"100\" /&gt;             &lt;TextBlock Text=\"Tip\" /&gt;            &lt;TextBlock Text=\"{Binding Tip}\" /&gt;        &lt;/StackPanel&gt;    &lt;/Grid&gt;&lt;/views:MvxWpfView&gt;Note that in XAML, OneWay binding is generally the default. To provide TwoWay binding we explicitly add Mode to our binding expressions: e.g. Value=\"{Binding Generosity,Mode=TwoWay}\"In the designer, this will look like:The Wpf UI is complete!At this point you should be able to run your application.When it starts… you should see:Moving on…There’s more we could do to make this User Interface nicer and to make the app richer… but for this first application, we will leave it here for now.And actually… that’s the end of our journey through this first app.One day soon there will be more steps - a step for Mac desktop, a step for XBox, a step for TV, etc - but for now this is the end.",
            "url": "/documentation/tipcalc-tutorial/a-wpf-ui-project"
          }
          ,
        
          "documentation-tipcalc-tutorial-a-xamarinandroid-ui-project" :{
            "title": "A Xamarin.Android UI Project",
            "content": "We started with the goal of creating an app to help calculate what tip to leave in a restaurant.We had a plan to produce a UI based on this concept:To satisfy this we built a ‘Core’ Portable Class Library project which contained:  Our ‘business logic’ - ICalculation  Our ViewModel - TipViewModel  Our App which contains the application wiring, including the start instructions.We’re now ready to add out first User Interface.So… let’s start with Android.To create an Android MvvmCross UI, you can use the Visual Studio project template wizards, but here we’ll instead build up a new project ‘from empty’, just as we did for the Core project.Create a new Android UI ProjectAdd a new project to your solution - a ‘Blank App (Android)’ application with name TipCalc.UI.DroidWithin this, you’ll find the normal Android application constructs:  the Assets folder  the Resources folder  the MainActivity.csDelete MainActivity.csNo-one really needs a MainActivity :)Also, delete Main.axml in the /resources/Layout folder.Install MvvmCrossIn the Package Manager Console, enter…Install-Package MvvmCross.BindingAdd a reference to TipCalc.Core.csprojAdd a reference to your TipCalc.Core project - the project we created in the last step which included:  Your Calculation service,  Your TipViewModel  Your App wiring.Add a Setup classEvery MvvmCross UI project requires a Setup class.This class sits in the root namespace (folder) of our UI project and performs the initialization of the MvvmCross framework and your application, including:  The Inversion of Control (IoC) system  The MvvmCross data-binding  Your App and its collection of ViewModels  Your UI project and its collection of ViewsMost of this functionality is provided for you automatically. Within your Droid UI project all you have to supply are:  your App - your link to the business logic and ViewModel contentFor TipCalc here’s all that is needed in Setup.cs:using Android.Content;using MvvmCross.Core.ViewModels;using MvvmCross.Droid.Platform;using TipCalc.Core;namespace TipCalc.UI.Droid{public class Setup : MvxAndroidSetup{    public Setup(Context applicationContext)    : base(applicationContext)    {    }    protected override IMvxApplication CreateApp()    {        return new App();    }}}Add your ViewAdd the Android Layout XML (AXML)This tutorial doesn’t attempt to give an introduction to Android XML layout.Instead all I’ll say here is the bare minimum. If you are new to Android, then you can find out more about Android XML from lots of places including the official documentation at this site. If you are coming from a XAML background - you are a XAMLite - then I’ll include some simple XAML-AXML comparisons to help you out.To achieve the basic layout:      We’ll add a new AXML file - View_Tip.axml in the /Resources/Layout folder        We’ll edit this using either the Xamarin Android designer or the Visual Studio XML editor - the designer gives us a visual display, while the VS editor sometimes gives us XML Intellisense.  &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:orientation=\"vertical\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\" /&gt;  We’ll add a local app namespace - http://schemas.android.com/apk/res-auto - this is just like adding a namespace in XAML.&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:local=\"http://schemas.android.com/apk/res-auto\"    android:orientation=\"vertical\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\" /&gt;      Notice that the LinearLayout has by default a horizontal orientation - for XAMLites, this layout is just like a StackPanel except that it is very important to specify the vertical orientation        Within this layout we’ll add some TextViews to provide some static text labels - for XAMLites, these are like TextBlocks  &lt;TextView    android:layout_width=\"match_parent\"    android:layout_height=\"wrap_content\"    android:text=\"SubTotal\" /&gt;&lt;TextView    android:layout_width=\"match_parent\"    android:layout_height=\"wrap_content\"    android:text=\"Generosity\" /&gt;&lt;TextView    android:layout_width=\"match_parent\"    android:layout_height=\"wrap_content\"    android:text=\"Tip to leave\" /&gt;  We’ll also add a short, wide View with a yellow background to provide a small amount of chrome:&lt;View    android:layout_width=\"match_parent\"    android:layout_height=\"1dp\"    android:background=\"#ffff00\" /&gt;      We’ll add some Views for data display and entry, and we’ll databind these Views to properties in our TipViewModel          An EditText for text data entry of the SubTotal - for XAMLites, this is a TextBox      &lt;EditText    android:layout_width=\"match_parent\"    android:layout_height=\"wrap_content\"    local:MvxBind=\"Text SubTotal\" /&gt;  A SeekBar for touch/slide entry of the Generosity - for XAMLites, this is like a ProgressBar:&lt;SeekBar    android:layout_width=\"match_parent\"    android:layout_height=\"wrap_content\"    android:max=\"100\"    local:MvxBind=\"Progress Generosity\" /&gt;  We’ll add a TextView to display the Tip that results from the calculation:&lt;TextView    android:layout_width=\"match_parent\"    android:layout_height=\"wrap_content\"    local:MvxBind=\"Text Tip\" /&gt;Put together, this looks like:&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:local=\"http://schemas.android.com/apk/res-auto\"    android:orientation=\"vertical\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"&gt;    &lt;TextView          android:layout_width=\"match_parent\"          android:layout_height=\"wrap_content\"          android:text=\"SubTotal\" /&gt;    &lt;EditText          android:layout_width=\"match_parent\"          android:layout_height=\"wrap_content\"          local:MvxBind=\"Text SubTotal\" /&gt;    &lt;TextView          android:layout_width=\"match_parent\"          android:layout_height=\"wrap_content\"          android:text=\"Generosity\" /&gt;    &lt;SeekBar          android:layout_width=\"match_parent\"          android:layout_height=\"wrap_content\"          android:max=\"100\"          local:MvxBind=\"Progress Generosity\" /&gt;    &lt;View          android:layout_width=\"match_parent\"          android:layout_height=\"1dp\"          android:background=\"#ffff00\" /&gt;    &lt;TextView          android:layout_width=\"match_parent\"          android:layout_height=\"wrap_content\"          android:text=\"Tip to leave\" /&gt;    &lt;TextView          android:layout_width=\"match_parent\"          android:layout_height=\"wrap_content\"          local:MvxBind=\"Text Tip\" /&gt;&lt;/LinearLayout&gt;About the data-binding syntaxEach of the data-binding blocks within our first sample looks similar:local:MvxBind=\"Text SubTotal\"What this line means is:  Data-bind:          The property Text on the View      To the property SubTotal on the DataContext - which in this case will be a TipViewModel        So:          Whenever the TipViewModel calls RaisePropertyChanged on SubTotal then the View should update      And whenever the user enters text into the View then the SubTotal value should be set on the TipViewModel      Note that this TwoWay binding is different to XAML where generally the default BindingMode is only OneWay.In later topics, we’ll return to show you more options for data-binding, including how to use ValueConverters, but for now all our binding uses this simple ViewProperty ViewModelProperty syntax.Add the View classWith our AXML layout complete, we can now add the C# Activity which is used to display this content. For developers coming from XAML backgrounds, these Activity classes are roughly equivalent to Page objects in WindowsPhone on WindowsStore applications - they own the ‘whole screen’ and have a lifecycle which means that only one of them is shown at any one time.To create our Activity - which will also be our MVVM View:      Create a Views folder within your TipCalc.UI.Droid project        Within this folder create a new C# class - TipView  Not that the name of this class MUST match the name of the viewmodel. As our viewmodel is called TipViewModel our class must be named TipView).      This class will:          Inherit from MvxActivity:      public class TipCalcView : MvxActivity\"  Be marked with the Xamarin.Android Activity attribute, marking it as the MainLauncher for the project:[Activity(Label = \"Tip\", MainLauncher=true)]  Use OnViewModelSet to inflate its ContentView from the AXML - this will use a resource identifier generated by the Android and Xamarin tools.protected override void OnViewModelSet(){    SetContentView(Resource.Layout.View_Tip);}As a result this completed class is very simple:using Android.App;using MvvmCross.Droid.Views;namespace TipCalc.UI.Droid.Views{[Activity(Label = \"Tip\", MainLauncher = true)]public class TipView : MvxActivity{    protected override void OnViewModelSet()    {        SetContentView(Resource.Layout.View_Tip);    }}}The Android UI is complete!At this point you should be able to run your application.When it starts… you should see:If you then want to make it ‘more beautiful’, then try adding a few attributes to some of your AXML - things like:    android:background=\"#00007f\"    android:textColor=\"#ffffff\"    android:textSize=\"24dp\"    android:layout_margin=\"30dp\"    android:padding=\"20dp\"    android:layout_marginTop=\"10dp\"Within a very short time, you should hopefully be able to create something ‘styled’…… but actually making it look ‘nice’ might take some design skills!Moving onThere’s more we could do to make this User Interface nicer and to make the app richer… but for this first application, we will leave it here for now.Let’s move on to Xamarin.iOS and to Windows!",
            "url": "/documentation/tipcalc-tutorial/a-xamarinandroid-ui-project"
          }
          ,
        
          "documentation-tipcalc-tutorial-a-xamarinios-ui-project" :{
            "title": "A Xamarin.iOS UI Project",
            "content": "We started with the goal of creating an app to help calculate what tip to leave in a restaurantWe had a plan to produce a UI based on this concept:To satisfy this we built a ‘Core’ Portable Class Library project which contained:  our ‘business logic’ - ICalculation  our ViewModel - TipViewModel  our App which contains the application wiring, including the start instructions.We then added our first User Interface - for Xamarin.Android:For our next project, let’s shift to Xamarin.iOS.To create an iPhone MvvmCross UI, you can use the Visual Studio project template wizards, but here we’ll instead build up a new project ‘from empty’, just as we did for the Core and Android projects.Also, to work with iPhone, for now we will switch to working on the Mac with Xamarin StudioCreate a new iOS UI ProjectAdd a new project to your solution - a ‘iOS’ -&gt; ‘Single View App’ application with name TipCalc.UI.iOSWithin this, you’ll find the normal iOS application constructs:  the Resources folder  the AppDelegate.cs class  the Entitlements.plist ‘configuration’ information  the Info.plist ‘configuration’ information  the Main.cs class  the Main.storyboard viewInstall MvvmCrossClick the Add NuGet Packages... item in the Project menu.  Install MvvmCross.Binding.Add a reference to TipCalc.Core.csprojAdd a reference to your TipCalc.Core project - the project we created in the last step which included:  your Calculation service,  your TipViewModel  your App wiring.Add a Setup classJust as we said during the Android construction Every MvvmCross UI project requires a Setup classThis class sits in the root namespace (folder) of our UI project and performs the initialization of the MvvmCross framework and your application, including:  the Inversion of Control (IoC) system  the MvvmCross data-binding  your App and its collection of ViewModels  your UI project and its collection of ViewsMost of this functionality is provided for you automatically. Within your iOS UI project all you have to supply are:  your App - your link to the business logic and ViewModel contentFor TipCalc here’s all that is needed in Setup.cs:using MvvmCross.iOS.Platform;using MvvmCross.iOS.Views.Presenters;using MvvmCross.Core.ViewModels;using TipCalc.Core;namespace TipCalc.UI.iOS{public class Setup : MvxIosSetup{    public Setup(MvxApplicationDelegate appDelegate, IMvxIosViewPresenter presenter)    : base(appDelegate, presenter)    {    }    protected override IMvxApplication CreateApp ()    {        return new App();    }}}Modify the AppDelegate to use SetupYour AppDelegate provides a set of callback that iOS uses to inform you about events in your application’s lifecycle.To use this AppDelegate within MvvmCross, we need to:      modify it so that it inherits from MvxApplicationDelegate instead of UIApplicationDelegate      public partial class AppDelegate : MvxApplicationDelegate            modify it so that the method that is called on startup (FinishedLaunching) does some UI application setup:          create a new presenter - this is the class that will determine how Views are shown - for this sample, we choose a ‘standard’ one:      var presenter = new MvxIosViewPresenter(this, Window);  create and call Initialize on a Setup:var setup = new Setup(this, presenter);setup.Initialize();  with Setup completed, use the Mvx Inversion of Control container in order to find and Start the IMvxAppStart object:var startup = Mvx.Resolve&lt;IMvxAppStart&gt;();startup.Start();Together, this looks like:using Foundation;using UIKit;using MvvmCross.iOS.Platform;using MvvmCross.iOS.Views.Presenters;using MvvmCross.Platform;using MvvmCross.Core.ViewModels;namespace TipCalc.UI.iOS{[Register(\"AppDelegate\")]public class AppDelegate : MvxApplicationDelegate{    public override UIWindow Window {        get;        set;    }    public override bool FinishedLaunching(UIApplication application, NSDictionary launchOptions)    {        Window = new UIWindow(UIScreen.MainScreen.Bounds);        var presenter = new MvxIosViewPresenter(this, Window);        var setup = new Setup(this, presenter);        setup.Initialize();        var startup = Mvx.Resolve&lt;IMvxAppStart&gt;();        startup.Start();        Window.MakeKeyAndVisible();        return true;    }}}Add your ViewCreate an initial UIViewControllerCreate a Views folderWithin this, add a new ‘View Controller’ and call it TipViewThis will generate:  TipView.cs  TipView.designer.cs  TipView.xibEdit the XIB layoutDouble click on the XIB file to edit it.Just as we did with Android, I won’t go into depth here about how to use the XIB iOS editor - instead I’ll just cover the bare basics, and I’ll also try to provide some comparisons for those familiar with XAML.Drag/drop from the ‘Toolbox’ to add:  some Labels for showing static text - these are like TextBlocks  a Text Field named SubTotalTextField for editing the SubTotal - this is like a TextBox  a Slider named GenerositySlider for editing the Generosity - this is like a ProgressBar  a Label named TipLabel for showing the Tip result  - this is like a TextBlockSet the Maximum Value of the Slider to ‘100’.Using drag and drop, you should be able to quite quickly generate a design similar to:Edit TipView.csBecause we want our TipView to be not only a UIViewController but also an Mvvm View, then change the inheritance of TipView so that it inherits from MvxViewController.public class TipView : MvxViewController&lt;TipViewModel&gt;The generic parameter to MvxViewController is used to link TipView to TipViewModel.To add the data-binding code, go to the ViewDidLoad method in your TipView class. This is a method that will be called after the View is loaded within iOS but before it is displayed on the screen.This makes ViewDidLoad a perfect place for us to call some data-binding extension methods which will specify how we want the UI data-bound to the ViewModel:public override void ViewDidLoad(){    base.ViewDidLoad();    this.CreateBinding(TipLabel).To((TipViewModel vm) =&gt; vm.Tip).Apply();    this.CreateBinding(SubTotalTextField).To((TipViewModel vm) =&gt; vm.SubTotal).Apply();    this.CreateBinding(GenerositySlider).To((TipViewModel vm) =&gt; vm.Generosity).Apply();}What this code does is to generate ‘in code’ exactly the same type of data-binding information as we generated ‘in XML’ in Android.Note that before the calls to this.Bind are made, then we first call base.ViewDidLoad(). This is important because base.ViewDidLoad() is where MvvmCross locates the TipViewModel that this TipView will bind to.Altogether this looks like:using MvvmCross.Binding.BindingContext;using MvvmCross.iOS.Views;using TipCalc.Core.ViewModels;namespace TipCalc.UI.iOS{public partial class TipView : MvxViewController&lt;TipViewModel&gt;{    public TipView() : base(\"TipView\", null)    {    }    public override void ViewDidLoad()    {        base.ViewDidLoad();        this.CreateBinding(TipLabel).To((TipViewModel vm) =&gt; vm.Tip).Apply();        this.CreateBinding(SubTotalTextField).To((TipViewModel vm) =&gt; vm.SubTotal).Apply();        this.CreateBinding(GenerositySlider).To((TipViewModel vm) =&gt; vm.Generosity).Apply();    }}}Binding in Xamarin.iOSYou will no doubt have noticed that data-binding in iOS looks very different to the way it looked in Android - and to what you may have expected from XAML.This is because the XIB format used in iOS is a lot less human manipulable and extensible than the XML formats used in Android AXML and Windows XAML - so it makes more sense to use C# rather than the XIB to register our bindings.Within this section of the tutorial all of our iOS bindings look like:this.CreateBinding(TipLabel).To((TipViewModel vm) =&gt; vm.Tip).Apply();what this line means is:  bind the TipLabel’s default binding property - which happens to be a property called Text  to the ViewModel’s Tip propertyAs with Android, this will be a TwoWay binding by default - which is different to what XAML developers may expect to see.If you had wanted to specify the TipLabel property to use instead of relying on the default, then you could have done this with:this.CreateBinding(TipLabel).For(label =&gt; label.Text).To((TipViewModel vm) =&gt; vm.Tip).Apply();In later topics we’ll cover more on binding in iOS, including more on binding to non-default fields; other code-based binding code mechanisms; custom bindings; using ValueConverters; and creating bound sub-views.The iOS UI is complete!At this point you should be able to run your application.When it starts… you should see:This seems to work perfectly, although you may notice that if you tap on the SubTotal property and start entering text, then you cannot afterwards close the keyboard.This is a View concern - it is a UI problem. So we can fix it just in the iOS UI code - in this View. For example, to fix this here, you can add a gesture recognizer to the end of the ViewDidLoad method like:View.AddGestureRecognizer(new UITapGestureRecognizer(() =&gt; {    this.SubTotalTextField.ResignFirstResponder();}));Moving on…There’s more we could do to make this User Interface nicer and to make the app richer… but for this first application, we will leave it here for now.Let’s move on to Windows!",
            "url": "/documentation/tipcalc-tutorial/a-xamarinios-ui-project"
          }
          ,
        
          "documentation-tipcalc-tutorial-the-core-project" :{
            "title": "The Core Project",
            "content": "MvvmCross application’s are normally structured with:  one shared ‘core’ Portable Class Library (PCL) project          containing as much code as possible: models, view models, services, converters, etc        one UI project per platform          each containing the bootstrap and view-specific code for that platform      Normally, you start development from the core project - and that’s exactly what we’ll do here.To create the core, you can use the Visual Studio project template wizards, but here we’ll instead build up a new project ‘from empty’.Create the new Portable Class Library            Using Visual Studio, create your new Class Library (Portable) project using the File      New Project wizard.      Call it something like TipCalc.Core.csproj and name the solution TipCalc.When asked to choose platforms, select .NET Framework 4.5, Windows 8, Windows Phone Silverlight 8, Windows Phone 8.1, Xamarin.Android and Xamarin.iOS - this will ensure that the PCL is in Profile259.  If Visual Studio stops you selecting these targets with the error ‘The selection does not match any portable APIs’ then use the workaround described here: http://danrigby.com/2014/04/10/windowsphone81-pcl-xamarin-fix/Profile259 defines a small subset of .Net including:  Microsoft.CSharp  mscorelib  System.Collections  System.ComponentModel  System.Core  System.Diagnostics  System  System.Globalization  System.IO  System.Linq  System.Net  System.ObjectModel  System.Reflection  System.Resources.ResourceManager  System.Runtime  System.Security.Principal  System.ServiceModel.Web  System.Text.Encoding  System.Text.RegularExpressions  System.Threading  System.Windows  System.XmlTo see the full list of assemblies, look in C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETPortable\\v4.5\\Profile\\Profile259Importantly for us this Profile259 includes everything we need to build our Mvvm applications.Delete Class1.csNo-one really needs a Class1 :)Install MvvmCrossIn the Package Manager Console, enter…Install-Package MvvmCross.CoreAdd the Tip Calculation serviceCreate a folder called ‘Services’Within this folder create a new Interface which will be used for calculating tips:namespace TipCalc.Core.Services{    public interface ICalculation    {        double TipAmount(double subTotal, int generosity);    }}Within this folder create an implementation of this interface:namespace TipCalc.Core.Services{    public class Calculation : ICalculation    {        public double TipAmount(double subTotal, int generosity)        {            return subTotal * ((double)generosity)/100.0;        }    }}This provides us with some simple business logic for our appAdd the ViewModelAt a sketch level, we want a user interface that:  uses:          our calculation service to calculate the tip        has inputs of:          the current bill (the subTotal)      a feeling for how much tip we’d like to leave (the generosity)        has output displays of:          the calculated tip to leave      To represent this user interface we need to build a ‘model’ for the user interface - which is, of course, a ‘ViewModel’Within MvvmCross, all ViewModels should inherit from MvxViewModel.So now create a ViewModels folder in our project, and in this folder add a new TipViewModel class like:using MvvmCross.Core.ViewModels;using TipCalc.Core.Services;namespace TipCalc.Core.ViewModels{    public class TipViewModel : MvxViewModel    {        readonly ICalculation _calculation;        public TipViewModel(ICalculation calculation)        {            _calculation = calculation;        }        public override void Start()        {            _subTotal = 100;            _generosity = 10;            Recalculate();            base.Start();        }        double _subTotal;        public double SubTotal        {            get {                return _subTotal;            }            set            {                _subTotal = value;                RaisePropertyChanged(() =&gt; SubTotal);                Recalculate();            }        }        int _generosity;        public int Generosity        {            get {                return _generosity;            }            set            {                _generosity = value;                RaisePropertyChanged(() =&gt; Generosity);                Recalculate();            }        }        double _tip;        public double Tip        {            get {                return _tip;            }            set            {                _tip = value;                RaisePropertyChanged(() =&gt; Tip);            }        }        void Recalculate()        {            Tip = _calculation.TipAmount(SubTotal, Generosity);        }    }}For many of you, this TipViewModel will already make sense to you. If it does then skip ahead to ‘Add the App(lication)’. If not, then here are some simple explanations:  the TipViewModel is constructed with an ICalculation servicereadonly ICalculation _calculation;public TipViewModel(ICalculation calculation){    _calculation = calculation;}  after construction, the TipViewModel will be started - during this it sets some initial values.public override void Start(){    // set some start values    SubTotal = 100.0;    Generosity = 10;    Recalculate();    base.Start();}  the view data held within the TipViewModel is exposed through properties.          Each of these properties is backed by a private member variable      Each of these properties has a get and a set      The set accessor for Tip is marked private      All of the set accessors call RaisePropertyChanged to tell the base MvxViewModel that the data has changed      The SubTotal and Generosity set accessors also call Recalculate()      double _subTotal;public double SubTotal{    get {        return _subTotal;    }    set    {        _subTotal = value;        RaisePropertyChanged(() =&gt; SubTotal);        Recalculate();    }}int _generosity;public int Generosity{    get {        return _generosity;    }    set    {        _generosity = value;        RaisePropertyChanged(() =&gt; Generosity);        Recalculate();    }}double _tip;public double Tip{    get {        return _tip;    }    set    {        _tip = value;        RaisePropertyChanged(() =&gt; Tip);    }}  The Recalculate method uses the _calculation service to update Tip from the current values in SubTotal and Generosityvoid Recalculate(){    Tip = _calculation.TipAmount(SubTotal, Generosity);}Add the App(lication)With our Calculation service and TipViewModel defined, we now just need to add the main App code.This code;  will sit in a single class within the root folder of our PCL core project.  this class will inherits from the MvxApplication class  this class is normally just called App  this class is responsible for providing:          registration of which interfaces and implementations the app uses      registration of which ViewModel the App will show when it starts      control of how ViewModels are located - although most applications normally just use the default implementation of this supplied by the base MvxApplication class.      ‘Registration’ here means creating an ‘Inversion of Control’ - IoC - record for an interface. This IoC record tells the MvvmCross framework what to do when anything asks for an instance of that interface.For our Tip Calculation app:  we register the Calculation class to implement the ICalculation serviceMvx.RegisterType&lt;ICalculation, Calculation&gt;();this line tells the MvvmCross framework that whenever any code requests an ICalculation reference, then the framework should create a new instance of Calculation. Note the single static class Mvx which acts as a single place for both registering and resolving interfaces and their implementations.  we want the app to start with the TipViewModelvar appStart = new MvxAppStart&lt;TipViewModel&gt;();Mvx.RegisterSingleton&lt;IMvxAppStart&gt;(appStart);this line tells the MvvmCross framework that whenever any code requests an IMvxAppStart reference, then the framework should return that same appStart instance.So here’s what App.cs looks like:using MvvmCross.Core.ViewModels;using MvvmCross.Platform;using TipCalc.Core.Services;using TipCalc.Core.ViewModels;namespace TipCalc.Core{    public class App : MvxApplication    {        public App()        {            Mvx.RegisterType&lt;ICalculation, Calculation&gt;();            Mvx.RegisterSingleton&lt;IMvxAppStart&gt;(new MvxAppStart&lt;TipViewModel&gt;());        }    }}Note: What is ‘Inversion of Control’?We won’t go into depth here about what IoC - Inversion of Control - is.Instead, we will just say that:  Within each MvvmCross application, there is a single special object - a singleton  This singleton lives within the Mvx static class.  The application startup code can use the Mvx.Register methods in order to specify what will implement interfaces during the lifetime of the app.  After this has been done, then later in the life when any code needs an interface implementation, then it can request one using the Mvx.Resolve methods.One common pattern that is seen is ‘constructor injection’:  Our TipViewModel uses this pattern.  It presents a constructor like: public TipViewModel(ICalculation calculation).  When the app is running a part of the MvvmCross framework called the ViewModelLocator is used to find and create ViewModels  when a TipViewModel is needed, the ViewModelLocator uses a call to Mvx.IocConstruct to create one.  This Mvx.IocConstruct call creates the TipViewModel using the ICalculation implementation that it finds using Mvx.ResolveThis is obviously only a very brief introduction.If you would like to know more, please see look up some of the excellent tutorials out there on the Internet - like http://joelabrahamsson.com/inversion-of-control-an-introduction-with-examples-in-net/The Core project is complete :)Just to recap the steps we’ve followed:  We created a new PCL project using Profile259  We added the MvvmCross libraries  We added a ICalculation interface and implementation pair  We added a TipViewModel which:          inherited from MvxViewModel      used ICalculation      presented a number of public properties each of which called RaisePropertyChanged        We added an App which:          inherited from MvxApplication      registered the ICalculation/Calculation pair      registered a special start object for IMvxAppStart      These are the same steps that you need to go through for every new MvvmCross application.Moving onNext we’ll start looking at how to add a first UI to this MvvmCross application.",
            "url": "/documentation/tipcalc-tutorial/the-core-project"
          }
          ,
        
          "documentation-tipcalc-tutorial-the-tip-calc-navigation" :{
            "title": "The TipCalc navigation",
            "content": "This article will cover some of the techniques available within MvvmCross for navigating between Page-level ViewModels.What do we mean by Page?MvvmCross was born for making modern Mobile apps - for building apps for iPhone, Android, and Windows Phone.These apps are generally Page-based - that is they generally involve User-Interfaces which show a single page at a time and which often involve the user experience moving forwards and backwards through the application workflow.There are variations on this, especially for Tabbed or Pivoting user interfaces; for Dialogs; and for Split displays. We’ll introduce some of these briefly at the end of this article.The initial navigationIn the TipCalc walkthough, we built most of our initial MvvmCross applications to use the IMvxAppStart interface as a starting mechanism.An implementation of this interface was registered by the core App like: Mvx.RegisterSingleton&lt;IMvxAppStart&gt;(new MvxAppStart&lt;TipViewModel&gt;());This implementation was then used in the AppDelegate and App.Xaml start sequences within the UI projects.The exception was Android - where we explicitly specified one of our Activities/Views with the MainLauncher=true property value within the [Activity] attribute.To use the IMvxAppStart instruction in Android as well, the easiest way is to add a splashscreen which will be displayed briefly while the application starts.Adding a splashscreen to an Android appTo add a splashscreen:      Remove the MainLauncher=true property from any existing Activity attributes.        Add some simple AXML for a splashscreen. For example, a very simple screen might be:      &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;    &lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"        android:layout_width=\"fill_parent\"        android:layout_height=\"fill_parent\"&gt;        &lt;TextView            android:layout_width=\"wrap_content\"            android:layout_height=\"wrap_content\"            android:gravity=\"center\"            android:text=\"loading...\" /&gt;    &lt;/FrameLayout&gt;Note that this splashscreen will be displayed before the MvvmCross system is fully booted - so you cannot use data-binding within the splashscreen AXML.  Add a simple Activity for the splashscreen. This will contain C# like:using Android.App;using MvvmCross.Droid.Views;namespace CalcApp.UI.Droid{[Activity(Label = \"My App\", MainLauncher = true, NoHistory = true, Icon = \"@drawable/icon\")]public class SplashScreenActivity    : MvxSplashScreenActivity{    public SplashScreenActivity()    : base(Resource.Layout.SplashScreen)    {    }}}This SplashScreenActivity uses the base MvxSplashScreenActivity which will start the MvvmCross framework and, when initialization is complete, will then use the IMvxAppStart interface.Supporting more advanced startupThe TipCalc app has a very simple startup instruction:Mvx.RegisterSingleton&lt;IMvxAppStart&gt;(new MvxAppStart&lt;TipViewModel&gt;()); This was an instruction to: always start the app with a TipViewModelIf you wanted instead to start with a different ViewModel - e.g. with LoginViewModel then you’d have to replace this with:Mvx.RegisterSingleton&lt;IMvxAppStart&gt;(new MvxAppStart&lt;LoginViewModel&gt;());If you wanted instead to start with some logic, then you can do this by providing a custom IMvxAppStart implementation - e.g.:public class CustomAppStart    : MvxNavigatingObject    , IMvxAppStart{    private readonly ILoginService _service;    public CustomAppStart(ILoginService service)    {        _service = service;    }    public void Start(object hint = null)    {        if (!_service.IsLoggedIn)        {            ShowViewModel&lt;LoginViewModel&gt;();        }        else        {            ShowViewModel&lt;TipViewModel&gt;();        }    }}Notice that to request this initial navigation, the CustomAppStart uses the ShowViewModel&lt;TViewModel&gt; method on the MvxNavigatingObject base class. We’ll see this method used throughout this article - it is the core of the MvvmCross navigation mechanism.If you wanted to do even more here, e.g. if you wanted to use parameters passed to the app from the operating system, then this is also possible - these can be passed from the platform-specific startup code to the IMvxAppStart.Start(object hint) method using the hint and can then also be passed on to the displayed ViewModel.Simple Navigation between Page-level ViewModelsWhen your app is displaying a ViewModel page, say FirstViewModel, then that first page can request that the display is moved forwards to a new ViewModel page, say SecondViewModel by using a call like: ShowViewModel&lt;SecondViewModel&gt;();When the FirstViewModel makes this request, then the MvvmCross framework will:  locate a View to use as a page for SecondViewModel within the app - normally this will be SecondView  create a new instance of this SecondView  create a SecondViewModel and provide it as the DataContext for the new SecondView  ask the operating system to display the SecondViewIn action - an Android appTo see an example of this, let’s set up a simple Android application.      Create a Core Portable Class Library application - exactly as we did in the TipCalc example.        Within this Core application add two ViewModels:  using System;using System.Windows.Input;using MvvmCross.Platform;using MvvmCross.ViewModels;namespace MyApp.Core{public class FirstViewModel : MvxViewModel{    public ICommand GoCommand    {        get        {            return new MvxCommand(() =&gt; ShowViewModel&lt;SecondViewModel&gt;();        }    }}public class SecondViewModel : MvxViewModel{}}      For IMvxAppStart choose to always show the FirstViewModel using:    Mvx.RegisterSingleton&lt;IMvxAppStart&gt;(new MvxAppStart&lt;FirstViewModel&gt;());        Create an Android UI for this app - just as we did in the TipCalc sample        Add simple Android views for both FirstView and SecondView.        For FirstView include a button - and bind it’s Click event to the GoCommand within the FirstViewModel      &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;    &lt;LinearLayout      xmlns:android=\"http://schemas.android.com/apk/res/android\"      xmlns:local=\"http://schemas.android.com/apk/res/MyApp.UI.Droid\"      android:layout_width=\"fill_parent\"      android:layout_height=\"fill_parent\"      &gt;    \t&lt;Button    \t  android:layout_width=\"fill_parent\"    \t  android:layout_height=\"wrap_content\"    \t  android:text=\"Go\"    \t  android:textSize=\"40dp\"    \t  local:MvxBind=\"Click GoCommand\"    \t  /&gt;    &lt;/LinearLayout&gt;  For SecondView include only some ‘simple’ text:\t&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\t&lt;LinearLayout\t  xmlns:android=\"http://schemas.android.com/apk/res/android\"\t  xmlns:local=\"http://schemas.android.com/apk/res/MyApp.UI.Droid\"\t  android:layout_width=\"fill_parent\"\t  android:layout_height=\"fill_parent\"\t  &gt;\t\t&lt;TextView\t\t  android:layout_width=\"fill_parent\"\t\t  android:layout_height=\"wrap_content\"\t\t  android:text=\"This is the Second View\"\t\t  android:textSize=\"40dp\"\t\t  /&gt;\t&lt;/LinearLayout&gt;  As discussed above in ‘The initial navigation’ add a SplashScreen for this Droid app.When this application runs, you should see a simple UI for FirstView with a FirstViewModel data context, and when you press the ‘Go’ button, you should see the display shift to a SecondView with a SecondViewModel data contextNavigation with parameters - using a parameter objectAs you write apps, you may frequently find that you want to parameterize a ViewModel navigation.For example, you may encounter List-Detail situations - where:  The Master view shows a list of items.  When the user selects one of these, then the app will navigate to a Detail view  The Detail view will then shows that specific selected item.To achieve this, the navigation from MasterViewModel to DetailViewModel will normally be achieved by:  we declare a class DetailParameters for the navigation:public class DetailParameters{    public int Index {        get;        set;    }}      the MasterViewModel makes ShowViewModel a call like:    ShowViewModel&lt;DetailViewModel&gt;(new DetailParameters() { Index = 2 });        the DetailViewModel declares an Init method in order to receive this DetailParameters:  public void Init(DetailParameters parameters){    // use the parameters here}Note that the DetailParameters class used here must be a ‘simple’ class used only for these navigations:  it must contain a parameterless constructor  it should contain only public properties with both get and set access  these properties should be only of types:          int      long      double      string      Guid      enumeration values      The reason for this limitations are that the navigation object itself needs to be serialized - it needs to be passed through mechanisms like Xaml urls on WindowsPhone, and like Intent parameter bundles on Android.If you do ever want to pass more complex objects between ViewModels during navigation, then you will need to find an alternative mechanism - e.g. perhaps caching the object in SQLite and using an index to identify the object.In action - an iOS exampleTODONavigation with parameters - using an anonymous parameter objectFor simple navigations, declaring a formal Parameters object can feel like ‘overkill’ - like ‘hard work’.In these situations you can instead use anonymous classes and named method arguments.For example, you can:      use a call to ShowViewModel like:    ShowViewModel&lt;DetailViewModel&gt;(new { index = 2 });        in the DetailViewModel declare an Init method in order to receive this index as:  public void Init(int index){    // use the index here}Note that due to serialization requirements, the only available parameter types used within this technique are only:  int  long  double  string  Guid  enumeration valuesNote that in order to use this technique on Windows platforms, you will need to add a InternalsVisibleTo line within the AssemblyInfo.cs file for the Core project.`[assembly: InternalsVisibleTo(\"MvvmCross\")]`This is because anonymous classes within C# are internal by default - so MvvmCross can only use reflection on them if InternalsVisibleTo is specified.",
            "url": "/documentation/tipcalc-tutorial/the-tip-calc-navigation"
          }
          ,
        
          "documentation-tipcalc-tutorial-the-tip-calc-tutorial" :{
            "title": "The Tip Calc tutorial",
            "content": "In this first Model-View-ViewModel project, we’ll create a simple single screen cross-platform application for calculating the tip at a restaurant.Here’s a sketch of where we hope to end up:The goals of this first application are all about introducing:  the general structure of MvvmCross applications  some of the code elements required in all MvvmCross applications  how data-binding support on Xamarin.Android and Xamarin.iOS (the products formerly known as Mono for Android and MonoTouch)Within this guide, we won’t attempt to provide any introduction to the Apple, Google, Microsoft, and Xamarin products and platforms - there are plenty of guides available already for all of those. Instead, we’ll focus instead on pure, unadulterated MvvmCross Nirvana.",
            "url": "/documentation/tipcalc-tutorial/the-tip-calc-tutorial"
          }
          ,
        
          "documentation-tipcalc-tutorial-tip-calculator-a-recap" :{
            "title": "Tip Calculator - A recap",
            "content": "Over the course of these articles, we’ve covered the complete Tip Calc app on 5 platforms from one shared PCL code library using Mvvm.I hope this was simple and easy to follow…Just to recap what we did:  For the core PCL library, we:  created a Profile 259 library  added some MvvmCross PCL libraries  added our services - the Calculator  added our TipViewModel which exposed properties  added our App which wired the services together and defined an IMvxAppStart  For each platform, we generally went through a process like:  created a platform specific project  added some MvvmCross PCL libraries  added some MvvmCross platform specific libraries  added a Setup class which would initialize everything  modified the platform-specific Application to call Setup  created a Views folder  added a platform specific View  changed that View base class to something beginning with Mvx  added a public new TipViewModel ViewModel to link the View to the ViewModel  modified the XML for that View to add the UI fields  modified those UI fields to add databinding to the ViewModel properties  pressed ‘Run’ :)  considered some ways that the UI could be improved using platform-specific UI techniquesGenerally, these same steps are what you’ll follow for each MvvmCross application you want to make.We’ll cover more advanced topics in future articles.Thanks for readingStuart",
            "url": "/documentation/tipcalc-tutorial/tip-calculator-a-recap"
          }
          
        
        ,
    
        
          "documentation-testing-testing" :{
            "title": "Testing",
            "content": "In order to test objects that make use of MvvmCross infrastructure, like ViewModels and the IoC container, there are some setup steps that are required.Creating a Test AssemblyFor general testing, a good cross-platform framework to choose is NUnit - http://nunit.org/While not currently available in pure PCL form, NUnit can easily be used to build .Net 4.5 test projects which can be quickly run from your build environment, and it opens the door to other test mechanisms such as testing with NUnitLite in Xamarin.iOS.For Mocking, frameworks such as Moq - http://code.google.com/p/moq/ - can be used in the ‘traditional’ .Net runtime environments. However, they cannot be used in Ahead-Of-Time compilation targets such as Xamarin.iOS. Instead, if you want to test within Xamarin.iOS on a real device, then manual object mocking must be used.For a basic .Net 4.5 test setup for, for example, a ViewModel, you can:  create a .Net 4.5 library project  use Nuget to add references to NUnit and to Moq  use Nuget or a local binary folder to add references to all of:          MvvmCross.Core      MvvmCross      MvvmCross.Tests      Note: The last assembly (MvvmCross.Tests) is key, as it is defines a base class MvxIoCSupportingTest which can help with initializing IoC setup.Test class declaration and setupYour test classes should inherit from MvxIoCSupportingTestEach test method should then call the Setup method:using MvvmCross.Test.Core;using Moq;using NUnit.Framework;[TestFixture]public class MyTest : MvxIoCSupportingTest{    [Test]    public void TestViewModel()    {        base.Setup(); // from MvxIoCSupportingTest        // your test code    }}Registering objects and additional setupNow that you have the bare bones for your test to work, you can use the Ioc property to register any singleton or regular types within MvvmCross.Also, there’s a special method named AdditionalSetup() which can be overridden to automatically do custom initialization:protected override void AdditionalSetup(){    // an automatically Mocked service:    var firstService = new Mock&lt;IFirstService&gt;();    Ioc.RegisterSingleton&lt;IFirstService&gt;(firstService.Object);    // a manually Mocked service:    var secondService = new MockSecondService();    Ioc.RegisterSingleton&lt;ISecondService&gt;(secondService);}When creating ViewModel or Service test objects, one common requirement is to provide a mock object which implements both IMvxViewDispatcher and IMvxMainThreadDispatcher. These interfaces are required for MvvmCross UI thread marshalling and for MvvmCross ViewModel navigation. This object can be implemented using a class like MockDispatcher:public class MockDispatcher    : MvxMainThreadDispatcher    , IMvxViewDispatcher{    public readonly List&lt;MvxViewModelRequest&gt; Requests = new List&lt;MvxViewModelRequest&gt;();    public readonly List&lt;MvxPresentationHint&gt; Hints = new List&lt;MvxPresentationHint&gt;();    public bool RequestMainThreadAction(Action action)    {        action();        return true;    }    public bool ShowViewModel(MvxViewModelRequest request)    {        Requests.Add(request);        return true;    }    public bool ChangePresentation(MvxPresentationHint hint)    {        Hints.Add(hint);        return true;    }}which can be registered as:protected MockDispatcher MockDispatcher {    get;    private set;}protected override void AdditionalSetup(){    MockDispatcher = new MockDispatcher();    Ioc.RegisterSingleton&lt;IMvxViewDispatcher&gt;(MockDispatcher);    Ioc.RegisterSingleton&lt;IMvxMainThreadDispatcher&gt;(MockDispatcher);}If you are also using object based navigation - e.g. ShowViewModel&lt;MyViewModel&gt;(new { id = 12 }) - then you may also need to register an IMvxStringToTypeParser parser to facilitate this:protected MockDispatcher MockDispatcher {    get;    private set;}protected override void AdditionalSetup(){    MockDispatcher = new MockDispatcher();    Ioc.RegisterSingleton&lt;IMvxViewDispatcher&gt;(MockDispatcher);    Ioc.RegisterSingleton&lt;IMvxMainThreadDispatcher&gt;(MockDispatcher);    // for navigation parsing    Ioc.RegisterSingleton&lt;IMvxStringToTypeParser&gt;(new MvxStringToTypeParser());}Links and other references      The Twitter Search example has a test project which can be used as reference as well        There is a N=29 video tutorial on testing        MvvmCross: Enable Unit-testing. A blog post presenting a slightly different approach, using a custom MvvmCrossTestSetup class.        MvvmCross: Unit-testing with AutoFixture. A blog post introducing a way to combine MvvmCross with AutoFixture  ",
            "url": "/documentation/testing/testing"
          }
          
        
        ,
    
        
          "documentation-samples-samples" :{
            "title": "Samples",
            "content": "For the samples please visit: https://github.com/MvvmCross/MvvmCross-Samples",
            "url": "/documentation/samples/samples"
          }
          
        
        ,
    
        
          "documentation-presenters-android-view-presenter" :{
            "title": "Android View Presenter",
            "content": "View Presenter OverviewThe default presenter for Android named MvxAndroidViewPresenter or MvxAppCompatViewPresenter when using the Android AppCompat support library offers out of the box support for the following navigation patterns / strategies:  Fragments (Nested)  Activity’s  Dialogs  Tabs / ViewPagerNavigation patterns that should be easy to implement with this are:  NavigationDrawer  BottomNavigationBar  BottomSheetDialog  Master/Detail Flows  Nested navigationAlso if your app needs another kind of presentation mode, you can easily extend it!Presentation AttributesThe presenter uses a set of PresentationAttributes to define how a view will be displayed. The existing attributes are:MvxActivityPresentationAttributeUsed as root of the App and root for other layouts like Fragments.MvxDialogFragmentPresentationAttributeExtends MvxFragmentPresentationAttribute and shows it in a DialogMvxFragmentPresentationAttributeHosted inside an Activity.MvxTabLayoutPresentationAttributeExtends MvxFragmentPresentationAttribute and puts the Fragment into a ViewPager with TabLayout.MvxViewPagerFragmentPresentationAttributeExtends MvxFragmentPresentationAttribute and puts the Fragment into a ViewPager.Views without attributes: Default values  If a view class has no attribute over it, the presenter will check the type and try to create the correct attribute for it.Override a presentation attribute at runtimeTo override a presentation attribute at runtime you can implement the IMvxOverridePresentationAttribute in your view and determine the presentation attribute in the PresentationAttribute method like this:public MvxBasePresentationAttribute PresentationAttribute(){    return new MvxFragmentPresentationAttribute()    {            };}If you return null from the PresentationAttribute the View Presenter will fallback to the attribute used to decorate the view. If the view is not decorated with a presentation attribute it will use the default presentation attribute.Note: Be aware that your ViewModel will be null during PresentationAttribute, so the logic you can perform there is limited here. Reason to this limitation is MvvmCross Presenters are stateless, you can’t connect an already instantiated ViewModel with a new View.ExtensibilityThe presenter is completely extensible! You can override any attribute and customize attribute members.You can also define new attributes to satisfy your needs. The steps to do so are:  Add a new attribute that extends MvxBasePresentationAttribute  Subclass MvxAppCompatViewPresenter and make it the presenter of your application in Setup.cs (by overriding the method CreatePresenter).  Override the method RegisterAttributeTypes and add a registry to the dictionary like this:_attributeTypesToShowMethodDictionary.Add(    typeof(MyCustomModePresentationAttribute),    (type, attribute, request) =&gt; ShowMyCustomModeView(type, (MyCustomPresentationAttribute)attribute, request));  Implement a method that takes care of the presentation mode (in the example above, ShowMyCustomModeView).  Use your attribute over a view class. Ready!Sample please!You can browse the code of the Playground Android project to see this presenter in action.",
            "url": "/documentation/presenters/android-view-presenter"
          }
          ,
        
          "documentation-presenters-ios-view-presenter" :{
            "title": "iOS View Presenter",
            "content": "View Presenter OverviewThe default presenter for iOS named MvxIosViewPresenter offers out of the box support for the following navigation patterns / strategies:  Stack navigation  Tabs  SplitView  Modal  Modal navigation  Nested modalsAlso if your app needs another kind of presentation mode, you can easily extend it!Presentation AttributesThe presenter uses a set of PresentationAttributes to define how a view will be displayed. The existing attributes are:MvxRootPresentationAttributeUsed to set a view as Root. You should use this attribute over the view class that will be the root of your application (your app can have several root views, one at a time).The view root can be one of the following types:  MvxViewController  MvxTabBarViewController (actually implementing IMvxTabBarViewController is enough)  MvxSplitViewController (actually implementing IMvxSplitViewController is enough)If you want to initiate a stack navigation, just set the attribute member WrapInNavigationController to true.MvxChildPresentationAttributeUsed to set a view as a child. You should use this attribute over a view class that will be displayed inside a navigation stack (modal or not).The view class can decide if wants to be displayed animated or not through the attribute member Animated (the default value is true).If your app uses a TabBarController as a child ViewController of a “master” NavigationController, you can decide whether to display a new child ViewController inside a Tab of the TabBarViewController (assuming that Tab  is a NavigationController) or to display it as a child of the “master” NavigationController. You can take control of this behavior by overriding MvxTabBarController.ShowChildView.MvxModalPresentationAttributeUsed to display a view as Modal. You should use this attribute over a view class to present the view as a modal.There are several attribute members that the view class can customize:  WrapInNavigationController: If set to true, a modal navigation stack will be initiated (following child presentations will be displayed inside the modal stack). The default value is false.  ModalPresentationStyle: Corresponds to the ModalPresentationStyle property of UIViewController. The default value is UIModalPresentationStyle.FullScreen.  ModalTransitionStyle: Corresponds to the ModalTransitionStyle property of UIViewController. The default value is UIModalTransitionStyle.CoverVertical.  PreferredContentSize : Corresponds to the PreferredContentSize property of UIViewController. The property works for iPad only.  Animated: If set to true, the presentation will be animated. The default value is true.MvxTabPresentationAttributeThis attribute is only useful (and should only be used) when the current Root view is a IMvxTabBarViewController.By using it over a view class, the presenter will show the view as a Tab inside the TabBarController.The presentation can be highly customized through this attribute members:  TabName: Defines the title of the tab that will be displayed below the tab icon. It has to be a magic string, but it can be for example a key to a localized string that you can grab overriding the method SetTitleAndTabBarItem in your TabBarController.  TabIconName: Defines the name of the resource that will be used as icon for the tab. It also has to be a magic string, but same as before, your app can take control of what happens by overriding the method SetTitleAndTabBarItem in your TabBarController.  TabSelectedIconName: Defines the name of the resource that will be used as icon for the tab when it becomes selected. It also has to be a magic string, your app can take control of what happens by overriding the method SetTitleAndTabBarItem in your TabBarController.  WrapInNavigationController: If set to true, the view will be wrapped in a MvxNavigationController, which will allow the tab to have its own navigation stack. Important note: When the current Root is a TabBarController and there is no current modal navigation stack, child presentations will be tried to be displayed in the current selected Tab.  TabAccessibilityIdentifier: Corresponds to the UIViewController.View AccessibilityIdentifier property.MvxMasterSplitViewPresentationAttributeThis attribute is only useful (and should only be used) when the current Root view is a IMvxSplitViewController.By using it over a view class, the presenter will show the view as Master of the split.There is an attribute member that can be used to customize the presentation:  WrapInNavigationController: If set to true, the view will be displayed wrapped in a MvxNavigationController, which will allow you to set a title, which is the most common scenario of SplitView. The default value is therefore true.MvxDetailSplitViewPresentationAttributeThis attribute is only useful (and should only be used) when the current Root view is a IMvxSplitViewController.By using it over a view class, the presenter will show the view as Detail of the split.There is an attribute member that can be used to customize the presentation:  WrapInNavigationController: If set to true, the view will be displayed wrapped in a MvxNavigationController,  which will allow the view to have its own navigation stack.Views without attributes: Default values  If the initial view class of your app has no attribute over it, the presenter will assume stack navigation and will wrap your initial view in a MvxNavigationController.  If a view class has no attribute over it, the presenter will assume animated child presentation and will display the view in the current navigation stack (could be modal or not).Override a presentation attribute at runtimeTo override a presentation attribute at runtime you can implement the IMvxOverridePresentationAttribute in your view controller and determine the presentation attribute in the PresentationAttribute method like this:public MvxBasePresentationAttribute PresentationAttribute(){    return new MvxModalPresentationAttribute    {        ModalPresentationStyle = UIModalPresentationStyle.OverFullScreen,        ModalTransitionStyle = UIModalTransitionStyle.CrossDissolve    };}If you return null from the PresentationAttribute the iOS View Presenter will fallback to the attribute used to decorate the view controller. If the view controller is not decorated with a presentation attribute it will use the default presentation attribute (a animated child presentation).Note: Be aware that your ViewModel will be null during PresentationAttribute, so the logic you can perform there is limited here. Reason to this limitation is MvvmCross Presenters are stateless, you can’t connect an already instantiated ViewModel with a new View.ExtensibilityThe presenter is completely extensible! You can override any attribute and customize attribute members.You can also define new attributes to satisfy your needs. The steps to do so are:  Add a new attribute that extends MvxBasePresentationAttribute  Subclass MvxIosViewPresenter and make it the presenter of your application in Setup.cs (by overriding the method CreatePresenter).  Override the method RegisterAttributeTypes and add a registry to the dictionary like this:_attributeTypesToShowMethodDictionary.Add(    typeof(MyCustomModePresentationAttribute),    (vc, attribute, request) =&gt; ShowMyCustomModeViewController(vc, (MyCustomPresentationAttribute)attribute, request));  Implement a method that takes care of the presentation mode (in the example above, ShowMyCustomModeViewController).  Use your attribute over a view class. Ready!Sample please!You can browse the code of the Playground iOS project to see this presenter in action.",
            "url": "/documentation/presenters/ios-view-presenter"
          }
          ,
        
          "documentation-presenters-mac-view-presenter" :{
            "title": "Mac View Presenter",
            "content": "View Presenter OverviewThe default presenter for Mac named MvxMacViewPresenter works in a similar way as the default ViewPresenter for iOS does. Together with the ViewsContainer, the presenter supports Storyboards, .xibs and coded interfaces.It offers out of the box support for the following navigation patterns / strategies:  Multiple windows by properties or via storyboard  Content inside windows  Modals  Sheets  TabsAlso if your app needs another kind of presentation mode, you can easily extend it!Presentation AttributesThe presenter uses a set of PresentationAttributes to define how a view will be displayed. The existing attributes are:MvxWindowPresentationAttributeUsed to initiate a new Window. The first view of your app should use this attribute or any attribute (see defaults section).You can customize how the window will look through the following properties:  Identifier: Window identifier, used to identify the window for other attributes. If an identifier is not provided by the developer, it will be set to the name of the view class.  WindowStyle: Used to set the NSWindowStyle. Default value is NSWindowStyle.Closable | NSWindowStyle.Resizable | NSWindowStyle.Titled.  BufferingType: Used to set the NSBackingStore. Default value is NSBackingStore.Buffered.  PositionX: float, default value is 200.  PositionY: float, default value is 200.  Width: float, default value is 600.  Height: float, default value is 400.To use a window generated in Storyboard, click on the storyboard and create a new Window Controller in Interface Builder. You may delete the generated View Controller. Back in Visual Studio for Mac, change the resulting NSWindowController to a MvxWindowController. Add two parameters to the MvxWindowPresentationAttribute, the WindowControllerName followed by the StoryboardName, e.g.,[MvxWindowPresentation(\"CustomWindow\", \"Main\")]Properties introduced inside the attribute will override the storyboard properties, e.g.,[MvxWindowPresentation(\"CustomWindow\", \"Main\", Width = 800)]will set the CustomWindow Width to 800.MvxContentPresentationAttributeUsed to set a view as content of a Window. Please notice that changing the content of a window does not automatically generate a navigation stack as it would be on iOS. Changing the content of a window dismisses the old content.You can choose in which window should this view be displayed by using the WindowIdentifier property of the attribute. If the identifier is not provided, the view will be displayed in the last opened window.MvxModalPresentationAttributeUsed to display a view as Modal. Same as with content, you can choose through the WindowIdentifier property from which window should the modal be opened. If the identifier is not provided, the view will be displayed in the last opened window.MvxSheetPresentationAttributeMacOS uses the concept of sheets to prompt the user with messages or small forms. If you use this attribute over a view class, it will be displayed as a sheet. You can choose from which window should it be opened through the WindowIdentifier property. If the identifier is not provided, the view will be displayed in the last opened window.MvxTabPresentationAttributeThis attribute is only useful (and should only be used) when the current Content of a Window is a IMvxTabViewController.By using it over a view class, the presenter will show the view as a Tab inside the TabViewController.The presentation can be customized through this properties:  TabTitle: Defines the title of the tab that will be displayed in the segmented control for tabs.  WindowIdentifier: identifier for the window where the view should be displayed.Views without attributes: Default values  If a view class has no attribute over it, the presenter will assume a new window presentation.Override a presentation attribute at runtimeTo override a presentation attribute at runtime you can implement the IMvxOverridePresentationAttribute in your ViewController and determine the presentation attribute in the PresentationAttribute method like this:public MvxBasePresentationAttribute PresentationAttribute(){    return new MvxModalPresentationAttribute    {        WindowIdentifier = \"MyWindow\"    };}If you return null from the PresentationAttribute the Mac View Presenter will fallback to the attribute used to decorate the view controller. If the view controller is not decorated with a presentation attribute it will use the default presentation attribute (a new window).Note: Be aware that your ViewModel will be null during PresentationAttribute, so the logic you can perform there is limited here. Reason to this limitation is MvvmCross Presenters are stateless, you can’t connect an already instantiated ViewModel with a new View.ExtensibilityThe presenter is completely extensible! You can override any attribute and customize attribute members.You can also define new attributes to satisfy your needs. The steps to do so are:  Add a new attribute that extends MvxBasePresentationAttribute  Subclass MvxMacViewPresenter and make it the presenter of your application in Setup.cs (by overriding the method CreatePresenter).  Override the method RegisterAttributeTypes and add a registry to the dictionary like this:AttributeTypesToShowMethodDictionary.Add(    typeof(MyCustomModePresentationAttribute),    (vc, attribute, request) =&gt; ShowMyCustomModeViewController(vc, (MyCustomPresentationAttribute)attribute, request));  Implement a method that takes care of the presentation mode (in the example above, ShowMyCustomModeViewController).  Use your attribute over a view class. Ready!Sample please!You can browse the code of the Playground macOS project to see this presenter in action.",
            "url": "/documentation/presenters/mac-view-presenter"
          }
          ,
        
          "documentation-presenters-view-presenters" :{
            "title": "View Presenters",
            "content": "View Presenters are a key object in the MvvmCross architecture. It is a singleton that acts as a glue between your Views and your ViewModels. As the name implies, a view presenter takes a ViewModel presentation request (that is built once you call ShowViewModel&lt;MyViewModel&gt;()) and decides how it will be presented on the UI.By using View Presenters, MvvmCross provides a clear separation between the ViewModel and the View layer. This gives a cross platform app a lot of power, since each platform can make real use of all of its capabilities.Going further with the previous idea, it is important to notice that each platform has its own and unique navigation and presentation patterns, and this is why a presenter deals directly with the View layer. To help illustrate the idea, let’s consider this example:  On Android, an App could include a content area and side menu - NavigationDrawer -. Most of the options are available through the side menu or a toolbar.  On iOS, the same app could include bottom tabs, where each tab can contain its own navigation stack.  On MacOS, once again the same app could include a window with a split view.  …MvvmCross provides default presenters for each platform that support the most used patterns and strategies. However, sometimes you might find yourself needing to display a ViewModel in a particular or rare way that is not covered. This means, you will need to create a custom presenter by subclassing one of the provided by MvvmCross or by implementing the interface IMvxViewPresenter.Let’s take a look now at the methods of that interface:  Show(MvxViewModelRequest request): This method is in charge of deciding how a view should be presented and then show it. It takes a ViewModel request as parameter, which contains all the the information passed in ShowViewModel.  AddPresentationHintHandler&lt;THint&gt;(Func&lt;THint, bool&gt; action) where THint : MvxPresentationHint: You can use this method to register your custom PresentationHints and their respective handlers (we will explore the PresentationHint concept a bit later).  ChangePresentation(MvxPresentationHint hint): This method is the one that gets called whenever a PresentationHint is requested. It is responsible for handling the requested change.  Close(IMvxViewModel toClose): As you can imagine, this method is used to handle the close request of a ViewModel. It takes the ViewModel instance to be closed as parameter.View Presenters on each platformEach mobile platform has its own View Presenter:  Android: MvxAndroidViewPresenter  iOS: MvxIosViewPresenter  Windows: MvxWindowsViewPresenterWhen you navigate to selected ViewModel, platform specific View Presenter handles displaying View properly.Android platform has two important types of View Presenters:  MvxAndroidViewPresenter - to switch between Activities  MvxFragmentsPresenter - to provide support for Android fragmentsiOS navigation is handled by MvxIosViewPresenter which provide sopport for the following navigation patterns:  Tabs  SplitView  Modal  StackKey functionality here is set of attributes (Presenter Attributes) which we can use to define how selected view will be displayed:  MvxTabPresentationAttribute – for tabs  MvxRootPresentationAttribute – to set ViewController as root  MvxModalPresentationAttribute – to display ViewController modally  MvxMasterSplitViewPresentationAttribute – for SplitView master controller  MvxDetailSplitViewPresentationAttribute – for SplitView details controllerHere is example how you can use them:    [MvxModalPresentation]    public class DetailsViewController : ApplicationBaseMvxViewController&lt;DetailsViewModel&gt;Windows (UWP) is responsible for proper navigation between Pages. When navigating between ViewModels, Windows View Presenter controls Frame stack and displays specific Pages.Showing ViewModelsThe key and most important method of a ViewPresenter is Show. It is in charge of transforming a request coming from the Core project into a View the user can interact with.There are several techniques to implement this method, but the preferred way by the MvvmCross default presenters is to use custom class attributes. These let the presenter know how a View wants to be presented on the UI. For instance, on iOS you would typically declare a ViewController like this:namespace Playground.iOS.Views{    [MvxRootPresentation(WrapInNavigationController = true)]    public partial class MyView : MvxViewController&lt;MyViewModel&gt;    {        // your UI code    }}In this example the attribute is telling the Presenter that whenever a ViewModel request for MyViewModel arrives, it should display the View as a root and wrap it into a NavigationController (it initiates a navigation stack).Requesting presentation changesAlthough for most apps showing / closing ViewModels is enough, there is one more tool that MvvmCross offers, and it is extremely powerful: the ability to request a change to the UI layer.The best example we can give about this is the Close method itself. Once you call Close from a ViewModel or a MvxNavigatingObject, what MvvmCross internally do is to send a MvxClosePresentationHint to the ViewPresenter, which then calls Close(IMvxViewModel toClose). You can see how this happen in the iOS Presenter.It is important to remark here that these are just unbound requests. Each platform is then responsible for deciding how a presentation hint should be handled - you can also decide to just ignore a hint type -.To add your own MvxPresentationHint you should follow these steps:      Create a MvxPresentationHint subclass:     public class MyCustomHint : MvxPresentationHint {     public string ImportantInformation { get; set; }     public MyCustomHint(string importantInformation)     {         ImportantInformation = importantInformation;     } }        Override the method CreatePresenter() in the Setup class and register your custom hint in it. For example, on iOS:     protected override IMvxIosViewPresenter CreatePresenter() {     var presenter = base.CreatePresenter();     presenter.AddPresentationHintHandler&lt;MyCustomHint&gt;(hint =&gt; HandleMyCustomHint(hint));     return presenter; }        Implement HandleMyCustomHint method, which will return true if the presentation change was successfully handled or false otherwise:     private bool HandleMyCustomHint(MyCustomHint hint) {     bool result;     if(hint.ImportantInformation != null)     // your code     return result; }        Now repeat steps 2 and 3 for each platform (if a platform should just ignore the MvxPresentationHint, it’s not necessary to do anything).    Finally, make a call to the ChangePresentation method from a MvxViewModel or a MvxNavigatingObject when necessary:     private void AMethod() {     // your code     ChangePresentation(new MyCustomHint(\"example\"));     // your code }      Ready!Another kind of presentation changes your app can request through hints includes clearing / modifying the BackStack, changing a root while maintaining the existent views, … possibilities are really endless. Once again your app is king here!",
            "url": "/documentation/presenters/view-presenters"
          }
          ,
        
          "documentation-presenters-wpf-view-presenter" :{
            "title": "WPF View Presenter",
            "content": "View Presenter OverviewThe default presenter for WPF named MvxWpfViewPresenter offers out of the box support for the following navigation patterns / strategies:  Single window and Multiple windows app  Content inside window with stack/non-stack navigation  Modal and modal-less windowAlso if your app needs another kind of presentation mode, you can easily extend it!Presentation AttributesThe presenter uses a set of MvxBasePresentationAttribute to define how a view will be displayed. The existing attributes are:MvxWindowPresentationAttributeUsed to a Window.The view can be one of the following types:  MvxWindowView (that inherits Window and implements IMvxWindowView)  MvxWpfView (that inherits UserControl and implements IMvxWpfView)If the view class isn’t Window, wrap in a window by the presenter.You can customize how the window will look through the following properties:  Identifier: Window identifier, used to identify the window for other attributes. If an identifier is not provided by the developer, it will be set to the name of the view class.  Modal: How to show window, if true the window will show by ShowDialog method. If false the window will show by Show method.This view with this attribute like this:[MvxWindowPresentation(Identifier = nameof(MainWindow), Modal = false)]public partial class MainWindow : MvxWindow&lt;MainWindow&gt;{    public MainWindow() =&gt; InitializeComponent();}MvxContentPresentationAttributeUsed to set a view as a content. The view that will be displayed as a Content object in a Window. The view class that will be displayed with stack navigation by default.The view can be one of the following types:  MvxWpfView (that inherits UserControl and implements IMvxWpfView)You can customize how the content will look through the following properties:  WindowIdentifier: You can choose in which window should this view be displayed by using this property.If the identifier is not provided, the view will be displayed in the last opened window.  StackNavigation: The view class can decide if wants to be displayed with stack navigation or non-stack navigation. The default is true.The view with this attribute like this:[MvxContentPresentation(WindowIdentifier = nameof(MainWindow), StackNavigation = false)]public partial class ChildView : MvxWpfView&lt;ChildViewModel&gt;{    public ChildView() =&gt; InitializeComponent();}Views without attributes: Default valuesIf a Window class has no attribute over it, the presenter will assume Window presentation.  Other classes are assumed Content presentation.Override a presentation attribute at runtimeTo override a presentation attribute at runtime you can implement the IMvxOverridePresentationAttribute in your view and determine the presentation attribute in the PresentationAttribute method like this:public partial class WindowView :    MvxWindow&lt;WindowViewModel&gt;,    IMvxOverridePresentationAttribute{    public WindowView() =&gt; InitializeComponent();    // Override a presentation attribute at runtime    public MvxBasePresentationAttribute PresentationAttribute() =&gt;        new MvxWindowPresentationAttribute        {            Identifier = $\"{nameof(WindowView)}.{ViewModel.Count}\"        };}If you return null from the PresentationAttribute, the presenter will assume presentation the same way as views without attributes.ExtensibilityThe presenter is completely extensible! You can override any attribute and customize attribute members.You can also define new attributes to satisfy your needs. The steps to do so are:  Add a new attribute that extends MvxBasePresentationAttribute     public class MyCustomModePresentationAttribute : MvxBasePresentationAttribute {     public int MyProperty { get; set; } }        Subclass MvxWpfViewPresenter and make it the presenter of your application in Setup.cs (by overriding the method CreateViewPresenter).     public class Setup : MvxWpfSetup {     public Setup(Dispatcher uiThreadDispatcher, ContentControl root) : base(uiThreadDispatcher, root)     {     }     protected override IMvxApplication CreateApp()     {         return new Core.App();     }     protected override IMvxWpfViewPresenter CreateViewPresenter(ContentControl root)     {         return new MyCustomViewPresenter(root);     } }        Override the method RegisterAttributeTypes and add a registry to the dictionary like this:     public class MyCustomViewPresenter         : MvxWpfViewPresenter {     protected virtual void RegisterAttributeTypes()     {         _attributeTypesToShowMethodDictionary.Add(             typeof(MyCustomModePresentationAttribute),             (element, attribute, request) =&gt;                 ShowMyCustomModeView(element, (MyCustomPresentationAttribute)attribute, request));     } }        Implement a method that takes care of the presentation mode (in the example above, ShowMyCustomModeView).  Use your attribute over a view class. Ready!Sample please!You can browse the code of the Playground WPF project to see this presenter in action.",
            "url": "/documentation/presenters/wpf-view-presenter"
          }
          
        
        ,
    
        
          "documentation-plugins-3rd-party-plugins" :{
            "title": "3rd party plugins",
            "content": "On this page you can find MvvmCross plugins that are made by 3rd parties. Feel free to add any missing plugin to this table.            Plugin      Summary      Platforms      Link                  ACR MvvmCross User Dialogs      A cross platform library that allows you to call for standard user dialogs from a shared/portable library.      Android, iOS, Windows Phone 8.0, UWP      Nuget              Pushwoosh plugin for MvvmCross      MvvmCross plugin that wraps the native Pushwoosh SDK      Android, iOS      Nuget              Infinite Scroll Plugin      Infinite Scrolling/Incremental Scrolling for lists      Android, iOS, UWP      Github              Bluetooth LE Plugin      Use bluetooth low energy      Android, iOS      Nuget              Fingerprint      Authenticate users via fingerprint      Android, iOS, UWP      Nuget              Mvx.Clipboard      Access the device’s clipboard      Android, iOS, WPF, UWP      Github              Mvx.Volume      Handle the device’s volume      Android, iOS      Github              Mvx.CreditCardScan      Scan credit cards using OCR      Android, iOS      Github              Mvx.Flashlight      Access the device’s flash/torch      Android, iOS      Github              Mvx.Microphone      Access the device’s microphone      Android, iOS      Github              Mvx.Picasso      Target Bindings for Picasso      Android      Github      ",
            "url": "/documentation/plugins/3rd-party-plugins"
          }
          ,
        
          "documentation-plugins-accelerometer" :{
            "title": "Accelerometer",
            "content": "The Accelerometer plugin provides access to a platforms accelerometer using a singleton implementing the API.public interface IMvxAccelerometer{    void Start();    void Stop();    bool Started {        get;    }    MvxAccelerometerReading LastReading {        get;    }    event EventHandler&lt;MvxValueEventArgs&lt;MvxAccelerometerReading&gt;&gt; ReadingAvailable;}This plugin is available on all of Android, iOS, Windows Uwp and Wpf.The Wpf implementation is an empty implementation - so it’s not really supported there.All implementations are ‘intro level’ only implementations. You may find that you need to add additional code to, for example, get consistent x,y,z readings across all platforms or to handle errors on devices where the accelerometer is not currently available.Current advice (August 2013): if your app requires accelerometer support, consider this plugin as a good open source starting point - but do test the implementation on several devices to ensure it suits your app - consider developing the code further (and consider contributing your changes back to improving this plugin too!).",
            "url": "/documentation/plugins/accelerometer"
          }
          ,
        
          "documentation-plugins-color" :{
            "title": "Color",
            "content": "The Color plugin provides native implementations for conversion from the cross-platform MvxColor to platform-specific Color implementations.public interface IMvxNativeColor{    object ToNative(MvxColor mvxColor);}This plugin is available on all platforms.This plugin also provides a number of useful Color-outputting ValueConverters - see Mvx Color Value Conversion for information on these. If you wish to create your own Color ValueConverters, then this plugin provides the base classes MvxColorValueConverter and MvxColorValueConverter&lt;T&gt;.The Android version of this plugin also registers some Binding Targets for use with Color  BackgroundColor for any Android View  TextColor for any Android TextView",
            "url": "/documentation/plugins/color"
          }
          ,
        
          "documentation-plugins-downloadcache" :{
            "title": "DownloadCache",
            "content": "The DownloadCache plugin provides a managed disk and memory cache for downloaded files - especially images.The DownloadCache plugin is only available for iOS and Android, although others have ported this to Windows platforms too.For the DownloadCache plugin to fully work, implementations must be registered for:  IMvxTextSerializer  IMvxFileStoreOne relatively easiest way to register implementations for these interfaces is to load the Json and File plugins.The most common use of the DownloadCache plugin is for downloading images using in MvxImageView in Android and iOS. This is managed automatically using the IMvxImageHelper&lt;Bitmap&gt; and &lt;IMvxImageHelper&lt;UIImage&gt; helpers.The caches used by these helpers are configured MvxDownloadCacheConfiguration configuration classes. The default configurations store up to 500 files for up to 7 days, and will maintain up to 4MB of up to 30 images in RAM. To override the default values, provide custom settings in GetPluginConfiguration in your Setup class.Known issues:  this cache is a complicated implementation, has been well tested in apps, but is poorly unit tested currently  one user has reported MonoTouch download issues in certain network conditions - these problems seem to be related to known MonoTouch issues - see StackOverflow Q&amp;A on this. That first StackOverflow post has a suggested workaround - overriding the IMvxHttpFileDownloader registration with an implementation which uses the UIImage.LoadFromData method.Download Cache and Android BitmapWhen loading images from remote source, you have to be careful with the images size. Loading a 2000x2000 pixels bitmap in a 40dp x 40dp ImageView will do no good to your application. You want eventually to scale down the image to a more pragmatic size.[Xamarin wrote a recipe for this].(https://developer.xamarin.com/recipes/android/resources/general/load_large_bitmaps_efficiently/)Lucky you, this recipe is implemented in the MvxAndroidLocalFileImageLoader.cs file of the DownloadCache plugin.If you look at the source code, and more precisely at private static async Task&lt;Bitmap&gt; LoadBitmapAsync(string localPath, int maxWidth, int maxHeight), you’ll see that the bitmap will be resampled accordingly to the given maxWidth and maxHeight.Climbing up the call ladder, we can see that these parameters are simply coming from the MvxImageView which overrides the properties of Android’s ImageView.So all you have to do in your layout, if per say you want to display a 40x40 avatar image, is this:android:maxHeight=\"40dp\"android:maxWidth=\"40dp\"To go further, I strongly advise you to create a “avatarStyle”, with your custom attributes, and apply it to your MvxImageView.",
            "url": "/documentation/plugins/downloadcache"
          }
          ,
        
          "documentation-plugins-email" :{
            "title": "Email",
            "content": "The Email plugin provides a cross-platform implementation for sending emails.public interface IMvxComposeEmailTask{    void ComposeEmail(string to, string cc, string subject, string body, bool isHtml);}The Email plugins is supported on all platforms.The implementation on Windows Uwp and Wpf is very simplistic - using only ‘mailto:’ url-open requests.To send an email you can use:Mvx.Resolve&lt;IMvxComposeEmailTask&gt;().ComposeEmail(\"me@slodge.com\",              string.Empty,              \"MvvmCross Email              \"I &lt;3 MvvmCross              false);",
            "url": "/documentation/plugins/email"
          }
          ,
        
          "documentation-plugins-fieldbinding" :{
            "title": "FieldBinding",
            "content": "The FieldBinding plugin is part of the Rio binding extensions for MvvmCross. The plugin is a pure PCL plugin - it contains only PCL assemblies.When FieldBinding is loaded, then MvvmCross data-binding:  can use fields as well as properties for binding.  can use INotifyChanged for dynamic fields.An example, Rio-based ViewModel using both FieldBinding and MethodBinding is:public class FirstViewModel    : MvxViewModel{    private readonly IDataStore _dataStore;    public FirstViewModel(IDataStore dataStore)    {        _dataStore = dataStore;    }    public void Init(int id)    {        var person = _dataStore.Get&lt;Person&gt;(id);        Id.Value = id;        FirstName.Value = person.FirstName;        LastName.Value = person.LastName;    }    public readonly INC&lt;int&gt; Id = new NC&lt;int&gt;();    public readonly INC&lt;string&gt; FirstName = new NC&lt;string&gt;();    public readonly INC&lt;string&gt; LastName = new NC&lt;string&gt;();    public void Save()    {        var person = _dataStore.Get&lt;Person&gt;(id);        person.FirstName = FirstName.Value;        person.LastName = LastName.Value;        _dataStore.Update(person);        Close(this);    }}The field in this class could be accessed using Android syntax:&lt;TextViewandroid:layout_width='fill_parent'                     android:layout_height='wrap_content'                             local:MvxBind='Text FirstName' /&gt;                                     &lt;TextView                                     android:layout_width='fill_parent'                                             android:layout_height='wrap_content'                                                     local:MvxBind='Text LastName' /&gt;For more on Rio FieldBinding see the N=36 video",
            "url": "/documentation/plugins/fieldbinding"
          }
          ,
        
          "documentation-plugins-file" :{
            "title": "File",
            "content": "The File plugin provides cross-platform access to a File Store API.public interface IMvxFileStore{    bool TryReadTextFile(string path, out string contents);    bool TryReadBinaryFile(string path, out Byte[] contents);    bool TryReadBinaryFile(string path, Func&lt;Stream, bool&gt; readMethod);    void WriteFile(string path, string contents);    void WriteFile(string path, IEnumerable&lt;Byte&gt; contents);    void WriteFile(string path, Action&lt;Stream&gt; writeMethod);    bool TryMove(string from, string to, bool deleteExistingTo);    bool Exists(string path);    bool FolderExists(string folderPath);    string PathCombine(string items0, string items1);    string NativePath(string path);    void EnsureFolderExists(string folderPath);    IEnumerable&lt;string&gt; GetFilesIn(string folderPath);    void DeleteFile(string path);    void DeleteFolder(string folderPath, bool recursive);    long GetSize(string path);    DateTime GetLastWriteTimeUtc(string path);}This plugin is implemented on all platforms - except Windows Uwp where the Folder APIs are currently unimplemented.By default, the plugin reads and writes files in paths relative to:            platform      location                  Android      Context.FilesDir              iOS      Environment.SpecialFolder.MyDocuments              Uwp      Windows.Storage.ApplicationData.Current.LocalFolder.Path              WPF      Environment.SpecialFolder.ApplicationData      Note: while it works, the use of a synchronous API for File IO on WindowsStore applications is slightly ‘naughty’. It’s likely that an asynchronous version of the IMvxFileStore interface will be provided in the near future.",
            "url": "/documentation/plugins/file"
          }
          ,
        
          "documentation-plugins-json" :{
            "title": "Json",
            "content": "The Json plugin provides a wrapper for a PCL version of the NewtonSoft Json.Net library allowing it to support.public interface IMvxJsonConverter    : IMvxTextSerializer{}public interface IMvxTextSerializer{    T DeserializeObject&lt;T&gt;(string inputText);    string SerializeObject(object toSerialise);    object DeserializeObject(Type type, string inputText);}The Serialize and Deserialize implementations used are ‘default’ Json.Net implementations with Formatting.None specified along with the settings:new JsonSerializerSettings{    Converters = new List&lt;JsonConverter&gt;    {        new MvxEnumJsonConverter(),    },    DateFormatHandling = DateFormatHandling.IsoDateFormat,}The version of Json.Net referenced is an old PCL version - 4.5.4.14825Json.Net is a popular library and it may be that the use of this old PCL version will conflict with another library your app is using. If this is the case, then it should be relatively straight-forward to not load the Json plugin, and to instead build your own implementations of IMvxTextSerializer and IMvxJsonConverter.The Json plugin can optionally be requested not to register Json as IMvxTextSerializer using the configuration in Setup.cs:protected override IMvxPluginConfiguration GetPluginConfiguration(Type plugin){    if (plugin == typeof(MvvmCross.Plugins.Json.PluginLoader))    {        return new MvvmCross.Plugins.Json.MvxJsonConfiguration()        {            RegisterAsTextSerializer = false        };    }    return null;}The Json plugin can be used:public class ExampleObject{    public string Name {        get;        set;    }    public DateTime DateOfBirth {        get;        set;    }}var serializer = Mvx.Resolve&lt;IMvxJsonConverter&gt;();var exampleObject = new ExampleObject(){    Name = \"Fred bloggs           DateOfBirth = new DateTime(1972,7,13)};var jsonText = serializer.SerializeObject(exampleObject);var deserialized = serializer.DeserializeObject&lt;ExampleObject&gt;(jsonText);Note that other Json libraries are available for .Net - in particular, several people have recommended the ServiceStack.Text library which is available on many platforms.",
            "url": "/documentation/plugins/json"
          }
          ,
        
          "documentation-plugins-jsonlocalisation" :{
            "title": "JsonLocalization",
            "content": "The JsonLocalization plugin provides a number of support classes to help load Json language text files for internationalization (i18n).The JsonLocalization plugin is a single PCL Assembly and isn’t really a typical plugin - it doesn’t itself register any singletons or services with the MvvmCross IoC container.For advice on using the JsonLocalization library, see:  the Babel sample - https://github.com/MvvmCross/MvvmCross-Samples/tree/master/Babel  the N+1 video N=21 which discusses how i18n is built - http://slodge.blogspot.co.uk/2013/05/n21-internationalisation-i18n-n1-days.htmlNotes:  the standard JsonLocalization implementation relies on the ResourceLoader and Json plugins for loading Json files from the application package contents.  several alternative localization implementations have been suggested including:          using Microsoft RESX files works using the ResxLocalization plugin.      using EmbeddedResources to store the Json files in the Core PCL assembly (see https://github.com/slodge/MvvmCross/issues/55)      using a single JSON file or a single CSV (Comma Separated Variables) file to store all languages in one single file (again see https://github.com/slodge/MvvmCross/issues/55)        we hope that some of these alternatives will become open source realities in the future  ",
            "url": "/documentation/plugins/jsonlocalisation"
          }
          ,
        
          "documentation-plugins-location" :{
            "title": "Location",
            "content": "The Location plugin provides access to GeoLocation (typically GPS) functionality via the API:public interface IMvxLocationWatcher{    void Start(        MvxLocationOptions options,         Action&lt;MvxGeoLocation&gt; success,         Action&lt;MvxLocationError&gt; error);    void Stop();    bool Started { get; }        MvxGeoLocation CurrentLocation { get; }    MvxGeoLocation LastSeenLocation { get; }        event EventHandler&lt;MvxValueEventArgs&lt;MvxLocationPermission&gt;&gt; OnPermissionChanged;}The Location plugin is implemented on all platforms (even Wpf).Because of the Action based nature of the IMvxLocationWatcher API, it’s generally best not to use this interface directly inside ViewModels, but instead to use the API in a singleton service which can then send Messages to your ViewModels.An example implementation of such a service is:public class LocationService    : ILocationService{    private readonly IMvxLocationWatcher _watcher;    private readonly IMvxMessenger _messenger;    public LocationService(IMvxLocationWatcher watcher, IMvxMessenger messenger)    {        _watcher = watcher;        _messenger = messenger;        _watcher.Start(new MvxLocationOptions(), OnLocation, OnError);    }    private void OnLocation(MvxGeoLocation location)    {        var message = new LocationMessage(this,                                            location.Coordinates.Latitude,                                            location.Coordinates.Longitude);        _messenger.Publish(message);    }    private void OnError(MvxLocationError error)    {        Mvx.Error(\"Seen location error {0}\", error.Code);    }}For a good walk-through of using the location plugin, including using it in tandem with the MvvmCross messenger, see both N=8 and N=9 in N+1 videos of MvvmCross - N+1 videosNotes:  the MvxLocationOptions object passed into the Start method provides a number of options like EnableHighAccuracy - not all of these options are well implemented on all platforms. For iOS8 and later, these options include the type of location permission request used (see https://github.com/MvvmCross/MvvmCross/pull/789)  the default implementation is a good ‘general’ module if you just need ‘location information’ in your app. If your app requires more - e.g. control over time and distance tracking, geo-fencing, etc - then consider building your own plugin (or injecting your own service from the UI project on each platform). The source code for the Location plugin should provide you with a good starting place for this.  it’s not unusual for Android developers to hit issues with location detection on different phones and on different Android - check StackOverflow and Issues for questions and answers - e.g. https://github.com/slodge/MvvmCross/issues/360  some platforms (especially Android) insist on the Location Watcher being started/stopped on the UI thread  the MvvmCross coordinates object - MvxCoordinates - does not currently come with any built-in maths operations. Algorithms for some common coordinate operations can be found on (for example) http://slodge.blogspot.co.uk/2012/04/calculating-distance-between-latlng.html.Known issue  Android plugin does not track location in case MvxLocationOptions does not match current device GPS mode. For example MvxLocationOptions.Coarse works only with Battery saving mode and does not work for High accuracy and Device only. As a solution use Fused plugin: MvvmCross.Plugins.Location.Fused.DroidFused Location (Android only)There is a new preferred way to access location in Android which is called FusedLocationApi: http://developer.android.com/intl/ru/training/location/index.htmlThere are few benefits of using it (over the old approach):  Coarse option means Low power mode  location still tracked when device’s GPS mode chagned  the plugin is more power efficient in generalNOTE: the plugin requires GooglePlayServices (which is not installed by default on emulators)This plugin is not compatible with default MvvmCross.Plugins.Location.Droid plugin. Ensure only one is used in Android project.",
            "url": "/documentation/plugins/location"
          }
          ,
        
          "documentation-plugins-messenger" :{
            "title": "Messenger",
            "content": "The MvvmCross Messenger plugin provides an Event aggregation Messenger which is biased towards using Weak references for event subscription.The IMvxMessenger API includes:  publishing methods:          Publish        subscription methods:          Subscribe, SubscribeOnMainThread, SubscribeOnThreadPoolThread, Unsubscribe        subscription state observation methods:          HasSubscriptionsFor, HasSubscriptionsForTag, CountSubscriptionsFor, CountSubscriptionsForTag, GetSubscriptionTagsFor        clearup methods:          RequestPurge, RequestPurgeAll      The basic use of the Messenger is:  Add the following to app.cs in the Initialize() method, this will make the messenger accessible through injection.Mvx.LazyConstructAndRegisterSingleton&lt;IMvxMessenger, MvxMessengerHub&gt;();  define one or more Message classes for communication between components. These should inherit from MvxMessage - e.g.:public class LocationMessage    : MvxMessage{    public LocationMessage(object sender, double lat, double lng)    : base(sender)    {        Lng = lng;        Lat = lat;    }    public double Lat {        get;        private set;    }    public double Lng {        get;        private set;    }}  define the classes which will create and send these Messages - e.g. a LocationService might create and send LocationMessages usingvar message = new LocationMessage(    this,    location.Coordinates.Latitude,    location.Coordinates.Longitude);_messenger.Publish(message);_messenger can be assigned through injection in the constructor.  define the classes which will subscribe to and receive these messages. Each of these classes must call one of the Subscribe methods on the IMvxMessenger and must store the returned token. For example part of a ViewModel receiving LocationMessages might look like:public class LocationViewModel    : MvxViewModel{    private readonly MvxSubscriptionToken _token;    public LocationViewModel(IMvxMessenger messenger)    {        _token = messenger.Subscribe&lt;LocationMessage&gt;(OnLocationMessage);    }    private void OnLocationMessage(LocationMessage locationMessage)    {        Lat = locationMessage.Lat;        Lng = locationMessage.Lng;    }    // remainder of ViewModel}The three different options for subscribing for messages differ only in terms of which thread messages will be passed back on:  Subscribe - messages will be passed directly on the Publish thread. These subscriptions have the lowest processing overhead - messages will always be received synchronously whenever they are published. You should use this type of subscription if you already know which type of thread the Publish will be called on and if you have a good understanding on the resource and UI usage of your message handler.  SubscribeOnMainThread - any message published on a background thread will be marshalled to the main UI thread.  This type of subscription is ideal if your message handler needs to perform some resource-unintensive task which involves interacting with the UI.  SubscribeOnThreadPoolThread - messages will always be queued for thread pool processing. This always involves an asynchronous post - even if the message is published on an existing ThreadPool thread. This type of subscription is ideal if your message handler needs to perform some resource-intensive task as it won’t block the UI, nor the message publisher.All subscription methods have two additional parameters:  MvxReference reference = MvxReference.Weak - specify MvxReference.Strong if you would prefer to use Strong references - in this case, the Messenger will keep a strong reference to the callback method and Garbage Collection will not be able to remove the subscription.  string tag = null - an optional tag which allows code to inspect what Message listeners are currently listening for - see ‘observe the current subscription status’ below.Subscriptions can be cancelled at any time using the Unsubscribe method on the IMvxMessenger or by calling Dispose() on the subscription token.However, in many cases, Unsubscribe/Dispose is never called. Instead listeners rely on the WeakReference implementation of the  MvxSubscriptionToken to clear up the subscription when objects go out of scope and Garbage Collection occurs.This GC-based unsubscription will occur whenever the subscription token returned from Subscribe is Garbage Collected - so if the token is not stored, then unsubscription may occur immediately - e.g. in this methodpublic void MayNotEverReceiveAMessage(){    var token = _messenger.Subscribe&lt;MyMessage&gt;((message) =&gt; {        Mvx.Trace(\"Message received!\");    });    // token goes out of scope now    // - so will be garbage collected *at some point*    // - so trace may never get called}For any code wishing to observe the current subscription status on any message type (including subscriptions that have been requested with a named string tag) then this can be done:  using the HasSubscriptionsFor and CountSubscriptionsFor methods  by subscribing for MvxSubscriberChangeMessage messages - the Messenger itself publishes these MvxSubscriberChangeMessage messages whenever subscriptions are made, are removed or have expired.public class MvxSubscriberChangeMessage : MvxMessage{    public Type MessageType {        get;        private set;    }    public int SubscriberCount {        get;        private set;    }    public MvxSubscriberChangeMessage(object sender, Type messageType, int countSubscribers = 0)    : base(sender)    {        SubscriberCount = countSubscribers;        MessageType = messageType;    }}These mechanisms allow you to author singleton services which can adapt their resource requirements according to the current needs of the app.For example, suppose you have a service which tracks stock prices using calls to a web service. Individual clients might subscribe to Messages from this service for individual stock codes. The stock service can track when subscribers are present for each stock code and can then adjust which network calls it makes.",
            "url": "/documentation/plugins/messenger"
          }
          ,
        
          "documentation-plugins-methodbinding" :{
            "title": "MethodBinding",
            "content": "The MethodBinding plugin is part of the Rio binding extensions for MvvmCross.The MethodBinding plugin is a pure PCL plugin - it contains only a PCL assembly.When MethodBinding is loaded, then MvvmCross data-binding:  can use public methods as well as ICommand properties for action/command binding.An example, Rio-based ViewModel using both FieldBinding and MethodBinding is:public class FirstViewModel    : MvxViewModel{    private readonly IDataStore _dataStore;    public FirstViewModel(IDataStore dataStore)    {        _dataStore = dataStore;    }    public void Init(int id)    {        var person = _dataStore.Get&lt;Person&gt;(id);        Id.Value = id;        FirstName.Value = person.FirstName;        LastName.Value = person.LastName;    }    public readonly INC&lt;int&gt; Id = new NC&lt;int&gt;();    public readonly INC&lt;string&gt; FirstName = new NC&lt;string&gt;();    public readonly INC&lt;string&gt; LastName = new NC&lt;string&gt;();    public void Save()    {        var person = _dataStore.Get&lt;Person&gt;(id);        person.FirstName = FirstName.Value;        person.LastName = LastName.Value;        _dataStore.Update(person);        Close(this);    }}The Save method in this class could be accessed using Android syntax:    &lt;Button        android:layout_width='fill_parent'        android:layout_height='wrap_content'        android:text='Save'        local:MvxBind='Click Save' /&gt;For more on Rio MethodBinding see N=36 on http://slodge.blogspot.co.uk/2013/07/n36-rio-binding-carnival.html",
            "url": "/documentation/plugins/methodbinding"
          }
          ,
        
          "documentation-plugins-network" :{
            "title": "Network",
            "content": "The original purpose of the Network plugin was to provide IMvxReachability on iOS onlypublic interface IMvxReachability{    bool IsHostReachable(string host);}Note: this interface is currently implemented on iOS only, although some contributors are working on other platforms (e.g. for Android see https://github.com/slodge/MvvmCross/issues/362)Since this original purpose, Network has now further been expanded to provide a simple Rest implementation - and this is available on Droid, iOS, Windows Uwp and Wpf.The Rest client is mainly implemented using the IMvxRestClient and IMvxJsonRestClient interfacespublic interface IMvxRestClient{    void ClearSetting(string key);    void SetSetting(string key, object value);    void MakeRequest(MvxRestRequest restRequest, Action&lt;MvxRestResponse&gt; successAction,                     Action&lt;Exception&gt; errorAction);    void MakeRequest(MvxRestRequest restRequest, Action&lt;MvxStreamRestResponse&gt; successAction,                     Action&lt;Exception&gt; errorAction);}public interface IMvxJsonRestClient{    Func&lt;IMvxJsonConverter&gt; JsonConverterProvider {        get;        set;    }    void MakeRequestFor&lt;T&gt;(MvxRestRequest restRequest, Action&lt;MvxDecodedRestResponse&lt;T&gt;&gt; successAction,                           Action&lt;Exception&gt; errorAction);}These are supported by a small set of Request and Response classes:  MvxRestRequest, MvxStreamRestRequest, MvxJsonRestRequest, MvxStringRestRequest, MvxStringRestRequest, MvxMultiPartFormRestRequest and MvxWwwFormRequest  MvxRestResponse, MvxStreamRestResponse, MvxJsonRestResponseTo make a simple fixed url Rest request, you can use:var request = new MvxRestRequest(\"http://myService.org/things/list\");var client = Mvx.Resolve&lt;IMvxRestClient&gt;();client.MakeRequest(request,(MvxStreamRestResponse response) =&gt; {    // do something with the response.StatusCode and response.Stream},error =&gt; {    // do something with the error});To use the Json APIs, you must have an IMvxJsonConverter implementation available - one way to get this is to load the Json plugin. With this in place, a simple Json upload with Json response might look like:var request = new MvxJsonRestRequest&lt;Person&gt;(\"http://myService.org/things/add\"){    Body = person};var client = Mvx.Resolve&lt;IMvxJsonRestClient&gt;();client.MakeRequestFor&lt;PersonAddResult&gt;(request,(MvxDecodedRestResponse&lt;PersonAddResult&gt; response) =&gt; {    // do something with the response.StatusCode and response.Result},error =&gt; {    // do something with the error});Note:  This Rest module is a ‘light-weight’ implementation which works for many simple Rest web services.  For more advanced web service requirements, consider extending the classes offered here or consider importing other more established Rest libraries such as RestSharp (http://restsharp.org/).",
            "url": "/documentation/plugins/network"
          }
          ,
        
          "documentation-plugins-phonecall" :{
            "title": "PhoneCall",
            "content": "The PhoneCall plugin provides implementations of:public interface IMvxPhoneCallTask{    void MakePhoneCall(string name, string number);}The PhoneCall plugin is available on Android, iOS, and WindowsPhone with a Skype-based implementation on WindowsStore.The PhoneCall plugin is very simple - e.g. it doesn’t provide any detection of whether or not a phone call is currently possible - e.g. for flight mode or for iPod-type devices without cell connectivity.SetupInstall the MvvmCross.Plugin.PhoneCall nuget in the Core and the platforms you want to support. After that you can inject the IMvxPhoneCallTask in your constructor and use it:public class MyViewModel : MvxViewModel{    public MyViewModel(IMvxPhoneCallTask phoneCallTask)    {        phoneCallTask.MakePhoneCall(\"Contact name\", \"+310631798511\");    }}",
            "url": "/documentation/plugins/phonecall"
          }
          ,
        
          "documentation-plugins-picturechooser" :{
            "title": "PictureChooser",
            "content": "The PictureChooser plugin provides implementations of:public interface IMvxPictureChooserTask{    void ChoosePictureFromLibrary(int maxPixelDimension, int percentQuality, Action&lt;Stream&gt; pictureAvailable,                                  Action assumeCancelled);    void TakePicture(int maxPixelDimension, int percentQuality, Action&lt;Stream&gt; pictureAvailable,                     Action assumeCancelled);}This is available on Android, iOS and Windows Uwp.This interface is designed for single use only - i.e. each time you require a picture you should request a new IMvxPictureChooserTask instance.The interface can be used as:var task = Mvx.Resolve&lt;IMvxPictureChooserTask&gt;();task.ChoosePictureFromLibrary(500, 90,stream =&gt; {    // use the stream    // expect the stream to be disposed after immediately this method returns.},() =&gt; {    // perform any cancelled operation});Note: Using this interface well on Android is very difficult.The reason for this is because of Android’s Activity lifecycle. The Android lifecycle means that the image that may be returned to a different View and ViewModel than the one that requested it. This is partly because camera apps generally use a lot of RAM (raw camera images are large files) - so while th camera app is capturing you image, then Android may look to free up additional RAM by killing your app’s Activity.If you want to use this IMvxPictureChooserTask effectively and reliably on Android then you really need to call this API via a service class, to use Messaging to pass the returned message back to a ViewModel and to implement ‘tombstoning’ support for that ViewModel.There is a simple demo for IMvxPictureChooserTask in PictureTaking - however, this simple demo doesn’t currently show this full Android technique.Note: On Windows Phone 8.0, an additional implementation is available:public interface IMvxCombinedPictureChooserTask{    void ChooseOrTakePicture(int maxPixelDimension, int percentQuality, Action&lt;Stream&gt; pictureAvailable,                             Action assumeCancelled);}Client code can test for the availability of this interface using:var isAvailable = Mvx.CanResolve&lt;IMvxCombinedPictureChooserTask&gt;();or:IMvxCombinedPictureChooserTask combined;var isAvailable = Mvx.TryResolve(out combined);Finally, the PictureChooser plugin also provides an “InMemoryImage” ValueConverter - MvxInMemoryImageValueConverter. This value converter allows images to be decoded from byte arrays for use on-screen.The “InMemoryImage” ValueConverter can be seen in use in the PictureTaking sample - see https://github.com/MvvmCross/MvvmCross-Samples/tree/master/PictureTaking.Windows Phone 8.1 Windows Phone 8.1 and Windows 8.1 API hasn’t converged entirely and there are differences in how pictures are handled. If you want to choose pictures from the gallery, you need to implement a EventHandler on your Page, which listens to Activated events. This is due to the picture data is returned on that event on Windows Phone 8.1.Hence in your constructor of your page add:var view = CoreApplication.GetCurrentView();view.Activated += ViewOnActivated;The ViewOnActivated EventHandler will look something like this:private void ViewOnActivated(CoreApplicationView sender, IActivatedEventArgs args){    var continuationArgs = args as FileOpenPickerContinuationEventArgs;    if (continuationArgs == null) return;    ViewModel.ContinueFileOpenPicker(args);}The ContinueFileOpenPicker() method in the ViewModel simply calls the same method on the IMvxPictureChooserTask:public void ContinueFilePicker(object args){    if (_currentChooserTask == null) return;    _currentChooserTask.ContinueFileOpenPicker(args);}If you don’t want to expose this method in your ViewModel, the alternative is to pass a message using IMvxMessenger instead.",
            "url": "/documentation/plugins/picturechooser"
          }
          ,
        
          "documentation-plugins-resourceloader" :{
            "title": "ResourceLoader",
            "content": "The ResourceLoader plugin provides access to files bundled within the app package.  On Android, this is for files bundled in the Assets folder and marked as Build Action of AndroidAsset  On iOS and Windows, this is for files bundled with a Build Action of ContentOn several platforms, the ResourceLoader plugin requires an IMvxFileStore is available. One easy way to supply this is to load the File plugin.The main interface supplied by this plugin is:public interface IMvxResourceLoader{    bool ResourceExists(string resourcePath);    string GetTextResource(string resourcePath);    void GetResourceStream(string resourcePath, Action&lt;Stream&gt; streamAction);}For a text file ‘Hello.txt’ bundled in a folder ‘Foo’, this can be called as:var loader = Mvx.Resolve&lt;IMvxResourceLoader&gt;();var contents = loader.GetTextResource(\"Foo/Hello.txt\");Samples using the ResourceLoader plugin include:  Babel - JsonLocalisation - see https://github.com/slodge/MvvmCross-Tutorials/tree/master/Babel  Conference - the sessions are loaded from Json resources - see https://github.com/slodge/MvvmCross-Tutorials/tree/master/Sample%20-%20CirriousConference",
            "url": "/documentation/plugins/resourceloader"
          }
          ,
        
          "documentation-plugins-resxlocalization" :{
            "title": "ResxLocalization",
            "content": "ResxLocalizationThe ResxLocalization plugin provides a support class to help use RESX files for internationalization (i18n).The ResxLocalization plugin is a single PCL Assembly and isn’t really a typical plugin - it doesn’t itself register any singletons or services with the MvvmCross IoC container.To start using it register your Resx file in the App.cs file:Mvx.RegisterSingleton(new MvxResxTextProvider(Strings.ResourceManager));For more advice on using the Localization library, see the blog post by @stefanschoeb. The ResxTextProvider he describes is now contained in the ResxLocalization plugin as MvxResxTextProvider. The language value converter he describes can also be used using the extension method ToLocalizationId() in fluent data binding, e.g.:bindingSet.Bind(TextBox).For(v =&gt; v.Text).ToLocalizationId(\"Description\");if your ViewModel implements the interface IMvxLocalizedTextSourceOwner.",
            "url": "/documentation/plugins/resxlocalization"
          }
          ,
        
          "documentation-plugins-share" :{
            "title": "Share",
            "content": "The Share plugin provides implementations of:public interface IMvxShareTask{    void ShareShort(string message);    void ShareLink(string title, string message, string link);}This plugin is available on Android and iOS. On Windows Uwp, sharing is done more by UI-based sharing (swipe in from the right).On Android, sharing is done using general Share/Send Intents. This could be improved in future implementations.On Windows Uwp, sharing is done via the OS level share task. On iOS, currently only sharing by linked Twitter account is supported. There is code available to extend this to Facebook - see https://github.com/slodge/MvvmCross/issues/188.A sample using the Share plugin is:  Conference - see https://github.com/slodge/MvvmCross-Tutorials/tree/master/Sample%20-%20CirriousConference",
            "url": "/documentation/plugins/share"
          }
          ,
        
          "documentation-plugins-visibility" :{
            "title": "Visibility",
            "content": "The Visibility plugin provides native implementations for the MvxVisibility enumeration.Visibility is available on all platforms.The Visibility functionality is generally not used directly - instead it’s generally used within ValueConverters used in Data-Binding. The plugin includes a couple of general purpose Value Converters - for more on these, see The Mvx Visibility ValueConverters.",
            "url": "/documentation/plugins/visibility"
          }
          ,
        
          "documentation-plugins-webbrowser" :{
            "title": "WebBrowser",
            "content": "The WebBrowser plugin provides cross platform support for showing web pages using the external web browser using:private void MySampleCommand(){    PluginLoader.Instance.EnsureLoaded();    var task = Mvx.Resolve&lt;IMvxWebBrowserTask&gt;();    task.ShowWebPage(\"http://www.xamarin.com\");}This plugin is available on all of Android, iOS and Windows Uwp.",
            "url": "/documentation/plugins/webbrowser"
          }
          
        
        ,
    
        
          "documentation-platform-android-support-library" :{
            "title": "Android support library",
            "content": "To get bindings working when using the support libraries (for example if you want to use MvxAutoCompleteTextView) you will need to do the following.In Setup.cs override FillTargetFactories.protected override void FillTargetFactories(    IMvxTargetBindingFactoryRegistry registry){    MvxAppCompatSetupHelper.FillTargetFactories(registry);    base.FillTargetFactories(registry);}SamplesA sample project can be found on github - MvvmCross-AndroidSupport",
            "url": "/documentation/platform/android-support-library"
          }
          ,
        
          "documentation-platform-ios-support-library" :{
            "title": "iOS Support Library",
            "content": "In version 4.0.0 we have started work on a new library dedicated to providing further classes and extended functionality targeting the iOS platform.Currently the classes available in this library consists of:  MvxSidebarPresenter  MvxBaseViewController  MvxExpandableTableViewSourceMvxSidebarPresenterThis presenter provides 3 panels as view “targets”, a main central panel, a right side panel and a left side panel. Where views appear in the UI and how they are shown is controlled through the decoration of a view controller using  class level attribute.A view controller class can be decorated with the MvxSidebarPresentationAttribute. The constructor for this attribute is shown below:public MvxSidebarPresentationAttribute(    MvxPanelEnum panel, MvxPanelHintType hintType, bool showPanel,    MvxSplitViewBehaviour behaviour = MvxSplitViewBehaviour.None){}This attribute is used by the presenter to make decisions about what to do with the view request when showing this view using the syntax shown below:[Register(\"CenterPanelView\")][MvxSidebarPresentation(     MvxPanelEnum.Center, MvxPanelHintType.ActivePanel, true)]public class CenterPanelView    : BaseViewController&lt;CenterPanelViewModel&gt;{}So to explain this example it’s telling the MvxSidebarPresenter that this view controller wants to be displayed in the center panel, set as the active panel and it also wants to be shown immediately.If this was using MvxPanelEnum.Left for instance this would be shown in the left hand panel and would also immediately slide the left panel into view.If the last value set in the attribute was set to false this would simply add the view to the left hand panel but leave the view hidden until the user performed some action in the UI that would result in that panel being shown.MvxSplitViewBehaviourThe MvxSidePanelsPresenter also contains a feature to allow this use of UISplitViewControllers “inline” with normal view controllers.  The presenter will automatically detect if the application is running on a large screen device (iPad) and provided the attribute details some behaviour other than None will respond accordingly.in a “normal” application view flow where a table of data is being displayed to the user it is fairly normal that there is some form of a child view that would show more details to the user in response to a users UI Touch on the table view.  In these cases on an small screen device (iPhone, iPad etc.) this would often result in a further navigation to a new view that shows the request content.However on devices with large screens this would often be displayed to the user on the same screen without the need for a navigation to a new view.  The data is then in a form of Master / Detail arrangement where both the Master (often a table view) and the Detail (the child view) will be displayed on the same screen.  A user touch on the master view results in the view hosted in the Detail view is then updated.The issue this behaviour deals with is that often iOS application will only user split views as the root view controller, this gets around this issue by allowing a split view to be shown as part of the normal flow of views without the need for explicitly setting this view as the root view in the view hierarchy.You can see an example of this below:[Register(\"MasterView\")][MvxPanelPresentation(     MvxPanelEnum.Center, MvxPanelHintType.ActivePanel,     true, MvxSplitViewBehaviour.Master)]public class MasterView    : BaseViewController&lt;MasterViewModel&gt;{}[Register(\"DetailView\")][MvxPanelPresentation(     MvxPanelEnum.Center, MvxPanelHintType.ActivePanel,     true, MvxSplitViewBehaviour.Detail)]public class DetailView    : BaseViewController&lt;DetailViewModel&gt;{}So when the presenter receives a request to show the master view and the application is running on a large screen device the presenter will respond to that request by constructing a number of controllers to manage the hosting of the split view controller and will then ultimately show the view in the appropriate section of the spit view.Subsequent touches on the UI master view which result in a request for view controller that requests to be shown as a detail view will then be shown in this same view (with no navigation occurring) but placed in the detail panel of the same instance of the split view created when the user navigated to the master view.Confused? See the demo applicationsMvxBaseViewControllerIn addition to the core MvvmCross view controller classes (MvxViewController) we have added a slightly expanded feature set to a new abstract base class called MvxBaseViewController.The idea behind this class is to gradually build up some “extended core” features that most developers will use without over-burdening  the class with too much extraneous stuff.At the moment this class is a generic view controller that has currently only one major feature over and above the core “basic” view controller - automatic keyboard handling.The feature requires there to be a UIScrollView in the view hierarchy in order to function.  It will detect a touch on a UIView that also expands the keyboard, it will then ensure that the view with focus is not obscured by the keyboard and is centered in the applications UI.  It can also optionally hide the keyboard when the user makes any further touches that moves focus away from the edit view.You can make use of this class using the following standard inheritance syntax:[Register(\"KeyboardHandlingView\")]public class KeyboardHandlingView    : MvxBaseViewController&lt;KeyboardHandlingViewModel&gt;{}In order to enable the keyboard handing features you need to first call the initializing method during view initialization, such as:public override void ViewDidLoad(){    base.ViewDidLoad();    // setup the keyboard handling    InitKeyboardHandling();    var scrollView = new UIScrollView();    Add(scrollView);    View.SubviewsDoNotTranslateAutoresizingMaskIntoConstraints();    View.AddConstraints(        scrollView.AtTopOf(View),        scrollView.AtLeftOf(View),        scrollView.WithSameWidth(View),        scrollView.WithSameHeight(View)    );}In addition to calling this initialization method you also need to override the following method and ensure that it returns true:public override bool HandlesKeyboardNotifications(){    return true;}",
            "url": "/documentation/platform/ios-support-library"
          }
          ,
        
          "documentation-platform-ios-tables-and-cells" :{
            "title": "iOS Tables and Cells",
            "content": "Available table source classes in MvvmCrossAbstract classes  MvxBaseTableViewSource          base functionality only      no ItemsSource - generally not used directly        MvxTableViewSource.cs          inherits from the basetable and adds ItemsSource for data-binding      inheriting classes need only to implement protected abstract UITableViewCell GetOrCreateCellFor(UITableView tableView, NSIndexPath indexPath, object item);        MvxExpandableTableViewSource.cs          inherits from MvxTableViewSource.cs      changes ItemSource to IEnumerable&lt;TItemSource&gt; ItemsSource for data-binding groups      inheriting classes need to implement protected abstract UITableViewCell GetOrCreateCellFor(UITableView tableView, NSIndexPath indexPath, object item); and register a header cell and table cell      Note available in MvvmCross.iOS.Support nuget package      Concrete classes  MvxStandardTableViewSource.cs          inherits from MvxTableViewSource      provides the ‘standard iPhone cell types’ via UITableViewCellStyle      within these you can bind TitleText, DetailText, ImageUrl and (with some teasing) Accessory        MvxSimpleTableViewSource.cs          inherits from MvxTableViewSource      provides a single cell type for all items in the collection - via string nibName in the ctor      within these cells you can bind what you like - see videos (later)        MvxActionBasedTableViewSource.cs          provides some Func&lt;&gt;style hooks to allow you to implement GetOrCreateCellFor without inheriting a new class from MvxTableViewSource      Custom table source exampleA typical TableSource with multiple cell types typically looks like:public class PolymorphicListItemTypesView : MvxTableViewController{    public PolymorphicListItemTypesView()    {        Title = \"Poly List\";    }    public override void ViewDidLoad()    {        base.ViewDidLoad();        var source = new TableSource(TableView);        this.AddBindings(new Dictionary&lt;object, string&gt;            {                {source, \"ItemsSource Animals\"}            });        TableView.Source = source;        TableView.RowHeight = KittenCell.GetCellHeight();        TableView.ReloadData();    }    public class TableSource : MvxTableViewSource    {        private static readonly NSString KittenCellIdentifier = new NSString(\"KittenCell\");        private static readonly NSString DogCellIdentifier = new NSString(\"DogCell\");        public TableSource(UITableView tableView)            : base(tableView)        {            tableView.SeparatorStyle = UITableViewCellSeparatorStyle.None;            tableView.RegisterNibForCellReuse(UINib.FromName(\"KittenCell\", NSBundle.MainBundle),                                              KittenCellIdentifier);            tableView.RegisterNibForCellReuse(UINib.FromName(\"DogCell\", NSBundle.MainBundle), DogCellIdentifier);        }        protected override UITableViewCell GetOrCreateCellFor(UITableView tableView, NSIndexPath indexPath,                                                              object item)        {            NSString cellIdentifier;            if (item is Kitten)            {                cellIdentifier = KittenCellIdentifier;            }            else if (item is Dog)            {                cellIdentifier = DogCellIdentifier;            }            else            {                throw new ArgumentException(\"Unknown animal of type \" + item.GetType().Name);            }            return (UITableViewCell) TableView.DequeueReusableCell(cellIdentifier, indexPath);        }    }}ReferencesFor examples of creating custom tables and cells:  there’s a lot of demos of table use in the N+1 series - indexed at http://mvvmcross.wordpress.com          N=2 and N=3 are very basic      N=6 and N=6.5 covers a book list (a good place to start)      N=11 covers collection views      N=12 to k=17 make a large app with a list/table from a database        the “Working with Collections” sample has quite a lot of Table and List code - https://github.com/MvvmCross/MvvmCross-Samples/tree/master/WorkingWithCollections  tables are used during the Evolve presentation - http://xamarin.com/evolve/2013#session-dnoeeoarfj  there are other samples available - see https://github.com/MvvmCross/MvvmCross-Samples (or search on GitHub for mvvmcross - others are also posting samples)  Custom Cells Without Using NIB files - http://benjaminhysell.com/archive/2014/04/mvvmcross-custom-mvxtableviewcell-without-a-nib-file/",
            "url": "/documentation/platform/ios-tables-and-cells"
          }
          ,
        
          "documentation-platform-universal-windows-platform-uwp-universal-windows-platform-uwp" :{
            "title": "Universal Windows platform (UWP)",
            "content": "InstallationThis tutorial will walk you through the installation of MvvmCross into a new Universal Windows Platform project.Create a new solution in Visual Studio. Right-click the solution in Solution Explorer and select Add -&gt; New Project....In the Add New Project dialog select the Windows Universal tab and select the Blank App template. In the bottom you can set the name. We will use MvvmCrossDocs.WindowsUniversal in this example.Now, we will open the New Project dialog again and create a Portable Class Library, that will act as the Core shared library in MvvmCross. In the dialog click the Visual C# node and find Class Library (Portable for iOS, Android and Windows). Name the project, in our case MvvmCrossDocs.Core.We will now want to reference the Core project inside of our Universal Windows project. To do that, right-click the References node under the UWP project in Solution Explorer and select Add reference…. In the opened dialog navigate to Projects -&gt; Solution in the left-side pane and then check the box next to our Core project in the list.Our projects are now ready and we can install MvvmCross from NuGet. First right-click the solution in Solution Explorer and then select Manage NuGet Packages for Solution.In the NuGet Package Manager window choose the Browse tab and enter mvvmcross into the search box. MvvmCross package should appear as the first result, which you can select and then check the boxes next to your project names in the right hand pane. When you are done, you can click the Install button to install the package. The installation might take a while and you will be prompted to agree with the changes. Confirm the prompt with OK and continue.Now we will need to add some basic code to get MvvmCross up and running.First inside the MvvmCrossDocs.Core portable project create a file named App.cs and enter the following:using MvvmCross.Platform.IoC;namespace MvvmCrossDocs.Core{public class App : MvvmCross.Core.ViewModels.MvxApplication{    public override void Initialize()    {        CreatableTypes()        .EndingWith(\"Service\")        .AsInterfaces()        .RegisterAsLazySingleton();        RegisterAppStart&lt;ViewModels.FirstViewModel&gt;();    }}}As you can see, in this code we are registering a first view model, which we will create now to be able to demonstrate the functionality of our setup later. Create a folder called ViewModels and inside a new file FirstViewModel.cs.using MvvmCross.Core.ViewModels;namespace MvvmCrossDocs.Core.ViewModels{public class FirstViewModel    : MvxViewModel{    private string _hello = \"Hello MvvmCross\";    public string Hello    {        get {            return _hello;        }        set {            SetProperty (ref _hello, value);        }    }}}Now we turn our attention to the Universal Windows Project. In the root of the project create a source file called Setup.cs with the following contents:using MvvmCross.Core.ViewModels;using MvvmCross.Platform.Platform;using MvvmCross.WindowsUWP.Platform;using Windows.UI.Xaml.Controls;namespace MvvmCrossDocs.WindowsUniversal{public class Setup : MvxWindowsSetup{    public Setup( Frame rootFrame ) : base( rootFrame )    {    }    protected override IMvxApplication CreateApp()    {        return new Core.App();    }    protected override IMvxTrace CreateDebugTrace()    {        return new DebugTrace();    }}}As you can see, the DebugTrace class does not exist. This class is recommended for all MvvmCross projects and it facilitates platform-based console logging during debug. Create a new file DebugTrace.cs in the root of your UWP project and paste the following:using System;using System.Diagnostics;using MvvmCross.Platform.Platform;namespace MvvmCrossDocs.WindowsUniversal{public class DebugTrace : IMvxTrace{    public void Trace( MvxTraceLevel level, string tag, Func&lt;string&gt; message )    {        Debug.WriteLine( tag + \":\" + level + \":\" + message() );    }    public void Trace( MvxTraceLevel level, string tag, string message )    {        Debug.WriteLine( tag + \":\" + level + \":\" + message );    }    public void Trace( MvxTraceLevel level, string tag, string message, params object[] args )    {        try        {            Debug.WriteLine( tag + \":\" + level + \":\" + message, args );        }        catch ( FormatException )        {            Trace( MvxTraceLevel.Error, tag, \"Exception during trace of {0} {1}\", level, message );        }    }}}Now navigate to the App.xaml.cs file in Solution Explorer. We want to start MvvmCross when the app launches. For that to happen, find the conditional if check for app’s rootFrame.Content and replace it with the following:if (rootFrame.Content == null){    var setup = new Setup( rootFrame );    setup.Initialize();    var start = MvvmCross.Platform.Mvx.Resolve&lt;MvvmCross.Core.ViewModels.IMvxAppStart&gt;();    start.Start();}Finally, we will create a sample view. Create a folder Views in the UWP project and create a new XAML Blank Page called FirstView.xaml inside.Open the XAML file and replace its contents with the following XAML code:&lt;views:MvxWindowsPage    x:Class=\"MvvmCrossDocs.WindowsUniversal.Views.FirstView\"    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"    xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"    xmlns:views=\"using:MvvmCross.WindowsUWP.Views\"    mc:Ignorable=\"d\"&gt;    &lt;Grid Background=\"{StaticResource ApplicationPageBackgroundThemeBrush}\"&gt;        &lt;StackPanel&gt;            &lt;TextBox Text=\"{Binding Hello, Mode=TwoWay}\" /&gt;            &lt;TextBlock Text=\"{Binding Hello}\" /&gt;        &lt;/StackPanel&gt;    &lt;/Grid&gt;&lt;/views:MvxWindowsPage&gt;Now there is only one more thing left to do. Open the FirstView.xaml.cs code file and change the type from which the FirstView class derives to MvxWindowsPage:public sealed partial class FirstView : MvxWindowsPageNow everything should be correctly set up and you can try to launch the application. If everything is correct, you should see a UI very similar to the following.Change the contents of the TextBox, and click elsewhere. The text below the TextBox should automatically update, proving that the data-binding is working as expected.Pages abstraction and ViewModel bindingThis section shows how to abstract Universal Windows Platform Page object to provide generic ViewModel binding.If you would like to provide generic way of binding Page with ViewModel, you would propably do it like presented below: public sealed partial class LoginPage&lt;LoginViewModel&gt;   {       public LoginPage()        {           this.InitializeComponent();        }    }Unfortunately this is not possible and that is why you have to provide abstraction for Pages.To achieve that you can create generic base class like below which derives from MvxWindowsPage class:public abstract class BaseApplicationMvxPage&lt;TViewModel&gt; : MvxWindowsPage&lt;TViewModel&gt; where TViewModel : MvxViewModel { }Now you have to create abstract class of Page you would like to use (in this case LoginPage) with selected ViewModel:public abstract class LoginPageAbstract : BaseApplicationMvxPage&lt;LoginViewModel&gt; { }Now your code-behind page (LoginPage.xaml.cs) code should look like below:public sealed partial class LoginPage : LoginPageAbstract {     public LoginPage()      {        this.InitializeComponent();      } }In XAML code page declaration should be provided like presented below:&lt;abstract:LoginPageAbstract    xmlns:abstract=\"using:MvvmCrossDemo.UWP.Pages.Abstract\"    x:Class=\"MvvmCrossDemo.UWP.Pages.LoginPage\"   &lt;!--rest of standard code here--&gt;&gt;    // Your UI code here",
            "url": "/documentation/platform/universal-windows-platform-uwp/universal-windows-platform-uwp"
          }
          ,
        
          "documentation-platform-xamarin-forms" :{
            "title": "Xamarin.Forms with MvvmCross",
            "content": "With the introduction of MvvmCross 5.0 we have full support for Xamarin Forms!TutorialLet’s take  a look at setting up a projectMvvmCross has some very helpful Nuget packages to get you started. In this case we will use the StarterPack Nuget to install the basic files and the MvvmCross.Forms Nuget to get us connected to Forms. Another great way is to use a Visual Studio extension like XabluCross for MvvmCross. In this guide I’m going to use Visual Studio for Mac to develop the sample App. You should be able to do the same using Visual Studio 2017, but things might just look slightly different.Note: this tutorial is using MvvmCross 5.0.7. Using other versions may not work!  Open up Visual Studio and start creating a New Solution in the File menu in the Menu.  In the Multi-platform section select Blank Forms App.  Enter the name for your new project, for this sample we will call it: MvxForms  As Target platforms we leave the default selected ones, Android and iOS.  For shared code we pick Portable Class Library. More information on that is available in the MvvmCross documentation.  In this we will use XAML for our layouts so leave that on default.  In the next page we leave the Project name and solution name to MvxForms. I would advice to create a .gitignore file if you are using Git. Press Create to finish.  In MvvmCross it is common to name the shared code project “.Core”. Change the name from MvxForms to MvxForms.Core.  Open the Core, Android and iOS projects, double click Packages and add the MvvmCross.StarterPack nuget and the MvvmCross.Forms nuget.  Remove the ToDo-MvvmCross and Views folders in the Android and iOS projects.  Change the App.cs name from:public class App : MvvmCross.Core.ViewModels.MvxApplicationTo:public class CoreApp : MvvmCross.Core.ViewModels.MvxApplicationWe do this because otherwise the Forms.App class conflicts with the MvvmCross.App class.  Edit the App.xaml file from:&lt;FormsApplication xmlns=\"http://xamarin.com/schemas/2014/forms\"     xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"     x:Class=\"MvxForms.Core.App\" &lt;/FormsApplication&gt;To:&lt;d:MvxFormsApplication xmlns=\"http://xamarin.com/schemas/2014/forms\"     xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"     x:Class=\"MvxForms.Core.App\"      xmlns:d=\"clr-namespace:MvvmCross.Forms.Core;assembly=MvvmCross.Forms\"&gt;&lt;/d:MvxFormsApplication&gt;Do the same for App.xaml.cspublic partial class App : FormsApplicationTo:public partial class App : MvxFormsApplication  Remove the line ‘MainPage = MvxFormsPage();’ from App.xaml.cs.  In the Setup.cs class of Android and iOS, change:protected override IMvxApplication CreateApp(){    return new Core.App();}To:protected override IMvxApplication CreateApp(){    return new Core.CoreApp();}protected override MvvmCross.Forms.Core.MvxFormsApplication CreateFormsApplication(){    return new App();}  Also change the base class of the Android setup from MvxAndroidSetup to MvxFormsAndroidSetup. Do the same on iOS from MvxIosSetup to MvxFormsIosSetup.  Note, if you get the error: No resource found that matches the given name (at ‘icon’ with value ‘@mipmap/icon’). Go to SplashScreen.cs and change Icon = “@mipmap/icon” to Icon = “@drawable/icon”.  On Android in your Activity replace theOnCreate method with:protected override void OnCreate(Bundle bundle){    TabLayoutResource = Resource.Layout.Tabbar;    ToolbarResource = Resource.Layout.Toolbar;     base.OnCreate(bundle);     global::Xamarin.Forms.Forms.Init(this, bundle);     var formsPresenter = (MvxFormsPagePresenter)Mvx.Resolve&lt;IMvxAndroidViewPresenter&gt;();    LoadApplication(formsPresenter.FormsApplication);}On iOS replace your AppDelegate code with:public partial class AppDelegate : MvxFormsApplicationDelegate{   public override UIWindow Window { get; set; }    public override bool FinishedLaunching(UIApplication app, NSDictionary options)   {        Window = new UIWindow(UIScreen.MainScreen.Bounds);         var setup = new Setup(this, Window);        setup.Initialize();         var startup = Mvx.Resolve&lt;IMvxAppStart&gt;();        startup.Start();         LoadApplication(setup.FormsApplication);         Window.MakeKeyAndVisible();         return true;    }}  The last step is to make your Xamarin.Forms page extend the MvxContentPage. You can either use a generic or name based convention to make MvvmCross recognize it. In MvxFormsPage.xaml.cs change:public partial class MvxFormsPage : ContentPageTo:public partial class MvxFormsPage : MvxContentPage&lt;MainViewModel&gt;  You need to change the XAML page attached to it as well:&lt;ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"     xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"     xmlns:local=\"clr-namespace:MvxForms.Core\"&gt;To:&lt;d:MvxContentPage x:TypeArguments=\"viewModels:MainViewModel\"     xmlns=\"http://xamarin.com/schemas/2014/forms\"     xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"     xmlns:local=\"clr-namespace:MvxForms.Core\"     x:Class=\"MvxForms.Core.MvxFormsPage\"     xmlns:viewModels=\"clr-namespace:MvxForms.Core.ViewModels;assembly=MvxForms.Core\"     xmlns:d=\"clr-namespace:MvvmCross.Forms.Core;assembly=MvvmCross.Forms\"&gt;  Note, if you are using a SplashScreen on Android you need to add:protected override void TriggerFirstNavigate(){    StartActivity(typeof(MainActivity));    base.TriggerFirstNavigate();}Otherwise your Forms Activity wouldn’t run and you’ll stuck on the SplashScreen.Fire up the App and enjoy!The result of this tutorial is available at: https://github.com/martijn00/MvxFormsWindows UWPModify Windows project’s MainPage.xaml.cs ctor. in the following way:public MainPage(){    InitializeComponent();    SupportedOrientations = SupportedPageOrientation.PortraitOrLandscape;    var presenter = Mvx.Resolve&lt;IMvxViewPresenter&gt;() as MvxFormsWindowsUWPPagePresenter;    LoadApplication(FormsApplication);}BindingsYou can use the MvvmCross binding syntax just like you would do in a native Xamarin project. For more information see the Bindings documentation.MasterDetail supportUse the MasterDetail presenters to add support for it to your app.MvxImageViewUse the MvxImageViewRenderer for MvvmCross.Forms to have a compatible ImageView Renderer.",
            "url": "/documentation/platform/xamarin-forms"
          }
          
        
        ,
    
        
          "documentation-licensing-licensing" :{
            "title": "Licensing",
            "content": "MvvmCross is licensed under the MS-PL LicenseMicrosoft Public License (MS-PL)This license governs use of the accompanying software. If you use the software, youaccept this license. If you do not accept the license, do not use the software.      DefinitionsThe terms “reproduce,” “reproduction,” “derivative works,” and “distribution” have thesame meaning here as under U.S. copyright law.A “contribution” is the original software, or any additions or changes to the software.A “contributor” is any person that distributes its contribution under this license.“Licensed patents” are a contributor’s patent claims that read directly on its contribution.        Grant of Rights(A) Copyright Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each contributor grants you a non-exclusive, worldwide, royalty-free copyright license to reproduce its contribution, prepare derivative works of its contribution, and distribute its contribution or any derivative works that you create.(B) Patent Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each contributor grants you a non-exclusive, worldwide, royalty-free license under its licensed patents to make, have made, use, sell, offer for sale, import, and/or otherwise dispose of its contribution in the software or derivative works of the contribution in the software.        Conditions and Limitations(A) No Trademark License- This license does not grant you rights to use any contributors’ name, logo, or trademarks.(B) If you bring a patent claim against any contributor over patents that you claim are infringed by the software, your patent license from such contributor to the software ends automatically.(C) If you distribute any portion of the software, you must retain all copyright, patent, trademark, and attribution notices that are present in the software.(D) If you distribute any portion of the software in source code form, you may do so only under this license by including a complete copy of this license with your distribution. If you distribute any portion of the software in compiled or object code form, you may only do so under a license that complies with this license.(E) The software is licensed “as-is.” You bear the risk of using it. The contributors give no express warranties, guarantees or conditions. You may have additional consumer rights under your local laws which this license cannot change. To the extent permitted under your local laws, the contributors exclude the implied warranties of merchantability, fitness for a particular purpose and non-infringement.  ",
            "url": "/documentation/licensing/licensing"
          }
          ,
        
          "documentation-licensing-references" :{
            "title": "References",
            "content": "  MonoCross was the original starting point for this project, and was used as a reference under MIT  Phone7.Fx is redistributed and modified under MS-PL  Tiny bits of MvvmLight are redistributed and modified under MIT  NewtonSoft.Json is redistributed and modified here under MIT  The original work on the JSON.Net port to MonoTouch and MonoDroid was done by @ChrisNTR  Sqlite-net - custom license  MonoTouch.Dialog - MIT X11  MonoDroid.Dialog - MIT X11  Messenger ideas from JonathanPeppers/XPlatUtils under Apache License Version 2.0, and from GrumpyDev/TinyMessenger under simple license of “THIS CODE AND INFORMATION IS PROVIDED “AS IS” WITHOUT WARRANTY”  Color codes under MIT License",
            "url": "/documentation/licensing/references"
          }
          
        
        ,
    
        
          "documentation-getting-started-debugging-with-symbols" :{
            "title": "Debugging with Symbols",
            "content": "Starting MvvmCross 5.x we have switched to use GitLink to help you easily step into MvvmCross code, without needing to do much configuration on your part.In short GitLink patches PDB files, to look at the MvvmCross GitHub repository with a specific commit hash.Stepping into MvvmCross code, it then fetches the exact code for that commit!Enabling debugging with SymbolsAs per the GitLink README, the only thing you need to do to enable this, is to go to Tools &gt; Options &gt; Debugging &gt; General and tick Enable source server support. That is it, you should now be able to step into MvvmCross code.If you encounter problems with Symbols, please refer to the Troubleshooting part of the GitLink README.",
            "url": "/documentation/getting-started/debugging-with-symbols"
          }
          ,
        
          "documentation-getting-started-getting-started" :{
            "title": "Getting Started with MvvmCross",
            "content": "            NuGet      Continuous Integration                              IntroductionMvvmCross is a cross-platform MVVM framework that enables developers to create powerful cross platform apps. It supports Xamarin.iOS, Xamarin.Android, Xamarin.Mac, Xamarin.Forms, Universal Windows Platform (UWP) and Windows Presentation Framework (WPF).The high level features that MvvmCross provides you with are:  MVVM architecture pattern  Navigation system  Data Binding  Platform specifics support  Inversion of control and Dependency Injection  Lots of plugins for common functionalities  Unit test helpers  Complete flexibility - your app is King!Your first project with Xamarin and MvvmCrossHere is a video that will help you creating a project from scratch with Xamarin and MvvmCross:https://www.youtube.com/watch?v=NihmK6R9r4sIt gives all the detailed steps for a solution that includes a Core PCL and app projects for iOS, Android and Windows Phone.Here is the article that contains the text version:http://jonathanroux.com/2016/02/09/mvvmcross-4-and-xamarin-project-setup/MvvmCross TemplatesYou can also install the templates for Visual Studio and Xamarin Studio:            Name      Author      Link                  XabluCross for MvvmCross      XabluCross      Visual Studio              MvvmCross for Visual Studio      Jim Bennett      Visual Studio - Visual Studio for Mac              MvvmCross Plugin Template for Visual Studio      EShy      Visual Studio              Xamarin MvvmCross Dreams      Artmdev      Visual Studio              Xamarin Forms with MvvmCross Solution Template      Cristian Chereches      Visual Studio              Ninja Coder For MvvmCross and Xamarin Forms      Ninja Coder for MvvmCross      Visual Studio              MVXTemplates      Luke Pothier      Visual Studio      You can choose to download and install an extension manually, or you can get it from the Extension Manager in Visual Studio / the Add-In Gallery in Xamarin Studio (Visual Studio for Mac).Help updating the docs!Everyone can contribute and help improving the docs! The docs are part of the source tree, so just go over to github and help us out!",
            "url": "/documentation/getting-started/getting-started"
          }
          ,
        
          "documentation-getting-started-mvvmcross-packages" :{
            "title": "MvvmCross Packages",
            "content": "MvvmCross is a very extensible framework. There is a lot already been made by the community which you can use. On this page you will find the MvvmCross nuget packages currently available.            Name      Description      Link                  MvvmCross.StarterPack      When starting a fresh project you should install this nuget. This will add all files to get you started. Afterwards you need to remove the nuget reference again manually from all your packages.config files (not through Nuget as this will delete the source files).      NuGet              MvvmCross      Main nuget. This will add Core and Binding.      NuGet              MvvmCross.Platform      Contains the libraries for all the separate platforms.      NuGet              MvvmCross.Core      Core libraries for the base of your app.      NuGet              MvvmCross.Tests      Test helpers      NuGet              MvvmCross.Droid.FullFragging      Support for native (Android &gt; 4.0) fragments, and more Android helpers      NuGet              MvvmCross.Console.Platform             NuGet              MvvmCross.CodeAnalysis      Code fixes for MvvmCross      NuGet              MvvmCross.Binding      Bindings system for all platforms      NuGet              MvvmCross.BindingEx             NuGet      Android Support            Name      Description      Link                  MvvmCross.Droid.Support.V4             NuGet              MvvmCross.Droid.Support.V7.AppCompat      AppCompat for MvvmCross      NuGet              MvvmCross.Droid.Support.V7.Fragging      Android support fragments, caching and helpers      NuGet              MvvmCross.Droid.Support.V7.Preference             NuGet              MvvmCross.Droid.Support.V7.RecyclerView             NuGet              MvvmCross.Droid.Support.V14.Preference             NuGet              MvvmCross.Droid.Support.V17.Leanback             NuGet              MvvmCross.Droid.Support.Design             NuGet      iOS Support            Name      Description      Link                  MvvmCross.iOS.Support      Helpers, featured ViewPresenters and Base classes for iOS      NuGet              MvvmCross.iOS.Support.JASidePanels      Implementation for JASidePanels library      NuGet              MvvmCross.iOS.Support.XamarinSidebar      Implementation for XamarinSidebar library      NuGet      Plugins            Name      Description      Link                  MvvmCross.Plugin.All             NuGet              MvvmCross.Plugin.Accelerometer             NuGet              MvvmCross.Plugin.Bookmarks             NuGet              MvvmCross.Plugin.Color             NuGet              MvvmCross.Plugin.DownloadCache             NuGet              MvvmCross.Plugin.Email             NuGet              MvvmCross.Plugin.FieldBinding             NuGet              MvvmCross.Plugin.File             NuGet              MvvmCross.Plugin.Json             NuGet              MvvmCross.Plugin.JsonLocalization             NuGet              MvvmCross.Plugin.Location             NuGet              MvvmCross.Plugin.Messenger             NuGet              MvvmCross.Plugin.MethodBinding             NuGet              MvvmCross.Plugin.Network             NuGet              MvvmCross.Plugin.PictureChooser             NuGet              MvvmCross.Plugin.ReflectionEx             NuGet              MvvmCross.Plugin.ResourceLoader             NuGet              MvvmCross.Plugin.Share             NuGet              MvvmCross.Plugin.SoundEffects             NuGet              MvvmCross.Plugin.SQLitePCL             NuGet              MvvmCross.Plugin.ThreadUtils             NuGet              MvvmCross.Plugin.Visibility             NuGet              MvvmCross.Plugin.WebBrowser             NuGet      ",
            "url": "/documentation/getting-started/mvvmcross-packages"
          }
          ,
        
          "documentation-getting-started-netstandard" :{
            "title": ".NET Standard &amp; MvvmCross",
            "content": "This document will briefly cover how you use .NET Standard in your core project, whilst still using the PCL based MvvmCross packages. This also works for other non-MvvmCross projects, where you want to have your core .NET Standard and still want to consume PCL projects in it.This document will asume that you are using the new csproj files and not using project.json to define your .NET Standard project.In order to consume PCL projects in any .NET Standard project you need to add a package target fallback for the PCL profile you want to consume. So let us assume you want to add MvvmCross.Bindings to your project. This library uses the PCL profile which has a signature that looks like portable-net45+win+wpa81+wp80. To add this as a target fallback you simply edit your csproj file and add the following line to it.&lt;PackageTargetFallback&gt;portable-net45+win+wpa81+wp80&lt;/PackageTargetFallback&gt;This line would normaly belong in the PropertyGroup which contains the TargetFramework, so it would look like. You can have multiple ;-separated fallbacks here, which helps you consume different profiles.&lt;Project Sdk=\"Microsoft.NET.Sdk\"&gt;  &lt;PropertyGroup&gt;    &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;    &lt;PackageTargetFallback&gt;portable-net45+win+wpa81+wp80&lt;/PackageTargetFallback&gt;  &lt;/PropertyGroup&gt;  &lt;!-- other entries --&gt;&lt;/Project&gt;From here you should be able to add MvvmCross and other PCL based NuGet packages to your .NET Standard project.",
            "url": "/documentation/getting-started/netstandard"
          }
          
        
        ,
    
        
          "documentation-fundamentals-customizing-using-app-and-setup" :{
            "title": "Customizing using App and Setup",
            "content": "Customizing using App and SetupIn each deployed MvvmCross application there are two key classes which control how your app starts:  the App class in the core project - which provides the initialization for your core business logic and your viewmodels.  the Setup class in the native UI project - this Setup is a bootstrapper for the MvvmCross system and for your app.App.csTypically App.cs provides only initialization of:  simple rule-based IoC registration - e.g.:CreatableTypes()    .EndingWith(\"Service\")    .AsInterfaces()    .RegisterAsLazySingleton();      the ViewModelLocator - how ViewModels are found or created when Views are displayed        the IMvxAppStart - which ViewModel or ViewModels are shown when the application is first started  Setup.csInternally the Setup bootstrapper performs many steps.You can see most of them in the MvxSetup.cs class source which includes a sequence like this:    // IoC    InitializeIoC();         // Core components    InitializeFirstChance();    InitializeDebugServices();    InitializePlatformServices();    InitializeSettings();    InitializeSingletonCache();    // Second components    PerformBootstrapActions();    InitializeStringToTypeParser();    InitializeViewModelFramework();    var pluginManager = InitializePluginFramework();    InitializeApp(pluginManager);    InitialiseViewModelTypeFinder();    InitializeViewsContainer();    InitiaiseViewDispatcher();    InitializeViewLookup();    InitialiseCommandCollectionBuilder();    InitializeNavigationSerializer();    InitializeInpcInterception();    InitializeLastChance();Most of these steps are virtual - so they allow customization. Also most of these steps are implemented using virtual Create steps - which again should make customization easier:protected virtual void InitialiseFoo(){    var foo = CreateFoo();    Mvx.RegisterSingleton&lt;Foo&gt;();}        protected virtual IFoo CreateFoo(){    return new Foo();}Added to these base class steps, each platform adds a small number of platform specific steps - eg Android adds some additional methods and properties for initialization of the Android UI and especially of the data-binding framework:    string ExecutableNamespace { get; }    Assembly ExecutableAssembly { get; }    IMvxAndroidViewPresenter CreateViewPresenter()    InitializeSavedStateConverter()    InitialiseBindingBuilder()    MvxAndroidBindingBuilder CreateBindingBuilder()    RegisterBindingBuilderCallbacks()    FillBindingNames(IMvxBindingNameRegistry registry)    FillAxmlViewTypeResolver(IMvxAxmlNameViewTypeResolver viewTypeResolver)    FillNamespaceListViewTypeResolver(IMvxNamespaceListViewTypeResolver viewTypeResolver)    FillValueConverters(IMvxValueConverterRegistry registry)    FillTargetFactories(IMvxTargetBindingFactoryRegistry registry)    IList&lt;string&gt; ViewNamespaces { get; }    IDictionary&lt;string, string&gt; ViewNamespaceAbbreviations { get; }    List&lt;Assembly&gt; ValueConverterAssemblies { get; }    List&lt;Type&gt; ValueConverterHolders { get; }    IList&lt;Assembly&gt; AndroidViewAssemblies { get; }This long list of virtual methods does provide a lot of opportunities for overriding default MvvmCross behaviour.However, most applications actually override only very few of these methods. Indeed, many applications only override only the one required method: IMvxApplication CreateApp()If you do want to override some of the Setup, then the rest of this document describes some of the methods and properties that you may find useful.Individual customizationsProviding application specific initializationThere are three key methods where application specific initialization might be added      App.Initialize - this is the place where all cross-platform app initialization should occur. In general it is the first choice for all app-specific initialization. Only use the Setup-based methods if you need platform-specific code injected        Setup.InitializeFirstChance - a “first blood” placeholder for any steps you want to take before any of the later steps happen        Setup.InitializeLastChance - a “last ditch” placeholder for any steps you want to take after all of earlier steps have happened. Note that the iOS and Android base classes configure binding within this method so you must call base.InitializeLastChance if you implement this method.  In this section, we’ll only introduce some of the possibilities for creating and registering objects during initialize and setup. For a more in-depth introduction to MvvmCross IoC, see Service Location and Inversion of Control.Registering cross-platform business objects in App.InitializeIt’s very common for App.Initialize to include IoC registration. Indeed, the default nuget App.cs template includesCreatableTypes()    .EndingWith(\"Service\")    .AsInterfaces()    .RegisterAsLazySingleton();This logic says:  within the Assembly containing the App  find all creatable Types - meaning:  with public constuctors  not marked abstract  find the interfaces they implement  lazily register these types as singletons - meaning:  that no instance will be created until one is requested  that once the first instance has been created, then that same instance will be returned for all subsequent requestsMany other registration techniques are available - including registering objects from other assemblies, using instance-per-request registration and using individual rather than reflection-based registrations. For more on these, see Service Location and Inversion of Control.Registering platform-specific business objects in Setup.InitializeFirstChance and Setup.InitializeLastChanceThese two placeholders provide key places for you to create and register services which are specific to your platform.For example, if you wanted to implement an EncryptionService which would provide native data-encryption for your application, then you could do this during Setup.InitializeFirstChance using: Mvx.RegisterType&lt;IEncryption, MyEncryption&gt;();This would then allow all of your App code - including code executed during App.Initialize() to use calls like:var encryption = Mvx.Resolve&lt;IEncryption&gt;();var safe = encryption.Encode(raw);Alternatively, if you wanted to implement a DialogService which would be used during normal UI flow, then you might choose to register this during Setup.InitializeLastChance as:Mvx.RegisterSingleton&lt;IDialogService&gt;(new MyDialogService());For many objects the choice of when to initialize - first or last - doesn’t matter. For others, the key choice is whether the service needs to be available before or after the App is created and initialized.Changing trace/debug outputEach platform provides a virtual CreateDebugTrace methods which offers your application a chance to customize where Mvx.Trace messages are displayed.To provide a custom trace implementation:  first implement a class which provides IMvxTrace  override Setup.CreateDebugTrace() in order to return an instead of your new classOne common use of this is simply to display messages to Debug using:public class MyDebugTrace : IMvxTrace{    public void Trace(MvxTraceLevel level, string tag, Func&lt;string&gt; message)\t{\t\tDebug.WriteLine(tag + \":\" + level + \":\" + message());\t}\tpublic void Trace(MvxTraceLevel level, string tag, string message)\t{\t\tDebug.WriteLine(tag + \":\" + level + \":\" + message);\t}\tpublic void Trace(MvxTraceLevel level, string tag, string message, params object[] args)\t{\t\ttry\t\t{\t\t\tDebug.WriteLine(string.Format(tag + \":\" + level + \":\" + message, args));\t\t}\t\tcatch (FormatException)\t\t{\t\t\tTrace(MvxTraceLevel.Error, tag, \"Exception during trace of {0} {1} {2}\", level, message);\t\t}\t}}this can be returned during Setup using:protected override IMvxTrace CreateDebugTrace() {     return new MyDebugTrace(); }Changing the IoC container that MvvmCross usesIoC is the first thing that MvvmCross setup starts.This is done within the method InitializeIoCTo override MvvmCross’ IoC, you can:  first find your alternative IoC implementation - e.g. something like AutoFac, Funq or TinyIoC  then create an Adapter which maps the implementation behind an IMvxIoCProvider interface and which inherits from MvxSingleton in order to provide a Singleton          the majority of the adaption should be relatively straight-forwards - see MvxSimpleIoCContainer for how the default IoC container is provided.      The only unusual methods in the MvvmCross IoC interface are the CallbackWhenRegistered hooks - these provide callbacks when new object types are registered and may require a little custom code in the RegisterXXX methods within your adapter.        finally, you can override IMvxIoCProvider CreateIocProvider() in your Setup class to return your IoC providerProviding additional View and ViewModel AssembliesThe default MvvmCross ViewModel Locator looks for:  Views in the Assembly containing Setup.cs  ViewModels in the Assembly containing App.csIf you wish to add additional View and ViewModel assemblies, then you can do this using overrides in Setup:protected override Assembly[] GetViewAssemblies(){    var list = new List&lt;Assembly&gt;();    list.AddRange(base.GetViewAssemblies());    list.Add(typeof(SomeTypeFromAdditionalViewAssembly1).Assembly);    list.Add(typeof(SomeTypeFromAdditionalViewAssembly2).Assembly);    list.Add(typeof(SomeTypeFromAdditionalViewAssembly3).Assembly);    // ...    return list.ToArray();}protected override Assembly[] GetViewModelAssemblies(){    var list = new List&lt;Assembly&gt;();    list.AddRange(base.GetViewModelAssemblies());    list.Add(typeof(SomeTypeFromAdditionalViewModelAssembly1).Assembly);    list.Add(typeof(SomeTypeFromAdditionalViewModelAssembly2).Assembly);    list.Add(typeof(SomeTypeFromAdditionalViewModelAssembly3).Assembly);        // ...    return list.ToArray();}Overriding ViewModel Location/ConstructionBy default, MvvmCross builds a new ViewModel every time one is requested and uses the CIRS sequence - Construction-Init-ReloadState-Start - to initialize that ViewModel.If you want to override this behaviour for one or more ViewModel types, then you can do this in your App object by supplying your own IMvxViewModelLocator implementation.For example, you could implementpublic class MyViewModelLocator  : MvxDefaultViewModelLocator{    private SpecialViewModel _special = new SpecialViewModel();    public override bool TryLoad(Type viewModelType, IDictionary&lt;string, string&gt; parameterValueLookup,\t                             out IMvxViewModel model)    {        if (viewModelType == typeof(SpecialViewModel))        {        \tmodel = _special;        \treturn true;        }        else if (viewModelType == typeof(FooViewModel))        {        \tmodel = new FooViewModel(_special);        \treturn true;        }                return base.TryLoad(viewModelType, parameterValueLookup, out model);    }}and could then return this in App.cs:protected override IMvxViewModelLocator CreateDefaultViewModelLocator(){    return new MyViewModelLocator();}Custom IMvxAppStartWhen an MvvmCross application starts by default it shows the View associated with a single ViewModel type.This default behaviour is configured in Initialize in App.cs using:RegisterAppStart&lt;FirstViewModel&gt;();If more advanced startup logic is needed, then a custom app start can be used - e.g.public class CustomAppStart        : MvxNavigatingObject        , IMvxAppStart{    public void Start(object hint = null)    {        var auth = Mvx.Resolve&lt;IAuth&gt;();        if (auth.Check())        {            ShowViewModel&lt;HomeViewModel&gt;();        }        else        {            ShowViewModel&lt;LoginViewModel&gt;();        }    }}This can then be registered in App using:RegisterAppStart(new CustomAppStart());Note: For situations where the app is launched using a protocol - e.g. from a Push notification or from an email link - then the object hint parameter start can be used to transfer a hint from the UI to the start object. Currently, it’s up to you - the app developer - to write the UI side code to do this.Custom PresentersFor ‘my first MvvmCross application’ most people start with a ‘full page’ app in which each ShowViewModel causes a new View to be displayed, filling an entire screen at a time.There are many other possibilities for ViewModel-&gt;ViewModel navigation, including:  tabbed displays  dialogs and flyouts  ‘hamburger menus’  splitviews, master-detail displays, screen ‘regions’ and other screen division/fragmentationTo provide these alternative UI possibilities, MvvmCross allows each app to provide a custom presenter.For more on custom presenters, see several articles and videos linked from: http://slodge.blogspot.co.uk/2013/06/presenter-roundup.htmlProviding ValueConvertersFor the platforms that use MvvmCross’ databinding platform, then ValueConverters:are classes which implement IMvxValueConverterare registered by name with a singleton IMvxValueConverterRegistryThere are several ways that individual ValueConverters can be registered. The most common are all in Setup.cs:  registering all value converters inside an assembly. To do this: override ValueConverterAssemblies:  registering value converters using a wrapper Converters class  registering value converters one at a timeThese three techniques are shown as:```c#// 1. register all value converters in the Assembly containing MyFirstValueConverterprotected override List ValueConverterAssemblies{ get {     var toReturn = base.ValueConverterAssemblies;     toReturn.Add(typeof(MyFirstValueConverter).Assembly);     return toReturn; }}// 2. register all value converters in the wrapper Converterspublic class Converters{    // this converter will be registered with name “TheLength”    public readonly LengthValueConverter TheLength = new LengthValueConverter();}protected override protected List ValueConverterHolders{    get    {        var toReturn = base.ValueConverterHolders;        toReturn.Add(typeof(Converters);        return toReturn;    }}// 3. register value converters one at a timeprotected override void FillValueConverters(IMvxValueConverterRegistry registry){    base.FillValueConverters(registry);registry.AddOrOverwrite(\"Foo\", new SquareValueConverter()); } ```Notes:When using the Assembly based method then the registered name uses the rules:  remove any Mvx prefix  remove any ValueConverter or Converter suffix  because of this a value converter in a class MvxBeerValueConverter will be registered under the name Beer  When using any of the registration mechanisms then the value converters are always ultimately added using a call to registry.AddOrOverwrite - so in the case of a name clash, then the last added value converter always wins.One final technique used for registering value converters is used by some of the plugins to enable them to register value converters independently of the main setup flow.This technique involves using the CallbackWhenRegistered IoC method on the IMvxValueConverterRegistry interface. This is used, for example, in the Visibility plugin as:Mvx.CallbackWhenRegistered&lt;IMvxValueConverterRegistry&gt;(RegisterValueConverters);        // ...    private void RegisterValueConverters(){    var registry = Mvx.Resolve&lt;IMvxValueConverterRegistry&gt;();    registry.AddOrOverwriteFrom(GetType().Assembly);}   For more on creating ValueConverters, see the ValueConverter sample in: https://github.com/slodge/MvvmCross-Tutorials/tree/master/ValueConversionProviding Custom Views (Android)In Android, MvvmCross overrides the default Android xml inflation and instead provides its own mechanism.In order to do this, you must supply the MvvmCross binding system with a list of Assembly’s in which it should look for Android View objects (note that these are Android View objects and have nothing to do with Mvvm Views at this point).To do this, you can override the Setup property AndroidViewAssemblies:protected override IList&lt;Assembly&gt; AndroidViewAssemblies {    get {        return new List&lt;Assembly&gt;(base.AndroidViewAssemblies) {            typeof (CheeseBaron.ExcellentViews.Pages).Assembly,            typeof (AnyAdditionalViewType).Assembly        };    }}Or as an expression body property in C# 6:protected override IList&lt;Assembly&gt; AndroidViewAssemblies =&gt; new List&lt;Assembly&gt;(base.AndroidViewAssemblies) {     typeof (CheeseBaron.ExcellentViews.Pages).Assembly,    typeof (AnyAdditionalViewType).Assembly};For more on writing Custom Views, see the N=18 and N=19 steps in N+1 - todo-linkRegistering Default Binding NamesIn iOS Fluent Bindings you frequently see code like:set.Bind(myLabel).To(vm =&gt; vm.FullName);This code uses a developer shortcut - the default binding property of a UILabel. This is just a shortcut and it means the binding is actually performed as:set.Bind(myLabel).For(label =&gt; label.Text).To(vm =&gt; vm.FullName);At present the defined set of default properties or events includes:UIButton TouchUpInsideUIBarButtonItem ClickedUITextField TextUITextView TextUITextField TextMvxCollectionViewSource ItemsSourceMvxTableViewSource ItemsSourceMvxImageView ImageUrlUIImageView\tImageUIDatePicker DateUISlider ValueUISwitch OnUIDatePicker DateIMvxImageHelper ImageUrlMvxImageViewLoader ImageUrlIf you would like register additional shortcuts in your application, or if you’d like to replace some of the existing shortcuts, then this can be done in FillBindingNamesprotected override void FillBindingNames(IMvxBindingNameRegistry registry){\tregistry.AddOrOverwrite(typeof (MyControl), \"MyDefaultPropertyOrEvent\");}Registering custom bindingsMvvmCross binding works by default against Android and iOS UI objects by trying to use Reflection on properties and events.This generally works really well, especially for cases where properties and events are linked using the convention that the property called Foo is associated with the change event FooChangedFor situations where this default binding doesn’t work, custom bindings can be written and these can be registered using an override of the FillTargetFactories method in the Android and iOS Setup classes.For more on this, see the N+1 video on custom binding - N=28.Overriding View-ViewModel associationsBy default, MvvmCross discovers the ViewModel that a View is associated with using the type of ViewModel discovered by name conventionThis makes prototyping initial application generally very functionality straight-forward.However, as applications grow in size and complexity, then sometimes developers like to override this lookup behaviour.To do this they can instead:  provide a concrete type of the ViewModel where one is specified - e.g. as:    public new DetailViewModel ViewModel{  get { return base.ViewModel as DetailViewModel; }  set { base.ViewModel = value; }}        provide an explicit type of the ViewModel specified using an MvxViewForAttributeFurther, in cases where every microsecond of startup time is essential, they can also help reduce the Reflection overhead by overriding the InitializeViewLookup method - e.g.protected override void InitializeViewLookup(){    var viewModelViewLookup = new Dictionary&lt;Type, Type&gt;()    {        { typeof (FirstViewModel), typeof(FirstView) },        { typeof (SecondViewModel), typeof(SecondView) },        \t//        { typeof (UmpteenthViewModel), typeof(UmpteenthView) },    };    var container = Mvx.Resolve&lt;IMvxViewsContainer&gt;();    container.AddAll(viewModelViewLookup);}",
            "url": "/documentation/fundamentals/Customizing-using-App-and-Setup"
          }
          ,
        
          "documentation-fundamentals-analysis" :{
            "title": "Code Analysis",
            "content": "BackgroundWith the release of C# version 6 Microsoft has rewritten their C# and VB compilers from the ground up. They are known as the Microsoft .NET Compiler Platform (aka Roslyn). These compilers provide library builders to provide the compiler with a set of so-called Analyzers and CodeFixes. These can be shipped through a nuget package, and will light up in an IDE with support for these Roslyn based compilers.What is this (aka TLDR)?Pull-request #1117 is the first attempt to introduce such analyzers and code fix providers for the MvvmCross library. This fixes #1040.What does it do?In short it helps developers use the MvvmCross library the way it was intended to be used.This first analyzer will identify the following code:[Activity(...)]class FirstView : MvxActivity{    public new FirstViewModel ViewModel =&gt; base.ViewModel as FirstViewModel;}and provide you with a IDE tooltip to transform the code into:[Activity(...)]class FirstView : MvxActivity&lt;FirstViewModel&gt; {    ...}What’s in it?  A new project type under the CodeAnalysis solution folder named MvvmCrossCodeAnalysis (there’s no . in the name for reasons - no tooling support) I’m wondering what you guys think about that?  A Vsix package to enable easy debugging of Code Analyzers/Fixes.Installation Steps  To use the Analyzers and Code Fixes, just add the NuGet package to your Core project, MvvmCross.CodeAnalysis.Testing  If you would like to create a new Analyzer/CodeFix, please consider adding tests to it. To do so, add a new class with your tests to the project MvvmCross.CodeAnalysis.Test, follow this guidelines:Test class declaration  If your code contains only a Diagnostic, your test class should inherit from[DiagnosticVerifier].There is also a generic version, [DiagnosticVerifier&lt;T&gt;], where T should be your analyzer([DiagnosticAnalyzer]). The generic version is preferred because it already associate the test class with the Analyzer being tested.Test setup      Your test methods should be quite simple. Provide test cases (strings containing full sample code) for the Analyzer and call method VerifyCSharpDiagnostic. This method receives your sample code and a DiagnosticResult instance, which should specify where and which analyzer should be triggered for this sample code, including the message, the DiagnosticId, severity and possible locations (column/line).        If your Analyzer also contains a code fix, your test class should inherit from[CodeFixVerifier]. This class inherits from [DiagnosticVerifier], and adds a few methods related to testing code fixes. There is also a generic version for this, [CodeFixVerifier&lt;T, TU&gt;], where T should inherit from [DiagnosticAnalyzer] and TU should inherit from [CodeFixProvider].        To test your code fix, you should add another test case that calls method [VerifyCSharpFix], passing the original source sample and another string containing the final result of how the code should look after the code fix executes. Remember about line endings and blank spaces. Tabs (\t) are not spaces.  More info  For additional information about analyzers and code fixes, follow this article:https://msdn.microsoft.com/en-us/magazine/dn904670.aspx",
            "url": "/documentation/fundamentals/analysis"
          }
          ,
        
          "documentation-fundamentals-app-lifecycle" :{
            "title": "App lifecycle",
            "content": "ViewModel CreationIn MvvmCross v3 - Hot Tuna - the default ViewModel location and construction was overhauled in order to provide 3 new features:  constructor based Dependency Injection  navigation using Typed navigation classes  saving and reloading VM state for ‘tombstoning’These changes were breaking changes for existing v1 and vNext apps, but provide significant testability and usability advantages for MvvmCross developers.How ViewModels are Created in v3The default ViewModelLocator in v3 builds new ViewModel instances using a 4-step process - CIRS:  Construction - using IoC for Dependency Injection  Init() - initialization of navigation parameters  ReloadState() - rehydration after tombstoning  Start() - called when initialization and rehydration are complete1. ConstructionIn MvvmCross, you can navigate to a ViewModel using parameter like:ShowViewModel&lt;DetailViewModel&gt;(    new{    First=\"Hello\",    Second=\"World\",    Answer=42});In older version of MvvmCross, these navigation parameters were passed to the constructor of the ViewModel.However, from v3 moving forwards, these navigation parameters are instead passed to the Init() method, and the constructor is now free to be used for Dependency Injection.This means that, for example, a DetailViewModel constructor might now look like:public class DetailViewModel : MvxViewModel{    private readonly IDetailRepository _repository;    public DetailViewModel(IDetailRepository repository)    {        _repository = repository;    }    // ...}This Dependency Injection is, of course, optional - you code can instead continue to use ServiceLocation if you prefer:public class DetailViewModel : MvxViewModel{    private readonly IDetailRepository _repository;    public DetailViewModel()    {        repository = Mvx.Resolve&lt;IDetailRepository&gt;();    }    // ...}2. Init()Now that the construction is used for Dependency Injection, the navigation parameters move to a new method - Init()Init() will always be called after construction and before ReloadState() and Start()Init() can come in several flavors:.  individual simply-Typed parameters  a single Typed parameter object with simply-Typed properties  as InitFromBundle() with an IMvxBundle parameter - this last flavor is always supported via the IMvxViewModel interface.You can declare zero or more of each of these types, but generally you will probably only want to use one within your application.So, for example, to support the navigation:RequestNavigate&lt;DetailViewModel&gt;(new { First=\"Hello\", Second=\"World\", Answer=42 });you could implement any of:public class DetailViewModel : MvxViewModel{    // ...    public void Init(string First, string Second, int Answer)    {        // use the values    }    // ...}or:public class DetailViewModel : MvxViewModel{    // ...    public class NavObject    {        public string First {            get;            set;        }        public string Second {            get;            set;        }        public int Answer {            get;            set;        }    }    public void Init(NavObject navObject)    {        // use navObject    }    // ...}or:public class DetailViewModel : MvxViewModel{    // ...    public override void InitFromBundle(IMvxBundle bundle)    {        // use bundle - e.g. bundle.Data[\"First\"]    }    // ...}Note that multiple calls can be used together if required. This allows for some separation of logic in your code. However, the separate objects cannot share field names and generally this approach is confusing… so is not really recommended:public class DetailViewModel : MvxViewModel{    // ...    public class FirstNavObject    {        public string First {            get;            set;        }        public string Second {            get;            set;        }    }    public class SecondNavObject    {        public int Answer {            get;            set;        }    }    public void Init(FirstNavObject firstNavObject)    {        // use firstNavObject    }    public void Init(SecondNavObject secondNavObject)    {        // use secondNavObject    }    // ...}3. ReloadStateIf the View/ViewModel is recovering from a Tombstoned state, then ReloadState will be called with the data needed for rehydration.If there is no saved state then no ReloadState() methods will be called.Exactly as with Init(), ReloadState can be called in several different ways.  individual simply-Typed parameters  a single Typed parameter object with simply-Typed properties  as ReloadStateFromBundle() using an IMvxBundle parameter - this last flavor is always supported via the IMvxViewModel interface.Normally, I’d expect this to be called as:public class DetailViewModel : MvxViewModel{    // ...    public class SavedState    {        public string Name {            get;            set;        }        public int Position {            get;            set;        }    }    public void ReloadState(SavedState savedState)    {        // use savedState    }    // ...}Aside: where does the SavedState come from?One of the new ViewModel APIs available in Hot Tuna is a SaveState pattern.This can be implemented in one of two ways:  using one or more paremeterless methods that return Typed state objects  using the override SavedStateToBundle(IMvxBundle bundle)Using a Typed state object:public class DetailViewModel : MvxViewModel{    // ...    public class SavedState    {        public string Name {            get;            set;        }        public int Position {            get;            set;        }    }    public SavedState SaveState()    {        return new SavedState()        {            Name = _name,            Position = _position        };    }    // ...}Using SavedStateToBundle:public class DetailViewModel : MvxViewModel{    // ...    protected override void SaveStateToBundle(IMvxBundle bundle)    {        bundle.Data[\"Name\"] = _name;        bundle.Data[\"Position\"] = _position.ToString();    }    // ...}4. Start()After all of Construction, Init, and ReloadState is complete, then the Start() method will be called.This method is simply:public class DetailViewModel : MvxViewModel{    // ...    public override void Start()    {        // do any start    }    // ...}Putting it all togetherFor a real app, I would expect the navigation, construction and state saving/loading code to actually look like:ShowViewModel&lt;DetailViewModel&gt;(    new DetailViewMode.NavObject{    First = \"Hello\",    Second = \"World\",    Answer = 42});andpublic class DetailViewModel : MvxViewModel{    public class SavedState    {        public string Name {            get;            set;        }        public int Position {            get;            set;        }    }    public class NavObject    {        public string First {            get;            set;        }        public string Second {            get;            set;        }        public int Answer {            get;            set;        }    }    private readonly IDetailRepository _repository;    public DetailViewModel(IDetailRepository repository)    {        _repository = repository;    }    public void Init(NavObject navObject)    {        // use navObject    }    public void ReloadState(SavedState savedState)    {        // use savedState    }    public override void Start()    {        // do any start    }    public SavedState SaveState()    {        return new SavedState()        {            Name = _name,            Position = _position        };    }    // ...}Overriding CIRS.If you don’t like this CIRS (Construction-Init-ReloadState-Start) flow for building your ViewModels, then the good news is that you can easily override the ViewModelLocator within v3, just as you could within earlier MvvmCross versions. For more on this see LINK-TODOViewModel Deactivation, Activation and DestructionMonitoring other View/ViewModel lifecycle event across multiple platforms is fairly tricky, especially once developers start experimenting beyond the ‘basic’ presentation models and start using tabs, splitviews, popups, flyouts, etcFor most viewmodels, it’s common to not try to monitor other lifecyle events. This is OK since most viewmodels don’t perform any actions and don’t consume any resources when the view is not present - so these can just be left to be garbage collected when the system needs the memory back.For ViewModels which consume low-intensity resources - like timer ticks - then these can generally use the MvxMessenger to connect the ViewModel to those resources. This messenger uses weak referencing by default and itself sends out subscription change messages when clients subscribe/unsubscribe. Using this method, a developer can allow the background resources to monitor whether the viewmodels are in memory (and referenced by views) - and so the background resources can manage themselves.For those rare situations where resource monitoring is actively needed - e.g. for the SpheroViewModel which needs to maintain an active BlueTooth SPP channel - then it is possible to implement a custom interface on the ViewModel - e.g. IActiveViewModel - and this interface can be called from each of the views on each of the client platforms.Generally this involves being hooked up from ViewDidAppear/Disappear on iOS, OnNavigatedTo/From on Windows, and OnRestart/Pause on Android, although this may vary depending on the exact presentation of your views (eg whether they are whole pages, tabs, flyouts, etc).",
            "url": "/documentation/fundamentals/app-lifecycle"
          }
          ,
        
          "documentation-fundamentals-custom-data-binding" :{
            "title": "Custom Data Binding",
            "content": "This article descibes how to add your own definitions for binding custom views or views, which MvvmCross does not support out of the box in TwoWay mode. Or for views that require extra parameters when needing to set them, or if you want to add bindings for views that expose no properties etc.In order to do so, you will need to write a Target Binding class which descibes how to bind a specific property and in case of TwoWay bindings, which event to listen to value changes on.Typically on iOS and Android a property will have an event indicating it changed. This is a bit different from Windows and Xamarin.Forms, where you normally will have a DependencyProperty or BindableProperty which describes how to both get and set and how to react to updates to that property. These properties and the responsibility to implement these on those platforms are up to the View itself. In MvvmCross, we have these descriptions outside of the View, meaning in a lot of cases, no modifications are needed in order to add descriptions on how to bind a View.Adding A Target BindingLet us start by making a couple of assumptions. We are binding a View called MyView, we want to bind to MyView’s public property MyProperty, of type string which has both a getter and a setter. The View also has a MyPropertyChanged event, which fires when someone sets the MyProperty. With this information we can now define a Target Binding.public class MyViewMyPropertyTargetBinding    : MvxPropertyInfoTargetBinding&lt;MyView&gt;{    // used to figure out whether a subscription to MyPropertyChanged    // has been made    private bool _subscribed;    public override MvxBindingMode DefaultMode =&gt; MvxBindingMode.TwoWay;    public MyViewMyPropertyTargetBinding(object target, PropertyInfo targetPropertyInfo)        : base(target, targetPropertyInfo)    {    }    // describes how to set MyProperty on MyView    protected override void SetValueImpl(object target, object value)    {        var view = target as MyView;        if (view == null) return;        view.MyProperty = (string)value;    }    // is called when we are ready to listen for change events    public override void SubscribeToEvents()    {        var myView = View;        if (myView == null)        {            MvxBindingTrace.Trace(MvxTraceLevel.Error, \"Error - MyView is null in MyViewMyPropertyTargetBinding\");            return;        }        _subscribed = true;        myView.MyPropertyChanged += HandleMyPropertyChanged;    }    private void HandleMyPropertyChanged(object sender, EventArgs e)    {        var myView = View;        if (myView == null) return;        FireValueChanged(myView.MyProperty);    }    // clean up    protected override void Dispose(bool isDisposing)    {        base.Dispose(isDisposing);        if (isDisposing)        {            var myView = View;            if (myView != null &amp;&amp; _subscribed)            {                myView.MyPropertyChanged -= HandleMyPropertyChanged;                _subscribed = false;            }        }    }}As you can see it is fairly simple to define these classes and for each one you define you have an additional step where you will have to add this Target Binding definition in your Setup.cs file by overriding FillTargetFactories.protected override void FillTargetFactories(IMvxTargetBindingFactoryRegistry registry){    base.FillTargetFactories(registry);    registry.RegisterPropertyInfoBindingFactory(        typeof(MyViewMyPropertyTargetBinding),        typeof(MyView), \"MyProperty\");}Internals Of A Target BindingAll target bindings are a subclass of MvxTargetBinding, there are a couple of subclasses of this, which MvvmCross provides, which contain some additions to help prevent issues such as infinte call loops. Adding support for converters, adding platform specifics and overcoming View quirks.This section goes a little bit deeper into what each of these variants provide.MvxTargetBindingThis is the base for all target bindings, it implements IMvxTargetBinding, which exposes:  TargetType property describing the type of the target to be bound  Mode property describing the mode of the binding (OneWay, TwoWay, OneWayToSouce etc.)  SetValue() method to describe how to set a value from the source  ValueChanged event to notify the binding engine that the target change its value  SubscribeToEvents() method called when we are ready to hook up event handlersThe MvxTargetBinding class additionally adds FireValueChanged(), which is a helper method to raise the ValueChanged event, allowing the developer to just pass along the new value to the method.It also makes a WeakReference to the target and exposes that reference as the Target property.MvxConvertingTargetBindingThis is the base that most target bindings use. A lot of target bindings will have to support using converters and MvvmCross combiners. What is special about this class is that it prevents feedback loops, when updating a target with a new value, and the ValueChanged event fires.This class also provides a couple of virtual methods, to provide the developer means of skipping calling SetValue for platform or view specific reasons:  ShouldSkipSetValueForViewSpecificReasons()  ShouldSkipSetValueForPlatformSpecificReasons()Both are called right before attempting to set the value.MvxPropertyInfoTargetBindingThis class is a subclass of MvxConvertingTargetBinding, which prepopulates the TargetType and automatically implements the SetValue() method, based on PropertyInfo. Using this is the shortest path to add a simple OneWay binding for a view, where you simply provide the instance of MvxPropertyInfoTargetBinding with the PropertyInfo of the target you want to bind, when you register the target binding.MvxWithEventPropertyInfoTargetBindingThis class is a subclass of MvxPropertyInfoTargetBinding, which is a shortcut to adding TwoWay bindings based on a specific event. Similarly to MvxPropertyInfoTargetBinding it uses the PropertyInfo to implement the SetValue() method. Additionally it implements the SubscribeToEvents() method, based on the assumption that there is an event which is called the same as the name of the property, postfixed with Changed. So if your property is called MyProperty it assumes that the corresponding event is called MyPropertChanged.MvxAndroidTargetBindingThis class is a subclass of MvxConvertingTargetBinding, which provides the current IMvxAndroidGlobals, to be able to get the current ApplicationContext for stuff like getting resources from the Android Resources and other operations which require the ApplicationContext.Getting InspirationTo get some inspiration on how to create your own target bindings, you can take a look at the ones that come out of the box with MvvmCross.You can find them in the Bindings code. There are a lot of target bindings you can look at for different kinds of behavior and requirements.",
            "url": "/documentation/fundamentals/custom-data-binding"
          }
          ,
        
          "documentation-fundamentals-customize-app" :{
            "title": "Customize app",
            "content": "In each deployed MvvmCross application there are two key classes which control how your app starts:  the App class in the core project - which provides the initialization for your core business logic and your viewmodels.  the Setup class in the native UI project - this Setup is a bootstrapper for the MvvmCross system and for your app.App.csTypically App.cs provides only initialization of:  simple rule-based IoC registration - e.g.:CreatableTypes().EndingWith(\"Service\").AsInterfaces().RegisterAsLazySingleton();  the ViewModelLocator - how ViewModels are found or created when Views are displayed  the IMvxAppStart - which ViewModel or ViewModels are shown when the application is first startedSetup.csInternally the Setup bootstrapper performs many steps.You can see most of them in the MvxSetup.cs class source which includes a sequence like this:// IoCInitializeIoC();// Core componentsInitializeFirstChance();InitializeDebugServices();InitializePlatformServices();InitializeSettings();InitializeSingletonCache();// Second componentsPerformBootstrapActions();InitializeStringToTypeParser();InitializeViewModelFramework();var pluginManager = InitializePluginFramework();InitializeApp(pluginManager);InitialiseViewModelTypeFinder();InitializeViewsContainer();InitiaiseViewDispatcher();InitializeViewLookup();InitialiseCommandCollectionBuilder();InitializeNavigationSerializer();InitializeInpcInterception();InitializeLastChance();Most of these steps are virtual - so they allow customization. Also most of these steps are implemented using virtual Create steps - which again should make customization easier:protected virtual void InitialiseFoo(){    var foo = CreateFoo();    Mvx.RegisterSingleton&lt;Foo&gt;();}protected virtual IFoo CreateFoo(){    return new Foo();}Added to these base class steps, each platform adds a small number of platform specific steps - eg Android adds some additional methods and properties for initialization of the Android UI and especially of the data-binding framework:string ExecutableNamespace {    get;}Assembly ExecutableAssembly {    get;}IMvxAndroidViewPresenter CreateViewPresenter()InitializeSavedStateConverter()InitialiseBindingBuilder()MvxAndroidBindingBuilder CreateBindingBuilder()RegisterBindingBuilderCallbacks()FillBindingNames(IMvxBindingNameRegistry registry)FillAxmlViewTypeResolver(IMvxAxmlNameViewTypeResolver viewTypeResolver)FillNamespaceListViewTypeResolver(IMvxNamespaceListViewTypeResolver viewTypeResolver)FillValueConverters(IMvxValueConverterRegistry registry)FillTargetFactories(IMvxTargetBindingFactoryRegistry registry)IList&lt;string&gt; ViewNamespaces {    get;}IDictionary&lt;string, string&gt; ViewNamespaceAbbreviations {    get;}List&lt;Assembly&gt; ValueConverterAssemblies {    get;}List&lt;Type&gt; ValueConverterHolders {    get;}IList&lt;Assembly&gt; AndroidViewAssemblies {    get;}This long list of virtual methods does provide a lot of opportunities for overriding default MvvmCross behaviour.However, most applications actually override only very few of these methods. Indeed, many applications only override only the one required method: IMvxApplication CreateApp()If you do want to override some of the Setup, then the rest of this document describes some of the methods and properties that you may find useful.Individual customizationsProviding application specific initializationThere are three key methods where application specific initialization might be added      App.Initialize - this is the place where all cross-platform app initialization should occur. In general it is the first choice for all app-specific initialization. Only use the Setup-based methods if you need platform-specific code injected        Setup.InitializeFirstChance - a “first blood” placeholder for any steps you want to take before any of the later steps happen        Setup.InitializeLastChance - a “last ditch” placeholder for any steps you want to take after all of earlier steps have happened.  Note that the iOS and Android base classes configure binding within this method so you must call base.InitializeLastChance if you implement this method.  In this section, we’ll only introduce some of the possibilities for creating and registering objects during initialize and setup. For a more in-depth introduction to MvvmCross IoC, see Service Location and Inversion of Control.Registering cross-platform business objects in App.InitializeIt’s very common for App.Initialize to include IoC registration. Indeed, the default nuget App.cs template includesCreatableTypes().EndingWith(\"Service\").AsInterfaces().RegisterAsLazySingleton();This logic says:  within the Assembly containing the App  find all creatable Types - meaning:  with public constuctors  not marked abstract  find the interfaces they implement  lazily register these types as singletons - meaning:  that no instance will be created until one is requested  that once the first instance has been created, then that same instance will be returned for all subsequent requestsMany other registration techniques are available - including registering objects from other assemblies, using instance-per-request registration and using individual rather than reflection-based registrations. For more on these, see Service Location and Inversion of Control.Registering platform-specific business objects in Setup.InitializeFirstChance and Setup.InitializeLastChanceThese two placeholders provide key places for you to create and register services which are specific to your platform.For example, if you wanted to implement an EncryptionService which would provide native data-encryption for your application, then you could do this during Setup.InitializeFirstChance using:        Mvx.RegisterType&lt;IEncryption, MyEncryption&gt;();This would then allow all of your App code - including code executed during App.Initialize() to use calls like:        var encryption = Mvx.Resolve&lt;IEncryption&gt;();        var safe = encryption.Encode(raw);Alternatively, if you wanted to implement a DialogService which would be used during normal UI flow, then you might choose to register this during Setup.InitializeLastChance as:        Mvx.RegisterSingleton&lt;IDialogService&gt;(new MyDialogService());For many objects the choice of when to initialize - first or last - doesn’t matter. For others, the key choice is whether the service needs to be available before or after the App is created and initialized.Changing trace/debug outputEach platform provides a virtual CreateDebugTrace methods which offers your application a chance to customise where Mvx.Trace messages are displayed.To provide a custom trace implementation:  first implement a class which provides IMvxTrace  override Setup.CreateDebugTrace() in order to return an instead of your new classOne common use of this is simply to display messages to Debug using:public class MyDebugTrace : IMvxTrace{    public void Trace(MvxTraceLevel level, string tag, Func&lt;string&gt; message)    {        Debug.WriteLine(tag + \":\" + level + \":\" + message());    }    public void Trace(MvxTraceLevel level, string tag, string message)    {        Debug.WriteLine(tag + \":\" + level + \":\" + message);    }    public void Trace(MvxTraceLevel level, string tag, string message, params object[] args)    {        try        {            Debug.WriteLine(string.Format(tag + \":\" + level + \":\" + message, args));        }        catch (FormatException)        {            Trace(MvxTraceLevel.Error, tag, \"Exception during trace of {0} {1} {2}\", level, message);        }    }}this can be returned during Setup using:protected override IMvxTrace CreateDebugTrace(){    return new MyDebugTrace();}Changing the IoC container that MvvmCross usesIoC is the first thing that MvvmCross setup starts.This is done within the method InitializeIoCTo override MvvmCross’ IoC, you can:  first find your alternative IoC implementation - e.g. something like AutoFac, Funq or TinyIoC  then create an Adapter which maps the implementation behind an IMvxIoCProvider interface and which inherits from MvxSingleton&lt;IMvxIoCProvider&gt; in order to provide a Singleton          the majority of the adaption should be relatively straight-forwards - see MvxSimpleIoCContainer for how the default IoC container is provided.      The only unusual methods in the MvvmCross IoC interface are the CallbackWhenRegistered hooks - these provide callbacks when new object types are registered and may require a little custom code in the RegisterXXX methods within your adapter.        finally, you can override IMvxIoCProvider CreateIocProvider() in your Setup class to return your IoC providerProviding additional View and ViewModel AssembliesThe default MvvmCross ViewModel Locator looks for:  Views in the Assembly containing Setup.cs  ViewModels in the Assembly containing App.csIf you wish to add additional View and ViewModel assemblies, then you can do this using overrides in Setup:protected override Assembly[] GetViewAssemblies(){    var list = new List&lt;Assembly&gt;();    list.AddRange(base.GetViewAssemblies());    list.Add(typeof(SomeTypeFromAdditionalViewAssembly1).Assembly);    list.Add(typeof(SomeTypeFromAdditionalViewAssembly2).Assembly);    list.Add(typeof(SomeTypeFromAdditionalViewAssembly3).Assembly);    // ...    return list.ToArray();}protected override Assembly[] GetViewModelAssemblies(){    var list = new List&lt;Assembly&gt;();    list.AddRange(base.GetViewModelAssemblies());    list.Add(typeof(SomeTypeFromAdditionalViewModelAssembly1).Assembly);    list.Add(typeof(SomeTypeFromAdditionalViewModelAssembly2).Assembly);    list.Add(typeof(SomeTypeFromAdditionalViewModelAssembly3).Assembly);    // ...    return list.ToArray();}Overriding ViewModel Location/ConstructionBy default, MvvmCross builds a new ViewModel every time one is requested and uses the CIRS sequence - Construction-Init-ReloadState-Start - to initialize that ViewModel.If you want to override this behaviour for one or more ViewModel types, then you can do this in your App object by supplying your own IMvxViewModelLocator implementation.For example, you could implementpublic class MyViewModelLocator    : MvxDefaultViewModelLocator{    private SpecialViewModel _special = new SpecialViewModel();    public override bool TryLoad(Type viewModelType, IDictionary&lt;string, string&gt; parameterValueLookup,                                 out IMvxViewModel model)    {        if (viewModelType == typeof(SpecialViewModel))        {            model = _special;            return true;        }        else if (viewModelType == typeof(FooViewModel))        {            model = new FooViewModel(_special);            return true;        }        return base.TryLoad(viewModelType, parameterValueLookup, out model);    }}and could then return this in App.cs:protected override IMvxViewModelLocator CreateDefaultViewModelLocator(){    return new MyViewModelLocator();}Custom IMvxAppStartWhen an MvvmCross application starts by default it shows the View associated with a single ViewModel type.This default behaviour is configured in Initialize in App.cs using:RegisterAppStart&lt;FirstViewModel&gt;();If more advanced startup logic is needed, then a custom app start can be used - e.g.public class CustomAppStart    : MvxNavigatingObject    , IMvxAppStart{    public void Start(object hint = null)    {        var auth = Mvx.Resolve&lt;IAuth&gt;();        if (auth.Check())        {            ShowViewModel&lt;HomeViewModel&gt;();        }        else        {            ShowViewModel&lt;LoginViewModel&gt;();        }    }}This can then be registered in App using:RegisterAppStart(new CustomAppStart());Alternatively if your custom IMvxAppStart class requires any IoC dependencies, like the IMvxNavigationService, you can register your class using:RegisterCustomAppStart&lt;CustomAppStart&gt;();Note: For situations where the app is launched using a protocol - e.g. from a Push notification or from an email link - then the object hint parameter start can be used to transfer a hint from the UI to the start object. Currently, it’s up to you - the app developer - to write the UI side code to do this.Custom PresentersFor ‘my first MvvmCross application’ most people start with a ‘full page’ app in which each ShowViewModel causes a new View to be displayed, filling an entire screen at a time.There are many other possibilities for ViewModel-&gt;ViewModel navigation, including:  tabbed displays  dialogs and flyouts  ‘hamburger menus’  splitviews, master-detail displays, screen ‘regions’ and other screen division/fragmentationTo provide these alternative UI possibilities, MvvmCross allows each app to provide a custom presenter.For more on custom presenters, see several articles and videos linked from: http://slodge.blogspot.co.uk/2013/06/presenter-roundup.htmlProviding ValueConvertersFor the platforms that use MvvmCross’ databinding platform, then ValueConverters:  are classes which implement IMvxValueConverter  are registered by name with a singleton IMvxValueConverterRegistryThere are several ways that individual ValueConverters can be registered. The most common are all in Setup.cs:  registering all value converters inside an assembly. To do this: override ValueConverterAssemblies:  registering value converters using a wrapper Converters class  registering value converters one at a timeThese three techniques are shown as:// 1. register all value converters in the Assembly containing `MyFirstValueConverter`protected override List&lt;Assembly&gt; ValueConverterAssemblies{    get    {        var toReturn = base.ValueConverterAssemblies;        toReturn.Add(typeof(MyFirstValueConverter).Assembly);        return toReturn;    }}// 2. register all value converters in the wrapper Converterspublic class Converters{    // this converter will be registered with name \"TheLength\"    public readonly LengthValueConverter TheLength = new LengthValueConverter();}protected override protected List&lt;Type&gt; ValueConverterHolders{    get    {        var toReturn = base.ValueConverterHolders;        toReturn.Add(typeof(Converters);                     return toReturn;    }}// 3. register value converters one at a timeprotected override void FillValueConverters(IMvxValueConverterRegistry registry){    base.FillValueConverters(registry);    registry.AddOrOverwrite(\"Foo\", new SquareValueConverter());}Notes:  When using the Assembly based method then the registered name uses the rules:  remove any Mvx prefix  remove any ValueConverter or Converter suffix  because of this a value converter in a class MvxBeerValueConverter will be registered under the name Beer  When using any of the registration mechanisms then the value converters are always ultimately added using a call to registry.AddOrOverwrite - so in the case of a name clash, then the last added value converter always wins.One final technique used for registering value converters is used by some of the plugins to enable them to register value converters independently of the main setup flow.This technique involves using the CallbackWhenRegistered IoC method on the IMvxValueConverterRegistry interface. This is used, for example, in the Visibility plugin as:Mvx.CallbackWhenRegistered&lt;IMvxValueConverterRegistry&gt;(RegisterValueConverters);// ...private void RegisterValueConverters(){    var registry = Mvx.Resolve&lt;IMvxValueConverterRegistry&gt;();    registry.AddOrOverwriteFrom(GetType().Assembly);}For more on creating ValueConverters, see the ValueConverter sample in: https://github.com/slodge/MvvmCross-Tutorials/tree/master/ValueConversionProviding Custom Views (Android)In Android, MvvmCross overrides the default Android xml inflation and instead provides its own mechanism.In order to do this, you must supply the MvvmCross binding system with a list of Assembly’s in which it should look for Android View objects (note that these are Android View objects and have nothing to do with Mvvm Views at this point).To do this, you can override the Setup property AndroidViewAssemblies:protected override IList&lt;Assembly&gt; AndroidViewAssemblies {    get {        return new List&lt;Assembly&gt;(base.AndroidViewAssemblies) {            typeof (CheeseBaron.ExcellentViews.Pages).Assembly,                   typeof (AnyAdditionalViewType).Assembly        };    }}Or as an expression body property in C# 6:protected override IList&lt;Assembly&gt; AndroidViewAssemblies =&gt; new List&lt;Assembly&gt;(base.AndroidViewAssemblies) {    typeof (CheeseBaron.ExcellentViews.Pages).Assembly,           typeof (AnyAdditionalViewType).Assembly};For more on writing Custom Views, see the N=18 and N=19 steps in N+1 - todo-linkRegistering Default Binding NamesIn iOS Fluent Bindings you frequently see code like:set.Bind(myLabel).To(vm =&gt; vm.FullName);This code uses a developer shortcut - the default binding property of a UILabel. This is just a shortcut and it means the binding is actually performed as:set.Bind(myLabel).For(label =&gt; label.Text).To(vm =&gt; vm.FullName);At present the defined set of default properties or events includes:        UIButton TouchUpInside        UIBarButtonItem Clicked        UITextField Text        UITextView Text        UITextField Text        MvxCollectionViewSource ItemsSource        MvxTableViewSource ItemsSource        MvxImageView ImageUrl        UIImageView\tImage        UIDatePicker Date        UISlider Value        UISwitch On        UIDatePicker Date        IMvxImageHelper ImageUrl        MvxImageViewLoader ImageUrlIf you would like register additional shortcuts in your application, or if you’d like to replace some of the existing shortcuts, then this can be done in FillBindingNamesprotected override void FillBindingNames(IMvxBindingNameRegistry registry){    registry.AddOrOverwrite(typeof (MyControl), \"MyDefaultPropertyOrEvent\");}Registering custom bindingsMvvmCross binding works by default against Android and iOS UI objects by trying to use Reflection on properties and events.This generally works really well, especially for cases where properties and events are linked using the convention that the property called Foo is associated with the change event FooChangedFor situations where this default binding doesn’t work, custom bindings can be written and these can be registered using an override of the FillTargetFactories method in the Android and iOS Setup classes.For more on this, see the N+1 video on custom binding - N=28.Overriding View-ViewModel associationsBy default, MvvmCross discovers the ViewModel that a View is associated with using the type of ViewModel discovered by name conventionThis makes prototyping initial application generally very functionality straight-forward.However, as applications grow in size and complexity, then sometimes developers like to override this lookup behaviour.To do this they can instead:  provide a concrete type of the ViewModel where one is specified - e.g. as:public new DetailViewModel ViewModel{    get {        return base.ViewModel as DetailViewModel;    }    set {        base.ViewModel = value;    }}  or provide an explicit type of the ViewModel specified using an MvxViewForAttributeFurther, in cases where every microsecond of startup time is essential, they can also help reduce the Reflection overhead by overriding the InitializeViewLookup method - e.g.protected override void InitializeViewLookup(){    var viewModelViewLookup = new Dictionary&lt;Type, Type&gt;()    {        { typeof (FirstViewModel), typeof(FirstView) },        { typeof (SecondViewModel), typeof(SecondView) },        //        { typeof (UmpteenthViewModel), typeof(UmpteenthView) },    };    var container = Mvx.Resolve&lt;IMvxViewsContainer&gt;();    container.AddAll(viewModelViewLookup);}",
            "url": "/documentation/fundamentals/customize-app"
          }
          ,
        
          "documentation-fundamentals-data-binding" :{
            "title": "Data binding",
            "content": "Data binding is the key technology that MVVM relies on, to link Views with their View-Models.Data binding provides and maintains the automated Two-Way connection between View and ViewModel. A good understanding of data binding is essential for every MVVM developer.Within MvvmCross, data binding was initially built to mirror the structure provided by Microsoft in their XAML based frameworks, but in more recent developments MvvmCross has extended data binding in new directions.This article focuses first on the core ‘Windows’ data binding approach, but then later extends to some of the newer ideas.Core Windows Data bindingIn this structure, for each binding:  C# properties are used in both View and ViewModel  A single View property is ‘bound’ - connected - to a ViewModel property  is specified with a Mode which gives a direction for data flow (One-Way, Two-Way, etc.)  can optionally be specified with a ValueConverter - and this can optionally also be parameterised  can also optionally be specified with a FallbackValue for when binding fails.C# properties and Data bindingC# properties are used for data binding on both the View and the ViewModel.On the ViewModel, these properties often look like:private string _myProperty;public string MyProperty{    get =&gt; _myProperty;    set    {        _myProperty = value;        RaisePropertyChanged(() =&gt; MyProperty);        // take any additional actions here which are required when MyProperty is updated    }}  Note: MvvmCross provides helper methods to assign the backing field and fire the PropertyChanged event, after checking whether value actually changed. Consider using SetProperty() for this, which is present on MvxViewModel and MvxPropertyChanged.This pattern uses a local private backing variable to store the current value, and relies on RaisePropertyChanged to signal changes in the value to any listening Views.In the View:  on Windows platforms, DependencyProperty objects are used to store variable values. These DependencyProperty objects provide well-known mechanisms:          to allow both get and set of the value within the View.      to listen for changes on the value within the View - e.g. when the user enters new text into a TextBox        in new C# platforms like Xamarin.Android and Xamarin.iOS:          most commonly                  normal C# properties are used to get and set variable values - typically these C# properties are wrapper properties that Xamarin has created around native Java or Objective-C methods          normal C# events are used to determine when these variable values have changed - e.g. when a user has entered a value.                    sometimes - when there isn’t a neat property and event based mapping available                  custom C# methods have to be used to get and set the variable values          custom Java listeners or Objective-C delegates have to be used to detect when the UI View state changes (e.g. when the user enters text or taps on a button).                    For more info on the details on implementing custom bindings, see the custom bindings blog post by Stuart LodgeDataBound propertiesUsing the View and ViewModel properties described above, it is common for a ViewModel C# property to be used to model the value of a View property.For example:  if your View contained a CheckBox which has an IsChecked property  then your ViewModel might contain a property:private bool _rememberMe;public bool RememberMe{    get =&gt; _rememberMe;    set =&gt; SetProperty(ref _rememberMe, value);}  then a binding might connect together IsChecked on the View with RememberMe in the ViewModel.DataBound events and actionsData binding also enables a ViewModel to react to ‘events’ which occur in a View - e.g. for a ViewModel to respond to events such as a button being pressed.The technique generally used for this is for the ViewModel to expose special Command properties which can be bound to corresponding Command properties on the View.For example, a CheckBox might have a CheckedCommand and this might be bindable to a RememberMeChangedCommand on the ViewModel.Within Windows, For sometimes, when a View has not exposedBinding ModesThere are 4 modes in which properties in the View can be bound to properties in the ViewModel:  One-Way  One-Way-To-Source  Two-Way  One-TimeOne-Way  This binding mode transfers values from the ViewModel to the View  whenever the property changes within the ViewModel, then the corresponding View property is automatically adjusted.  This binding mode is useful when when showing, for example, data which is arriving from a dynamic source - like from a sensor or from a network data feed.  In Windows/Xaml, this is very often the default binding mode - so it is the mode used when no other is selected.One-Way-To-Source  This binding mode transfers values from the View to the ViewModel  When the View property changes then the corresponding ViewModel will be updated.  This binding mode is useful when collecting new data from a user - e.g. when a user fills in a blank form.  In practice, this binding mode is rarely used - most developers choose to use Two-Way instead.Two-Way  This binding mode transfers values in both directions  Changes in both View and ViewModel properties are monitored - if either changes, then the other will be updated.  This binding mode is useful when editing entries an existing form, and is very commonly used by developers.  Where MvvmCross had created new bindings, then this is very often the default binding mode MvvmCross tries to use.One-Time  This binding mode transfers values from ViewModel to View  This transfer doesn’t actively monitor change messages/events from the ViewModel  instead this binding mode tries to transfer data from ViewModel to View only when the binding source is set. After this, the binding doesn’t monitor changes and doesn’t perform any updates, unless the binding source itself is reset.  This mode is not very commonly used, but can be useful for fields which are configurable but which don’t tend to change after they have initially been set.  In MvvmCross, we use One-Time binding when setting static text from language files - this is because it’s common for the user to select a language, but once chosen, it’s uncommon for the user to then change that language.Value ConversionA ValueConverter is a class which implements the IValueConverter interface.This interface provides two object level conversion methods:  Convert - providing a simple mechanism for changing values from ViewModel to View  ConvertBack - providing a simple mechanism for changing values back from View to ViewModelIt is very common for a ValueConverter to only be used for converting values for display in the View. In this case, only the Convert method is implemented.Because the IValueConverter interface is not exactly the same across all platforms, MvvmCross instead provides IMvxValueConverter interface which can be mapped to IValueConverter on each platform.Further, MvvmCross provides some supporting base classes to help with writing value converters:  MvxValueConverter  MvxValueConverter&lt;TFrom&gt;  MvxValueConverter&lt;TFrom, TTo&gt;As an example, a LengthValueConverter which is only used to help display the length of a string - with no ConvertBack use - might be implemented:public class LengthValueConverter    : MvxValueConverter&lt;string, int&gt;{    protected override int Converter(string value, Type targetType, object parameter, CultureInfo cultureInfo)    {        if (value == null)            return 0;        return value.Length;    }}ValueConverters can also be provided with a parameter - this can sometimes be useful to reuse a single value converter in different situations. For example, a TrimValueConverter might be able to take the characters to trim in its parameter.Fallback ValuesSometimes the ViewModel source property for the ViewModel isn’t available.For example:  suppose you bind a label’s Text to Customer.FirstName on the ViewModel  and that you specify a FallbackValue='no customer'  if Customer is null at any point, then Customer.FirstName will be treated as UnsetValue - and so the fallback ‘no customer’ will be displayed.Notes:  in this example, if Customer is an object which has a null FirstName then this will not cause the Fallback to be used. The Fallback is there only for cases where the value is Unset - where the binding engine cannot find a value. A null value is still a value - so it doesn’t trigger the Fallback.  one situation which can trigger an UnsetValue is if an Exception is thrown - e.g. during the evaluation of a ValueConverter. In this case, the binding engine will treat this Exception as an UnsetValue and so the FallbackValue will be used.A note about DataContextWhile we have used the terms View and ViewModel throughout this article, you will also see DataContext used in this article and in code.DataContext is simply the C# name for the property on a View to which the ViewModel is assigned.ViewModel and DataContext can be considered as the same thing.MvvmCross Data bindingData binding has always been at the heart of MvvmCross, and the functionality has grown over the different versions of MvvmCross.The evolution of MvvmCross data binding can be trace over a path of:  JSON  Swiss  Fluent  Tibet, Rio and the future!JSONIn the first versions of MvvmCross the data binding framework used strings based on JSON to achieve data binding.This JSON version is now retired - it is no longer easily available in MvvmCross v3. If you come across any samples or documents which use JSON binding, then be aware that these samples are now out of date.SwissThe replacement for JSON data binding was called ‘Swiss’. It provides the same functionality as the JSON binding, but used a cleaner, less verbose syntax that is easier to use.For example:  a binding in JSON which was written:{    'Text':    {        'Path':'TweetText',        'Converter':'RemainingLength',        'ConverterParameter':140    }}  could be rewritten in Swiss using:Text TweetText,    Converter=RemainingLength,    ConverterParameter=140FluentIn addition to providing text-format binding statement which can be easily included in xml layout files, MvvmCross also provides a C# based syntax to enable bindings to be easily constructed using code.This binding syntax is referred to as ‘Fluent’ bindings.As an example:  the text binding:Text TweetText,    Converter=RemainingLength,    ConverterParameter=140  might be rewritten using fluent bindings as:this.CreatingBinding(label)    .For(l =&gt; l.Text)    .To(vm =&gt; vm.TweetText)    .WithConversion(\"RemainingLength\", 140);Fluent binding is especially useful in the iOS and OSX platforms where the Xml layout formats are not easily human-editable.Tibet, Rio and the futureAs the MvvmCross binding format evolved from its JSON origins through to Swiss and Fluent, the improvements were largely cosmetic. These cosmetic changes offered improved developer productivity through easier-to-use binding syntax, and did so without offering any changes in functionality in the underlying data-binding itself.The future of MvvmCross continues to aim to include cosmetic improvements, but also aims to deliver functional enhancements as well.The current ideas for improvements and enhancements include:  Tibet binding          multi-binding      ValueCombiners      literal-binding      binding macros      functional syntax for ValueConverters and ValueCombiners      nested value conversion        Rio binding  Auto-Command bindingUsing these ideas, then a binding like:      Text TweetText,          Converter=RemainingLength,         ConverterParameter=140might be rewritten:  Text RemainingLength(TweetText,140)or perhaps even:  Text 140 - Length(TweetText)These ideas and their current development status are discussed further later in this article.Beyond these, of course, the opportunity is there for plenty more ideas and improvements from the community - the evolution of MvvmCross and its data binding is driven by real users and the invention and ideas their real apps require.JSONAs discussed above, JSON binding is not supported within MvvmCross v3 or later.SwissSwiss binding syntax allows a basic binding from a View $Target$ to a ViewModel property $SourcePath$ to be written using a syntax: $Target$ $SourcePath$where $Target$ must always be the direct path to the View property - e.g.:  Text  IsChecked  Value  …$SourcePath$ can be any C# style path to the property on the ViewModel or on a sub-object exposed using a property - e.g.:  UserId  RememberMe  Password  Customer.FirstName  Customer.Address.City  Customer.Orders[0].Date  Customer.Orders[0].Total  Customer.Cards[“Primary”].Expiry  Customer.Cards[“Primary”].Number  …Beyond this basic $TargetPath$ to $SourcePath$ syntax:      If $SourcePath$ is omitted or a single period “.” is used, then the Source used is the whole of the ViewModel.        If a converter is needed, then this can be added using:  , Converter=$ConverterName$where $ConverterName$ is the name of the Value Converter to use - which typically is the class name without it’s ValueConverter postfix - e.g. the name “Length” would be used for the class LengthValueConverter  If a ConverterParameter is needed then this can be added using:, ConverterParameter=$ParameterValue$where $ParameterValue$ is one of:  a quotation or double-quotation delimited string  the word ‘null’ meaning C# null.  the word ‘true’ or ‘false’ providing a bool value  an integer number - which will be parsed as a long      a floating point number - which will be parsed as a double    If a FallbackValue is needed then this can be added using:, FallbackValue=$FallbackValue$where $FallbackValue$ has the same permitted contents as $ParameterValue$ above, but can also additionally be:  the ToString() representation of an Enum value.This is especially useful in, for example, the binding of Visibility properties.  If a specific Binding Mode is needed, then this can be added:, Mode=$WhichMode$where $WhichMode$ is one of:  OneWay  OneWayToSource  TwoWay  OneTime      Default        Where multiple bindings are needed, these can be separated using a semi-colon    One very specific extension to ‘Swiss’ binding is the CommandParameter binding, this binding uses an implicit ValueConverter to specify the parameter for an ICommand invocation. This is specified using:, CommandParameter=$CPValue$where $CPValue$ is a literal value similar to $ParameterValue$ aboveSome examples of Swiss binding statements are:Text Customer.FirstNameBind the Text property to Customer.FirstName on the ViewModel.Text Title, Converter=LengthBind the Text property to Title on the ViewModel, but apply the Length value converter - which will normally be a default instance of the class LengthValueConverter.Text Order.Amount, Converter=Trim, ConverterParameter='£'Bind the Text property to Order.Amount on the ViewModel, but apply the Trim value converter, passing it the string “£”.Text Order.Amount, Converter=Trim, ConverterParameter='£', FallbackValue='N/A'Bind the Text property to Order.Amount on the ViewModel, but apply the Trim value converter, passing it the string “£”. If no Order is available, or if the Order object doesn’t have an Amount value, then display “N/A”Value Count, Mode=TwoWayBind the Value property to Count on the ViewModel, and ensure this binding is both from View to ViewModel and from ViewModel to View.Click DayCommand, CommandParameter='Thursday'Bind the Click event to the DayCommand property on the ViewModel (which should implement ICommand). When invoked, ensure that Execute is passeda parameter value of “Thursday”FluentThe fluent syntax provides a C# way to create bindings.This syntax is generally done using the CreateBindingSet&lt;TView, TViewModel&gt; helper.The syntax includes:Bind($ViewObject$) where $ViewObject$ is the view target for binding.For(v =&gt; v.$ViewProperty$) where $ViewProperty$ is the property on the view for binding.  If For is not provided, then the default view property is used. [Look at the tables at the bottom of this page][#default-view-properties] to see all the default bindings used for each platforms control type.To(vm =&gt; vm.$ViewModelPath$)where $ViewModelPath$ is the path to the view model ‘source’  property for binding.OneWay()TwoWay()OneWayToSource()OneTime()all of which provide the mode for the bindingWithConversion($name$, $parameter$)where $name$ is the name of the value converter to use, and $parameter$ is the parameter to pass in.Using this syntax, an example binding set is:var set = this.CreateBindingSet&lt;MyView, MyViewModel&gt;();set.Bind(nameLabel)    .For(v =&gt; v.Text)    .To(vm =&gt; vm.Customer.FirstName);set.Bind(creditLabel)    .For(v =&gt; v.Text)    .To(vm =&gt; vm.Customer.Total)    .WithConversion(\"CurrencyFormat\", \"$\");set.Bind(cardLabel)    .For(v =&gt; v.Text)    .To(vm =&gt; vm.Customer.Cards[\"Primary\"].Number)    .WithConversion(\"LastFour\")    .OneWay()    .FallbackValue(\"N/A\");set.Bind(warningView)    .For(v =&gt; v.Hidden)    .To(vm =&gt; vm.Customer.Alert)    .WithConversion(\"Not\")    .FallbackValue(true);set.Apply();Note: when using a fluent binding, always remember to use .Apply() - if this is missed then the binding won’t ever be created.MvvmCross Defined Custom bindingsIn addition to the Expression based Fluent bindings, String and Extension Method based Fluent bindings are also available. They are particularly useful for situations where bindings are needed to View events or to binding targets which are not fully exposed as C# properties. For example, even though a UIButton does not have a Title property in C#, a Title property can still be set via the use of custom bindings:set.Bind(okButton)    .For(\"Title\")    .To(vm =&gt; vm.Caption);set.Bind(okButton)    .For(c =&gt; c.BindText())    .To(vm =&gt; vm.Caption);TibetTibet binding includes several ideas which extend Swiss binding.Tibet has been carefully designed so that it is backwards compatible - any existing Swiss bindings should work within Tibet.The core parts of Tibet are:  multi-binding  value combiners  literal-binding  binding macros  functional syntax for ValueConverters and ValueCombiners  nested value conversionMulti-bindingIn Swiss binding, each binding can only reference a single ViewModel property path.This meant that if a ViewModel had 2 properties like FirstName and LastName, then the main way to create a display of the ful name was to create a new ViewModel property - e.g.:private string _firstName;public string FirstName{    get =&gt; _firstName;    set     {         if (SetProperty(ref _firstName, value))            RaisePropertyChanged(() =&gt; FullName);    }}private string _lastName;public string LastName{    get =&gt; _lastName;    set     {         if (SetProperty(ref _lastName, value))            RaisePropertyChanged(() =&gt; FullName);    }}public string FullName =&gt; _firstName + \" \" + _lastName;With Multi-Binding, the addition of the FullName property is no longer necessary - instead the binding can be written inside the binding expression directly as:Text FirstName + ' ' + LastNameThis multi-binding will cause Text to automatically be updated whenever either of FirstName or LastName change.ValueCombinersA ValueCombiner is a new technique provided by Tibet binding in order to merge multiple sources into a single value.For example, the multi-binding example above used two Add value combiners in order to link together three inputs:  FirstName  ’ ‘  LastNameThere are a small number of ValueCombiners provided within Tibet, including:  If(test, if_true, if_false) - takes 3 inputs:          a boolean test value      an if_true value which is used if the test value is true      an if_false value which is used otherwise        Format(format, args...) - takes 1 or more inputs          a string value which evaluates to a format string template      0 or more args which will be evaluated in the string template        Add(one,two) - takes 2 arguments which it ‘combines’ together. For two strings, this means concatenation. For two doubles or two longs it means numeric addition. For mixtures of those items, the result is currently not fully specified.  GreaterThan(one, two) - takes 2 arguments and attempts to apply greater than logic to them. As with Add this logic is straight-forward for two strings, two doubles or two longs, but is not well-defined for other object combinations.Notes:  some ValueCombiners are also available in operator form - e.g. Add can be used as + and GreaterThan can be used as &gt;  combination is an interpretation, not a compilation step - especially because dynamic code generation is not supported on all MvvmCross platforms.  for direct comparison/combination of simple string, long and double values, this ‘interpretation’ should work well. Using combiners for more complicated combinations is less well defined.  currently ValueCombiners typically try to use long rather than int and double rather than float.Important note: The current interface of value combiners is currently a proposal and working prototype only. As we learn more about the real use, benefits and challenges of value combination we may revise the API, including making breaking changes to any value combiners produced by the community. In particular, it’s possible we may make changes to the type safety of the APIs, and we may try to reduce the complexity of the APIs - as Value Combiners are currently quite ‘open’ in the source/target types they accept and this makes developing them quite complicated.Literal bindingAs we’ve seen in the previous Multi-Binding and Value-Combining steps, literals can now be included in Tibet binding expressions.For example, a binding:Value 100 * Ratiouses the literal 100 to provide a way of translating a Ratio into a Percentage.Or a binding:Value 'True'uses a literal string which is automatically converted to a boolean if Value is a boolean property.Or a binding:Value Format('Hello {1} - today is {0:ddd MMM yyyy}', TheDate, Name)uses a literal string to assist formating TheDate and NameBinding macrosBinding macros are not yet implemented.Ideas being considered in this area include:  access to parent, global and named(name) binding contexts  access to shared variables - e.g, shared numbers, strings and Colors which could provide more theming/styling options  access to i18n resources to make text localization more straight-forwardIt is likely that that prefix characters, such as $, # or @, might be used as simple markers to enable the identification of these ‘macros’Functional syntax for ValueConverters and ValueCombinersThis change allows shorter simpler binding expressions to be used.This means that a Swiss binding of:Text TweetText,     Converter=RemainingLength,    ConverterParameter=140can be rewritten in Tibet as:Text RemainingLength(TweetText, 140)Note that the function name space is shared between the Value Combiners and the Value Converters. When looking for a name, MvvmCross first looks for a matching ValueCombiner, and then second for a matching ValueConverter.Nested value conversionIn addition to supporting multiple bound source values, Tibet binding further introduces nested evaluation of value converters and combiners.For example, Length and Trim value converters could be applied with the Add value combiner as:Text Length(Trim(FirstName + ' ' + LastName))A Mild WarningTibet binding provides developers with many options for more advanced bindings.This advancement is, of course, not free - it does come with a small memory and processing cost during both the construction and the execution of the bindings.In general, this additional overhead is very small and so should not be of concern to developers. However, it’s always important to be aware of your application’s performance - so always consider how a binding will be constructed and evaluated, especially when applying large numbers of bindings, when applying bindings within loops (collections) or when applying bindings to data which changes very frequently. Always consider applying source (ViewModel-based) data manipulation, writing a single optimized combiner/converter or consider simple OneTime binding as potential ways to avoid performance issues.RioWithin ViewModels, Mvvm in C# has always been centred around the INotifyPropertyChanged interface.This interface is typically implemented around C# properties which look like:private string _lastName;public string LastName{    get =&gt; _lastName;    set =&gt; SetProperty(ref _lastName, value);}and this is further enhanced using ICommand properties for action callbacks - e.g.private ICommand _submitCommand;public ICommand SubmitCommand{    get    {        _submitCommand = _submitCommand ?? new MvxCommand(DoSubmit);        return _submitCommand;    }}This syntax is well understood by experienced Mvvm developers, but can also appear quite verbose when dealing with very small view models.Some developers have worked around this verbosity by using techniques such as post-compilation injection of code - e.g. using the AOP Property plugin from Fody.Rio binding offers developers a different approach - using the new FieldBinding and MethodBinding plugins.FieldBindingWith the field binding plugin, MvvmCross data binding can use ViewModel public fields as data-sources for binding - e.g.public string LastName;Further, to provide events to drive UI updates, a lightweight INotifyChanged interface has been added, along with abbreviated helper interfaces and classes - INC&lt;T&gt; and NC&lt;T&gt;. These can be used as:public readonly INC&lt;string&gt; LastName = new NC&lt;string&gt;();A LastName declared in this way can be databound exactly as te earlier INotifyPropertyChanged-based property:Text LastNameFurther, the underlying string field can be accessed in code using:LastName.Value = \"Hello\";Mvx.Trace(\"Current value is {0}\", LastName.Value);To use FieldBinding, import the Field binding plugin into both your core and your UI projects.Notes:  In addition to the syntactic changes of Rio, there are also some slight performance improvements - achieved by avoiding some Reflection-based get/set and by avoiding string-based event notifications.  INotifyChanged binding has no way to support the INotifyPropertyChanged feature ‘all changed’ which is achieved by signalling a property change with a null or empty property name.  INotifyChanged itself is a very simple interface - so you can easily implement your own classes to implement this if you require extensions.MethodBindingWith the method binding plugin, MvvmCross data binding can use ViewModel public methods as sources for ICommand without declaring an ICommand property.For example, a methodpublic void GoHome(){    ShowViewModel&lt;HomeViewModel&gt;();}can be used in binding as:Click GoHome Where a single argument is available within the source method, Method Binding uses the command parameter for this call. This is useful in, for example, list item selection events - e.g.:public void ShowDetail(ListItem item){    ShowViewModel&lt;DetailViewModel&gt;(new { id = item.Id} );}bound with:    ItemClick ShowDetail To use MethodBinding, import the Method binding plugin into just your UI projects - there is no ‘core’ component required for these plugins.Note: One important feature sometimes used in Windows Xaml binding but poorly supported by MvvmCross is the CanExecute/CanExecuteChanged functionality on ICommand. In Xaml binding this property and event pair can be used to enable/disable UI controls such as buttons.However, in MvvmCross, this auto-enable/disable binding isn’t currently widely supported - with support instead being given to secondary binding properties - e.g. to pairs of bindings like:    Click GoHome; IsEnabled CanGoHomeThe Rio EffectA view model built using Rio will not be to every developer’s liking.However, the effect on the code-size and readability can be striking.A Rio INotifyChanged ViewModel like:public class MathsViewModel{    public readonly INC&lt;double&gt; SubTotal = new NC&lt;double&gt;();    public readonly INC&lt;double&gt; Percent = new NC&lt;double&gt;();    public void Calculate()    {        Total.Value = SubTotal.Value * Percent.Value;    }    public readonly INC&lt;double&gt; Total = new NC&lt;double&gt;();}is equivalent to a INotifyPropertyChanged ViewModel of:public class MathsViewModel{    private double _subTotal;    public double SubTotal    {        get =&gt; _subTotal;        set =&gt; SetProperty(ref _subTotal, value);    }     private double _percent;    public double Percent    {        get =&gt; _percent;        set =&gt; SetProperty(ref _percent, value);    }    private ICommand _calculateCommand;    public ICommand CalculateCommand;    {        get         {            _calculateCommand = _calculateCommand ?? new MvxCommand(Calculate);            return _calculateCommand;        }    }    private void Calculate()    {        Total = SubTotal * Percent;    }                private double _total;    public double Total    {        get =&gt; _total;        set =&gt; SetProperty(ref _total, value);    }}BindingEx - Tibet and Rio in XamlXaml is a platform and product from Microsoft which offers excellent tooling, lots of extensibility for adding new controls, but only limited extensibility for adding customization.Unfortunately, this means MvvmCross can’t intercept the ‘normal’ Xaml binding syntax which might look like:Text=\"{Binding FirstName}\"However, MvvmCross Swiss, Tibet and Rio binding can be enabled through AttachedPropertiesIn particular two AttachedProperties is supplied in the BindingEx package:  mvx:Bi.nd - for bindings  mvx:La.ng - for internationalization extensionsTo add these properties to your Windows Uwp or WPF MvvmCross app:  include the MvvmCross.Binding package  include an additional step in Setup which initializes the WindowsBinding frameworkprotected override void InitializeLastChance(){    base.InitializeLastChance();        var builder = new MvxWindowsBindingBuilder();    builder.DoRegistration();        }      in your Xaml files include an xml attribute for mvx - this will be different according to the platform:        Uwp    xmlns:mvx=”using:mvx”        WPF    xmlns:mvx=”clr-namespace:mvx;assembly=MvvmCross.Binding.Wpf”        in your Xaml files you can now include bindings within tags such as:    &lt;TextBlock mvx:Bi.nd=\"Text Customer.FirstName; Visible=ShowFirstName\" /&gt;        for design-time support, you may also need to pull in additional value converters into the Xaml namespace. For more on this, see http://slodge.blogspot.co.uk/2013/07/n35-multibinding-with-tibet-n1-videos.html  Once installed, the syntax within these AttachedProperties bindings is exactly the same as within all other Swiss and Tibet binding - and this binding functionality can be extended with custom bindings, with FieldBinding, etc - just as in MvvmCross on non-Xaml platforms.Beyond RioThe framework that enables the Rio and Tibet binding extensions is interface-based and is built upon the small CrossCore platform which underpins MvvmCross.We’re excited by the possibilities that this framework can provide - by the inventions that the community can now develop.Anyone wishing to experiment with creating their own source binding plugins is encouraged to get started by looking at the source code for the MethodBinding and FieldBinding plugins.Generic and typed bindingsThis change will add a generic “WithConversion” method. This will allow developers to strongly type the use of value converters, making refactoring a lot easier and more save. For example:set.Bind(textField).To(vm =&gt; vm.Counter).WithConversion&lt;SomeValueConverter&gt;();Add something about the Generic implementation of IMvxTargetBinding #1610Default view propertiesThe tables in this section describe the default view properties used in a Fluent binding when the For method chain is not provided.Android            Base Control      Default                  Android.Widget.Button      Click              Android.Widget.CheckBox      Checked              Android.Widget.TextView      Text              Android.Widget.CompoundButton      Checked              Android.Widget.SeekBar      Progress              Android.Widget.SearchView      Query              MvvmCross.Binding.Droid.Views.MvxListView      ItemsSource              MvvmCross.Binding.Droid.Views.MvxLinearLayout      ItemsSource              MvvmCross.Binding.Droid.Views.MvxGridView      ItemsSource              MvvmCross.Binding.Droid.Views.MvxRelativeLayout      ItemsSource              MvvmCross.Binding.Droid.Views.MvxFrameLayout      ItemsSource              MvvmCross.Binding.Droid.Views.MvxTableLayout      ItemsSource              MvvmCross.Binding.Droid.Views.MvxFrameControl      DataContext              MvvmCross.Binding.Droid.Views.MvxImageView      ImageUrl              MvvmCross.Binding.Droid.Views.MvxDatePicker      Value              MvvmCross.Binding.Droid.Views.MvxTimePicker      Value      iOS            Base Control      Default                  UIKit.UIButton      TouchUpInside              UIKit.UIBarButtonItem      Clicked              UIKit.UISearchBar      Text              UIKit.UITextField      Text              UIKit.UITextView      Text              UIKit.UILabel      Text              UIKit.UIImageView      Image              UIKit.UIDatePicker      Date              UIKit.UISlider      Value              UIKit.UISwitch      On              UIKit.UIProgressView      Progress              UIKit.UISegmentedControl      SelectedSegment              UIKit.UIPageControl      CurrentPage              UIKit.UIActivityIndicatorView      Hidden              MvvmCross.Binding.iOS.Views.MvxCollectionViewSource      ItemsSource              MvvmCross.Binding.iOS.Views.MvxTableViewSource      ItemsSource              MvvmCross.Binding.iOS.Views.MvxImageView      ImageUrl              MvvmCross.Binding.iOS.Views.MvxImageViewLoader      ImageUrl      Mac            Base Control      Default                  AppKit.NSButton      Activated              AppKit.NSButtonCell      Activated              AppKit.NSSegmentedControl      SelectedSegment              AppKit.NSSearchField      Text              AppKit.NSTextField      StringValue              AppKit.NSTextView      StringValue              AppKit.NSImageView      Image              AppKit.NSDatePicker      Date              AppKit.NSSlider      IntValue      tvOS            Base Control      Default                  UIKit.UIButton      TouchUpInside              UIKit.UIBarButtonItem      Clicked              UIKit.UISearchBar      Text              UIKit.UITextField      Text              UIKit.UITextView      Text              UIKit.UILabel      Text              UIKit.UIImageView      Image              UIKit.UIProgressView      Progress              UIKit.UISegmentedControl      SelectedSegment              UIKit.UIActivityIndicatorView      Hidden              MvvmCross.Binding.tvOS.Views.MvxCollectionViewSource      ItemsSource              MvvmCross.Binding.tvOS.Views.MvxTableViewSource      ItemsSource              MvvmCross.Binding.tvOS.Views.MvxImageView      ImageUrl              MvvmCross.Binding.tvOS.Views.MvxImageViewLoader      ImageUrl      Built in bindingsThe following tables shows all the bindings built into MvvmCross.  When using extension method based bindings you will have to include the relevant using namespace to access the extension methods. Additionally, extension method based bindings are only supported starting with MvvmCross 5.Android - using MvvmCross.Binding.Droid            Base Control      String      Extension method                  Android.Views.View      Visible      BindVisible()              Android.Views.View      Hidden      BindHidden()              Android.Views.View      Click      BindClick()              Android.Views.View      LongClick      BindLongClick()              Android.Widget.TextView      Text      BindText()              Android.Widget.TextView      TextFormatted      BindTextFormatted()              Android.Widget.CompoundButton      Checked      BindChecked()              Android.Widget.SeekBar      Progress      BindProgress()              Android.Widget.ImageView      Bitmap      BindBitmap()              Android.Widget.ImageView      Drawable      BindDrawable()              Android.Widget.ImageView      DrawableId      BindDrawableId()              Android.Widget.ImageView      DrawableName      BindDrawableName()              Android.Widget.ImageView      ResourceName      BindResourceName()              Android.Widget.ImageView      AssetImagePath      BindAssetImagePath()              Android.Widget.EditText      TextFocus      BindTextFocus()              Android.Widget.SearchView      Query      BindQuery()              Android.Widget.RatingBar      Rating      BindRating()              Android.Widget.AdapterView      SelectedItemPosition      BindSelectedItemPosition()              Android.Preferences.Preference      Value      BindValue()              Android.Preferences.EditTextPreference      Text      BindText()              Android.Preferences.ListPreference      Value      BindValue()              Android.Preferences.TwoStatePreference      Checked      BindChecked()              MvvmCross.Binding.Droid.Views.MvxAutoCompleteTextView      PartialText      BindPartialText()              MvvmCross.Binding.Droid.Views.MvxAutoCompleteTextView      SelectedObject      BindSelectedObject()              MvvmCross.Binding.Droid.Views.MvxSpinner      SelectedItem      BindSelectedItem()              MvvmCross.Binding.Droid.Views.MvxListView      SelectedItem      BindSelectedItem()              MvvmCross.Binding.Droid.Views.MvxExpandableListView      SelectedItem      BindSelectedItem()              MvvmCross.Binding.Droid.Views.MvxRadioGroup      SelectedItem      BindSelectedItem()      Android - using MvvmCross.Plugins.Color.Droid            Base Control      String      Extension method                  Android.Widget.TextView      TextColor      BindTextColor()              Android.Views.View      BackgroundColor      BindBackgroundColor()      Android - using MvvmCross.Droid.Support.V7.AppCompat            Base Control      String      Extension method                  Android.Support.V7.Widget.SearchView      Query      BindQuery()              Android.Support.V7.Widget.Toolbar      Subtitle      BindSubtitle()              MvvmCross.Droid.Support.V7.AppCompat.Widget.MvxAppCompatAutoCompleteTextView      PartialText      BindPartialText()              MvvmCross.Droid.Support.V7.AppCompat.Widget.MvxAppCompatAutoCompleteTextView      SelectedObject      BindSelectedObject()              MvvmCross.Droid.Support.V7.AppCompat.Widget.MvxAppCompatSpinner      SelectedItem      BindSelectedItem()              MvvmCross.Droid.Support.V7.AppCompat.Widget.MvxAppCompatRadioGroup      SelectedItem      BindSelectedItem()      Android - using MvvmCross.Droid.Support.V7.Preference            Base Control      String      Extension method                  Android.Support.V7.Preferences.Preference      Value      BindValue()              Android.Support.V7.Preferences.ListPreference      Value      BindValue()              Android.Support.V7.Preferences.EditTextPreference      Text      BindText()              Android.Support.V7.Preferences.TwoStatePreference      Checked      BindChecked()      iOS - using MvvmCross.Binding.iOS            Base Control      String      Extension method                  UIKit.UIControl      TouchDown      BindTouchDown()              UIKit.UIControl      TouchDownRepeat      BindTouchDownRepeat()              UIKit.UIControl      TouchDragInside      BindTouchDragInside()              UIKit.UIControl      TouchUpInside      BindTouchUpInside()              UIKit.UIControl      ValueChanged      BindValueChanged()              UIKit.UIControl      PrimaryActionTriggered      BindPrimaryActionTriggered()              UIKit.UIControl      EditingDidBegin      BindEditingDidBegin()              UIKit.UIControl      EditingChanged      BindEditingChanged()              UIKit.UIControl      EditingDidEnd      BindEditingDidEnd()              UIKit.UIControl      EditingDidEndOnExit      BindEditingDidEndOnExit()              UIKit.UIControl      AllTouchEvents      BindAllTouchEvents()              UIKit.UIControl      AllEditingEvents      BindAllEditingEvents()              UIKit.UIControl      AllEvents      BindAllEvents()              UIKit.UIActivityIndicatorView      Hidden      BindHidden()              UIKit.UISlider      Value      BindValue()              UIKit.UIStepper      Value      BindValue()              UIKit.UISegmentedControl      SelectedSegment      BindSelectedSegment()              UIKit.UIPageControl      CurrentPage      BindCurrentPage()              UIKit.UIDatePicker      Date      BindDate()              UIKit.UITextField      ShouldReturn      BindShouldReturn()              UIKit.UIDatePicker      Time      BindTime()              UIKit.UILabel      Text      BindText()              UIKit.UITextField      Text      BindText()              UIKit.UITextView      Text      BindText()              UIKit.UISwitch      On      BindOn()              UIKit.UISearchBar      Text      BindText()              UIKit.UIButton      Title      BindTitle()              UIKit.UIButton      DisabledTitle      BindDisabledTitle()              UIKit.UIButton      HighlightedTitle      BindHighlightedTitle()              UIKit.UIButton      SelectedTitle      BindSelectedTitle()              UIKit.UIView      Tap      BindTap()              UIKit.UIView      Hidden      BindHidden()              UIKit.UIView      Visible      BindVisible()              UIKit.UIView      DoubleTap      BindDoubleTap()              UIKit.UIView      TextFocus      BindTextFocus()              UIKit.UIView      Visibility      BindVisibility()              UIKit.UIView      TwoFingerTap      BindTwoFingerTap()              UIKit.UIView      LayerBorderWidth      BindLayerBorderWidth()      Mac - using MvvmCross.Binding.Mac            Base Control      String      Extension method                  AppKit.NSView      Visibility      BindVisibility()              AppKit.NSView      Visible      BindVisible()              AppKit.NSSlider      IntValue      BindIntValue()              AppKit.NSSegmentedControl      SelectedSegment      BindSelectedSegment()              AppKit.NSDatePicker      Time      BindTime()              AppKit.NSDatePicker      Date      BindDate()              AppKit.NSTextField      StringValue      BindStringValue()              AppKit.NSTextView      StringValue      BindStringValue()              AppKit.NSButton      Visibility      BindVisibility()              AppKit.NSButton      Title      BindTitle()              AppKit.NSSearchField      Text      BindText()              AppKit.NSTabViewController      SelectedTabViewItemIndex      BindSelectedTabViewItemIndex()      tvOS - using MvvmCross.Binding.tvOS            Base Control      String      Extension method                  UIKit.UIControl      TouchUpInside      BindTouchUpInside()              UIKit.UIControl      ValueChanged      BindValueChanged()              UIKit.UIActivityIndicatorView      Hidden      BindHidden()              UIKit.UISegmentedControl      SelectedSegment      BindSelectedSegment()              UIKit.UITextField      ShouldReturn      BindShouldReturn()              UIKit.UILabel      Text      BindText()              UIKit.UITextField      Text      BindText()              UIKit.UITextView      Text      BindText()              UIKit.UISearchBar      Text      BindText()              UIKit.UIButton      Title      BindTitle()              UIKit.UIButton      DisabledTitle      BindDisabledTitle()              UIKit.UIButton      HighlightedTitle      BindHighlightedTitle()              UIKit.UIButton      SelectedTitle      BindSelectedTitle()              UIKit.UIView      Tap      BindTap()              UIKit.UIView      Hidden      BindHidden()              UIKit.UIView      Visible      BindVisible()              UIKit.UIView      TextFocus      BindTextFocus()              UIKit.UIView      DoubleTap      BindDoubleTap()              UIKit.UIView      Visibility      BindVisibility()              UIKit.UIView      TwoFingerTap      BindTwoFingerTap()              UIKit.UIView      LayerBorderWidth      BindLayerBorderWidth()      UWP - using MvvmCross.Binding.Uwp            Base Control      String      Extension method                  Windows.UI.Xaml.FrameworkElement      Visible      BindVisible()              Windows.UI.Xaml.FrameworkElement      Collapsed      BindCollapsed()              Windows.UI.Xaml.FrameworkElement      Hidden      BindHidden()      WPF - using MvvmCross.BindingEx.Wpf / using MvvmCross.BindingEx.WindowsCommon            Base Control      String      Extension method                  Windows.UI.Xaml.FrameworkElement      Visible      BindVisible()              Windows.UI.Xaml.FrameworkElement      Collapsed      BindCollapsed()              Windows.UI.Xaml.FrameworkElement      Hidden      BindHidden()      ",
            "url": "/documentation/fundamentals/data-binding"
          }
          ,
        
          "documentation-fundamentals-dependency-injection" :{
            "title": "Dependency injection",
            "content": "Constructor InjectionAs well as Mvx.Resolve&lt;T&gt;, the Mvx static class provides a reflection based mechanism to automatically resolve parameters during object construction.For example, if we add a class like:public class Bar{    public Bar(IFoo foo)    {        // do stuff    }}Then you can create this object using:    Mvx.IocConstruct&lt;Bar&gt;();What happens during this call is:  MvvmCross:          uses Reflection to find the constructor of Bar      looks at the parameters for that constructor and sees it needs an IFoo      uses Mvx.Resolve&lt;IFoo&gt;() to get hold of the registered implementation for IFoo      uses Reflection to call the constructor with the IFoo parameter      Constructor Injection and ViewModelsThis “Constructor Injection” mechanism is used internally within MvvmCross when creating ViewModels.If you declare a ViewModel like:public class MyViewModel : MvxViewModel{    public MyViewModel(IMvxJsonConverter jsonConverter, IMvxGeoLocationWatcher locationWatcher)    {    // ....    }}then MvvmCross will use the Mvx static class to resolve objects for jsonConverter and locationWatcher when a MyViewModel is created.This is important because:  It allows you to easily provide different locationWatcher classes on different platforms (on iPhone you can use a watcher that talk to CoreLocation  It allows you to easily provide mock implementations in your unit tests  It allows you to override default implementations - if you don’t like the Json.Net implementation for Json, you can use a ServiceStack.Text implementation instead.Constructor Injection and ChainingInternally, the Mvx.Resolve&lt;T&gt; mechanism uses constructor injection when new objects are needed.This enables you to register implementations which depend on other interfaces like:public interface ITaxCalculator{    double TaxDueFor(int customerId)}public class TaxCalculator{    public TaxCalculator(ICustomerRepository customerRepository, IForeignExchange foreignExchange, ITaxRuleList taxRuleList)    {        // code...    }    // code...}If you then register this calculator as:     Mvx.RegisterType&lt;ITaxCalculator, TaxCalculator&gt;();Then when a client calls Mvx.Resolve&lt;ITaxCalculator&gt;() then what will happen is that MvvmCross will create a new TaxCalculator instance, resolving all of ICustomerRepository IForeignExchange and ITaxRuleList during the operation.Further, this process is recursive - so if any of these returned objects requires another object  - e.g. if your IForeignExchange implementation requires a IChargeCommission object - then MvvmCross will use Resolve to provide an IChargeCommission instance for you.What if… I want to mix Dynamic and Singleton typesIf you use constructor injection, then for each dependency you can only ever receive a single instance. In some cases this may not be what you want.Take the following code:// Registered with Mvx.RegisterType&lt;IBar, Bar&gt;();public class Bar : IBar{    public void DoStuff()    {        // implementation    }}// Registered with Mvx.ConstructAndRegisterSingleton&lt;IFooSingleton, FooSingleton&gt;();public class FooSingleton : IFooSingleton{    private readonly IBar _bar;    public FooSingleton(IBar bar)    {        // This \"bar\" instance will be held forever,        // no other instance will be created for the        // lifetime of this singleton        _bar = bar;    }    public void DoFoo()    {        _bar.DoStuff();    }}In this case, FooSingleton is registered as a singleton within MvvmCross, and when it is created it will receive a instance of Bar, which it will always use.If instead, you wanted the FooSingleton to request a new instance each time then you could remove the constructor injection and instead use dynamic resolution - for example:public class FooSingleton : IFooSingleton{    public FooSingleton()    {        // No \"IBar\" dependency in the constructor    }    public void DoFoo()    {        var bar = Mvx.Resolve&lt;IBar&gt;();        bar.DoStuff();    }}As another alternative, you could continue to use constructor injection, but could use an IBarFactory dependency instead of an IBar - e.g.:public class FooSingleton : IFooSingleton{    private readonly IFactory&lt;IBar&gt; _barFactory;    public FooSingleton(IFactory&lt;IBar&gt; barFactory)    {        _barFactory = barFactory;    }    public void DoFoo()    {        var bar = _barFactory.Create();        bar.DoStuff();    }}Understanding object lifecycles in this type of situation - where some objects are dynamic and some are singletons - can be difficult, especially in large applications. To work with these type of objects it may help to adopt and follow patterns and naming conventions within your application - these may allow developers to more easily identify which interfaces should and should not be used dynamically.",
            "url": "/documentation/fundamentals/dependency-injection"
          }
          ,
        
          "documentation-fundamentals-inversion-of-control-ioc" :{
            "title": "Inversion of Control",
            "content": "Two key ideas that are used in MvvmCross are:  the Service Locator pattern  Inversion of ControlThere are lots of articles and introductions available on this - some good starting places are Martin Fowler’s introduction and Joel Abrahamsson’s IoC introduction. I’ve also made some animated slides as a simple demonstration.Specifically within MvvmCross, we provide a single static class Mvx which acts as a single place for both registering and resolving interfaces and their implementations.Service Location - Registration and ResolutionThe core idea of MvvmCross Service Location is that you can write classes and interfaces like:public interface IFoo{    string Request();}public class Foo : IFoo{    public string Request()    {        return \"Hello World\";    }}Singleton RegistrationWith this pair written you could then register a Foo instance as a singleton which implements IFoo using:    // every time someone needs an IFoo they will get the same one    Mvx.RegisterSingleton&lt;IFoo&gt;(new Foo());If you did this, then any code can call:    var foo = Mvx.Resolve&lt;IFoo&gt;();and every single call would return the same instance of FooAn alternative syntax for singleton registration - especially useful when the registered type requires constructor dependency injection - is:    // every time someone needs an IFoo they will get the same one    Mvx.ConstructAndRegisterSingleton&lt;IFoo, Foo&gt;();Lazy Singleton RegistrationAs a variation on this, you could register a lazy singleton. This is written    // every time someone needs an IFoo they will get the same one    // but we don't create it until someone asks for it    Mvx.RegisterSingleton&lt;IFoo&gt;(() =&gt; new Foo());In this case:  no Foo is created initially  the first time any code calls Mvx.Resolve&lt;IFoo&gt;() then a new Foo will be created and returned  all subsequent calls will get the same instance that was created the first timeAn alternative syntax for lazy singleton registration - especially useful when the registered type requires constructor dependency injection - is:    // every time someone needs an IFoo they will get the same one    Mvx.LazyConstructAndRegisterSingleton&lt;IFoo, Foo&gt;();‘Dynamic’ RegistrationOne final option, is that you can register the IFoo and Foo pair as:    // every time someone needs an IFoo they will get a new one    Mvx.RegisterType&lt;IFoo, Foo&gt;();In this case, every call to Mvx.Resolve&lt;IFoo&gt;() will create a new Foo - every call will return a different Foo.Last-registered winsIf you create several implementations of an interface and register them all:    Mvx.RegisterType&lt;IFoo, Foo1&gt;();    Mvx.RegisterSingleton&lt;IFoo&gt;(new Foo2());    Mvx.RegisterType&lt;IFoo, Foo3&gt;();Then each call replaces the previous registration - so when a client calls Mvx.Resolve&lt;IFoo&gt;() then the most recent registration will be returned.This can be useful for:  overwriting default implementations  replacing implementations depending on application state - e.g. after a user has been authenticated then you could replace an empty IUserInfo implementation with a real one.Bulk Registration by ConventionThe default NuGet templates for MvvmCross contain a block of code in the core App.cs like:        CreatableTypes()            .EndingWith(\"Service\")            .AsInterfaces()            .RegisterAsLazySingleton();This code uses Reflection to:  find all classes in the Core assembly          which are creatable - i.e.:                  have a public constructor          are not abstract                    with names ending in Service        find their interfaces  register them as lazy singletons according to the interfaces they supportTechnical Note&gt; the lazy singleton implementation here is quite technical - it ensures that if a class implements IOne and ITwo then the same instance will be returned when resolving both IOne and ITwo.The choice of name ending here - Service - and the choice to use Lazy singletons are only personal conventions. If you prefer to use other names or other lifetimes for your objects you can replace this code with a different call or with multiple calls like:        CreatableTypes()            .EndingWith(\"SingleFeed\")            .AsInterfaces()            .RegisterAsLazySingleton();        CreatableTypes()            .EndingWith(\"Generator\")            .AsInterfaces()            .RegisterAsDynamic();        CreatableTypes()            .EndingWith(\"QuickSand\")            .AsInterfaces()            .RegisterAsSingleton();There you can also use additional Linq helper methods to help further define your registrations if you want to - e.g. Inherits, Except. WithAttribute, Containing, InNamespace … e.g.        CreatableTypes()            .StartingWith(\"JDI\")            .InNamespace(\"MyApp.Core.HyperSpace\")            .WithAttribute(typeof(MySpecialAttribute))            .AsInterfaces()            .RegisterAsSingleton();And you can also, of course, use the same type of registration logic on assemblies other than Core - e.g.:        typeof(Reusable.Helpers.MyHelper).Assembly.CreatableTypes()            .EndingWith(\"Helper\")            .AsInterfaces()            .RegisterAsDynamic();Alternatively, if you prefer not to use this Reflection based registration, then you can instead just manually register your implementations:        Mvx.RegisterSingleton&lt;IMixer&gt;(new MyMixer());        Mvx.RegisterSingleton&lt;ICheese&gt;(new MyCheese());        Mvx.RegisterType&lt;IBeer, Beer&gt;();        Mvx.RegisterType&lt;IWine, Wine&gt;();The choice is your’sConstructor InjectionAs well as Mvx.Resolve&lt;T&gt;, the Mvx static class provides a reflection based mechanism to automatically resolve parameters during object construction.For example, if we add a class like:    public class Bar    {        public Bar(IFoo foo)        {            // do stuff        }    }Then you can create this object using:    Mvx.IocConstruct&lt;Bar&gt;();What happens during this call is:  MvvmCross:          uses Reflection to find the constructor of Bar      looks at the parameters for that constructor and sees it needs an IFoo      uses Mvx.Resolve&lt;IFoo&gt;() to get hold of the registered implementation for IFoo      uses Reflection to call the constructor with the IFoo parameter      Constructor Injection and ViewModelsThis “Constructor Injection” mechanism is used internally within MvvmCross when creating ViewModels.If you declare a ViewModel like:     public class MyViewModel : MvxViewModel     {         public MyViewModel(IMvxJsonConverter jsonConverter, IMvxGeoLocationWatcher locationWatcher)         {            // ....         }     }then MvvmCross will use the Mvx static class to resolve objects for jsonConverter and locationWatcher when a MyViewModel is created.This is important because:  It allows you to easily provide different locationWatcher classes on different platforms (on iPhone you can use a watcher that talk to CoreLocation  It allows you to easily provide mock implementations in your unit tests  It allows you to override default implementations - if you don’t like the Json.Net implementation for Json, you can use a ServiceStack.Text implementation instead.Constructor Injection and ChainingInternally, the Mvx.Resolve&lt;T&gt; mechanism uses constructor injection when new objects are needed.This enables you to register implementations which depend on other interfaces like:     public interface ITaxCalculator     {         double TaxDueFor(int customerId)     }     public class TaxCalculator     {         public TaxCalculator(ICustomerRepository customerRepository, IForeignExchange foreignExchange, ITaxRuleList taxRuleList)         {             // code...         }         // code...     }If you then register this calculator as:     Mvx.RegisterType&lt;ITaxCalculator, TaxCalculator&gt;();Then when a client calls Mvx.Resolve&lt;ITaxCalculator&gt;() then what will happen is that MvvmCross will create a new TaxCalculator instance, resolving all of ICustomerRepository IForeignExchange and ITaxRuleList during the operation.Further, this process is recursive - so if any of these returned objects requires another object  - e.g. if your IForeignExchange implementation requires a IChargeCommission object - then MvvmCross will use Resolve to provide an IChargeCommission instance for you.How do I use IoC when I need different implementations on different platforms?Sometimes you need to use some platform specific functionality in your ViewModels. e.g. for example, you might want to get the current screen dimensions in your ViewModel - but there’s no existing portable .Net call to do this.When you want to include functionality like this, then there are two main choices:  Declare an interface in your core library, but then provide and register an implementation in each of your UI projects.  Use or create a plugin1. PCL-Interface with Platform-Specific ImplementationIn your core project, you can declare an interface and you can use that interface in your classes there - e.g.:    public interface IScreenSize    {        double Height { get; }        double Width { get; }    }    public class MyViewModel : MvxViewModel    {        private readonly IScreenSize _screenSize;        public MyViewModel(IScreenSize screenSize)        {             _screenSize = screenSize;        }        public double Ratio        {            get { return (_screenSize.Width / _screenSize.Height); }        }    }In each UI project, you can then declare the platform-specific implementation for IScreenSize - e.g. a trivial example is:    public class WindowsPhoneScreenSize : IScreenSize    {        public double Height { get { return 800.0; } }        public double Width { get { return 480.0; } }    }You can then register these implementations in each of the platform-specific Setup files - e.g. you could override MvxSetup.InitializeFirstChance with    protected override void InitializeFirstChance()    {        Mvx.RegisterSingleton&lt;IScreenSize&gt;(new WindowsPhoneScreenSize());        base.InitializeFirstChance();    }With this done, then MyViewModel will get provided with the correct platform specific implementation of IScreenSize on each platform.2. Use or create a pluginA Plugin is an MvvmCross pattern for combining a PCL assembly, plus optionally some platform specific assemblies in order to package up some functionality.This plugin layer is simply a pattern - some simple conventions - for naming related Assemblies, for including small PluginLoader and Plugin helper classes, and for using IoC. Through this pattern it allows functionality to be easily included, reused and tested across platforms and across applications.For example, existing plugins include:  a File plugin which provides access to System.IO type methods for manipulating files  a Location plugin which provides access to GeoLocation information  a Messenger plugin which provides access to a Messenger/Event Aggregator  a PictureChooser plugin which provides access to the camera and to the media library  a ResourceLoader plugin which provides a way to access resource files packaged within the .apk, .app or .ipa for the application  a SQLite plugin which provides access to SQLite-net on all platforms.####Plugin UseIf you want to see how these plugins can be used in your applications, then:  the N+1 videos provide a good starting point - see http://mvvmcross.wordpress.com/ - especially :          N=8 - Location http://slodge.blogspot.co.uk/2013/05/n8-location-location-location-n1-days.html      N=9 - Messenger http://slodge.blogspot.co.uk/2013/05/n9-getting-message-n1-days-of-mvvmcross.html      N=10 - SQLite http://slodge.blogspot.co.uk/2013/05/n10-sqlite-persistent-data-storage-n1.html      N=12 -&gt; N=17 - the Collect-A-Bull app http://slodge.blogspot.co.uk/2013/05/n12-collect-bull-full-app-part-1-n1.html        see the Plugins article####Plugin AuthoringWriting plugins is easy to do, but can feel a bit daunting at first.The key steps are:  Create the main PCL Assembly for the plugin - this should include:          the interfaces your plugin will register      any shared portable code (which may include implementations of one or more of the interfaces)      a special PluginLoader class which MvvmCross will use to start the plugin        Optionally create platform specific assemblies which:          is named the same as the main assembly but with a platform specific extension (.Droid, .WindowsPhone, etc(      contains                  any platform specific interface implementations          a special Plugin class which MvvmCross will use to start this platform-specific extension                      Optionally provide extras like documentation and nuget packaging which will make the plugin easier to reuse.I’m not going to go into any more detail on writing plugins here.If you’d like to see more about writing your own plugin, then:  see the Plugins article  there’s a presentation on this at https://speakerdeck.com/cirrious/plugins-in-mvvmcross  there’s a sample which creates a Vibrate plugin at https://github.com/slodge/MvvmCross-Tutorials/tree/master/GoodVibrationsWhat if…What if… I don’t want to use Service Location or IoCIf you don’t want to use this in your code, then don’t.Simply remove the CreatableTypes()... code from App.cs and then use ‘normal code’ in your ViewModels - e.g.:     public class MyViewModel : MvxViewModel     {         private readonly ITaxService _taxService;         public MyViewModel()         {             _taxService = new TaxService();         }     }What if… I want to use a different Service Location or IoC mechanismThere are lots of excellent libraries out there including AutoFac, Funq, MEF, OpenNetCF, TinyIoC and many, many more!If you want to replace the MvvmCross implementation, then you’ll need to:  write some kind of Adapter layer to provide their service location code as an IMvxIoCProvider  override CreateIocProvider in your Setup class to provide this alternative IMvxIoCProvider implementation.Alternatively, you may be able to organize a hybrid situation - where two IoC/ServiceLocation systems exist side-by-side.What if… I want to use Property Injection as an IoC mechanism?From v3.1 of MvvmCross, Property Injection is supported in the default IoC container.To enable this injection, you need to change your app Setup so that it overrides CreateIocOptions()There are currently two ways you inject into properties:  inject only into marked interface properties - MvxInjectInterfaceProperties  inject into all interface properties - AllInterfacePropertiesIn both cases, MvvmCross will perform the property injection as soon as construction is completed.One further option is that the MvvmCross IMvxPropertyInjector can be used independently - you can choose to use this on your options if you want to.MvxInjectInterfacePropertiesIf you override options as:  protected override IMvxIoCOptions CreateIocOptions()  {      return new MvxIocOptions()      {                PropertyInjectorOptions = MvxPropertyInjectorOptions.MvxInject      };  }then this will enable injection into public writeable properties which are declared as interfaces and which have an MvxInject attribute - e.g. Foo below:   public class MyViewModel : MvxViewModel   {       [MvxInject]       public IFooService Foo { get; set; }   }AllInterfacePropertiesIf you override options as:  protected override IMvxIoCOptions CreateIocOptions()  {      return new MvxIocOptions()      {                PropertyInjectorOptions = MvxPropertyInjectorOptions.All      };  }then this will enable injection into public writeable properties which are declared as interfaces - e.g. Bar below:   public class MyViewModel : MvxViewModel   {       public IBarService Bar { get; set; }   }Using IMvxPropertyInjector directlyYou can inject into your own objects independently of the MvvmCross IoC Container.To do this, you can use: var injector = new MvxPropertyInjector()or var injector = Mvx.Resolve&lt;IMvxPropertyInjector&gt;();and then: var foo = new Foo(); injector.Inject(foo, MvxPropertyInjectorOptions.MvxInject);or: var bar = new Bar(); injector.Inject(bar, MvxPropertyInjectorOptions.All);What happens if… A needs a B which needs an A which … ?Circular references are a tricky problem in object construction - regardless of whether or not you use dependency injection.For example:    public interface IA { }    public interface IB { }    public class A : IA    {       public A(IB b) { }    }    public class B : IB    {       public B(IA a) { }    }At runtime, by default MvvmCross’s Ioc will throw an MvxIoCResolveException from Resolve or return false from TryResolve if it detects recursion has occurred.Generally in this situation you need to refactor your code to remove the circular dependency - for example see one suggestion in Stack Overflow - other stackoverflow Q&amp;As may also help.However, if you feel the MvvmCross detection is wrong - if your app has some behaviour which means it can survive the recursive dependency - then you can turn this detection off if you want to using the options - e.g:        var options = new MvxIocOptions()        {            TryToDetectDynamicCircularReferences = false            TryToDetectSingletonCircularReferences = false        };        var instance = MvxSimpleIoCContainer.Initialize(options);Note: in the event of recursion causing a stack overflow, some mobile runtimes will not throw a StackOverlowException - but will instead simply exit without warning - this situation can be hard to debug.What if… I want advanced IoC features like child containersThe IoC container in MvvmCross is designed to be quite lightweight and is targeted at a level of functionality required in the mobile applications I have built.If you need more advanced/complex functionality, then you may need to use a different provider or a different approach - some suggestions for this are discussed in: http://stackoverflow.com/questions/16514691/child-containers-in-mvvmcross-iocWhat if… I want to mix Dynamic and Singleton typesIf you use constructor injection, then for each dependency you can only ever receive a single instance. In some cases this may not be what you want.Take the following code:// Registered with Mvx.RegisterType&lt;IBar, Bar&gt;();public class Bar : IBar{    public void DoStuff()    {        // implementation    }}// Registered with Mvx.ConstructAndRegisterSingleton&lt;IFooSingleton, FooSingleton&gt;();public class FooSingleton : IFooSingleton{    private readonly IBar _bar;    public FooSingleton(IBar bar)    {        // This \"bar\" instance will be held forever,        // no other instance will be created for the        // lifetime of this singleton        _bar = bar;    }    public void DoFoo()    {        _bar.DoStuff();    }}In this case, FooSingleton is registered as a singleton within MvvmCross, and when it is created it will receive a instance of Bar, which it will always use.If instead, you wanted the FooSingleton to request a new instance each time then you could remove the constructor injection and instead use dynamic resolution - for example:public class FooSingleton : IFooSingleton{    public FooSingleton()    {        // No \"IBar\" dependency in the constructor    }    public void DoFoo()    {        var bar = Mvx.Resolve&lt;IBar&gt;();        bar.DoStuff();    }}As another alternative, you could continue to use constructor injection, but could use an IBarFactory dependency instead of an IBar - e.g.:public class FooSingleton : IFooSingleton{    private readonly IFactory&lt;IBar&gt; _barFactory;    public FooSingleton(IFactory&lt;IBar&gt; barFactory)    {        _barFactory = barFactory;    }    public void DoFoo()    {        var bar = _barFactory.Create();        bar.DoStuff();    }}Understanding object lifecycles in this type of situation - where some objects are dynamic and some are singletons - can be difficult, especially in large applications. To work with these type of objects it may help to adopt and follow patterns and naming conventions within your application - these may allow developers to more easily identify which interfaces should and should not be used dynamically.",
            "url": "/documentation/fundamentals/inversion-of-control-ioc"
          }
          ,
        
          "documentation-fundamentals-mvvmcross-overview" :{
            "title": "MvvmCross Overview",
            "content": "Deployed MvvmCross applications consist of two parts:  the “core” - containing all the ViewModels, Services, Models and ‘business’ code  the “ui” - containing the Views and platform specific code for interacting with the “core”For a multi-platform application, it’s typical for there to be:  a single “core” project, written as a PCL (Portable Class Library)  a “ui” project per platform written as a native project for the current target platform.  optionally some “plugins” - each one containing a PCL part and native parts - each one providing reusable abstractions of native functionality such as camera, geolocation, accelerometer, files, etcThis is the way that MvvmCross encourages people to write their applications, and this guide will. However, other approaches are possible - e.g. a single project can include both “core” and “ui”, or multiple “core” projects can be written using copy-and-paste or using a technique such as file-linkingSome key MvvmCross objectsThere are a few key objects within an MvvmCross application:  in the “core”, there are:  an App - responsible for starting your ViewModels and your business logic  a Start object - responsible for deciding the first ViewModel or ViewModels which should be presented  one or more ViewModels - each one responsible for a piece of user interaction      your services, models, etc    in each “ui”, there are:  the native Application object - responsible for native lifecycle events - on each platform this object is a platform-specific class  an MvvmCross Setup class - responsible for ‘bootstraping’ MvvmCross, your ‘core’ and your ‘ui’  one or more Views - each one responsible for presenting one of your ViewModels  a Presenter - responsible for deciding how Views are shown  custom UI code - for controls, gestures, events, etcHow an MvvmCross application startsWhen an MvvmCross app starts on a native project, then:  the native Application will ‘be created’ first  within the construction of the native Application, a Setup will be created  the Setup will perform very basic tasks - e.g. initialization of the IoC system (see https://github.com/slodge/MvvmCross/wiki/Service-Location-and-Inversion-of-Control)  then the Setup will call into the core project, construct an App and will call Initialize on it.  during the Initialize your App will typically:          register your app-specific services with the IoC system      create and register a Start object        the Setup will then configure the UI side of the project - especially things like lookup tables for views  finally the Setup will start the MvvmCross binding engine (if needed)  with Setup complete, your native Application can then actually start.  to do this, it requests a reference to the Start object and calls Start() on it  after this, the app will start presenting ViewModels using databound ViewsThe MvvmCross CoreAn MvvmCross Core project provides:  an application object - typically in App.cs  one or more ViewModels - normally in a folder called ViewModels  your code: services, models, repositories, engines, units of work, etc - whatever your app needs to workApp.csIn each MvvmCross application there should be one and only one App.This App is not to be confused with the ApplicationDelegate in iOS, or with the Application objects in Android or Windows. Those native objects are there to provide the lifecycle of the native platform-specific code.Instead, this App in MvvmCross is there to assist with the lifecycle of your ViewModels and your services, models, etcThe key methods within an App are:  Initialize - called on start up  FindViewModelLocator(MvxViewModelRequest request) - used to find the object which provides ViewModels during navigationThe specific jobs that your App should do during its Initialize are:  to construct and/or IoC-register any objects specific to your applications - services, models, etc  to register an IMvxAppStart objectA default App supplied via NuGet, looks like:using MvvmCross.Platform.Ioc;namespace MyName.Core{    public class App : MvvmCross.Core.ViewModels.MvxApplication    {        public override void Initialize()        {            CreatableTypes()                .EndingWith(\"Service\")                .AsInterfaces()                .RegisterAsLazySingleton();            RegisterAppStart&lt;ViewModels.MainViewModel&gt;();        }    }}This App:  within Initialize  looks within the current Assembly (the “core” Assembly) and uses Reflection to register all classes ending in Service as lazily-constructed singletons  calls RegisterAppStart&lt;TViewModel&gt; to create and register a very simple IMvxAppStart implementation - an implementation which always shows a single MainViewModel when Start() is called  uses the default ViewModelLocator - this default uses naming conventions to locate and construct ViewModels and creates a new ViewModel for each and every request from a ViewIf you wanted to use a custom IMvxAppStart object, see https://github.com/slodge/MvvmCross/wiki/Customising-using-App-and-Setup.ViewModelsIn each MvvmCross ‘core’ application your ViewModels provide containers for the state and the behaviour for your User Interface.Typically they do this using:  C# Properties  the INotifyPropertyChanged and INotifyCollectionChanged interfaces to send notifications when properties change  special ICommand properties which can allow View events (e.g. button taps) to call actions within the ViewModelFor MvvmCross, ViewModels normally inherit from MvxViewModelA typical ViewModel might look like:public class MainViewModel : MvxViewModel{    public MainViewModel()    {    }            public override Task Initialize()    {        //TODO: Add starting logic here                    return base.Initialize();    }            public IMvxCommand ResetTextCommand =&gt; new MvxCommand(ResetText);    private void ResetText()    {        Text = \"Hello MvvmCross\";    }    private string _text = \"Hello MvvmCross\";    public string Text    {        get { return _text; }        set { SetProperty(ref _text, value); }    }}This MainViewModel has:  a single Text property which raises a PropertyChanged notification when it changes  a single ResetTextCommand command which will call the ResetText() method whenever the command is executed.Beyond this simple example, ViewModels can also:  contain dynamic lists (see https://github.com/slodge/MvvmCross/wiki/MvvmCross-Tutorials#working-with-collections)  be constructed from IoC (https://github.com/slodge/MvvmCross/wiki/Service-Location-and-Inversion-of-Control)  use ‘techniques’ like:  MvxCommandCollection (see http://slodge.blogspot.co.uk/2013/03/fixing-mvvm-commands-making-hot-tuna.html),  IMvxINPCInterceptor (see http://slodge.blogspot.co.uk/2013/07/intercepting-raisepropertychanged.html)  Fody to remove some of the boilerplate code (http://slodge.blogspot.co.uk/2013/07/awesome-clean-viewmodels-via-fody.html)  Rio binding (see http://slodge.blogspot.co.uk/2013/07/n36-rio-binding-carnival.html)The MvvmCross UIAn MvvmCross ‘ui’ project provides:  the native platform-specific application code - e.g Main.cs and AppDelegate.cs on Xamarin.iOS  a Setup.cs class  one or more Views - each one responsible for presenting one of your ViewModels  a Presenter - responsible for deciding how Views are shown  custom UI code - for controls, gestures, events, etcPlatform specific application codeiOSOn iOS, we need to replace the normal AppDelegate.cs class with an MvxApplicationDelegateAn initial replacement looks like:using Foundation;using UIKit;using MvvmCross.Platform;using MvvmCross.iOS.Platform;using MvvmCross.Core.ViewModels;namespace MyName.iOS{    [Register(\"AppDelegate\")]    public partial class AppDelegate : MvxApplicationDelegate    {        public override UIWindow Window { get; set; }        public override bool FinishedLaunching(UIApplication application, NSDictionary launchOptions)        {            Window = new UIWindow(UIScreen.MainScreen.Bounds);            var setup = new Setup(this, Window);            setup.Initialize();            var startup = Mvx.Resolve&lt;IMvxAppStart&gt;();            startup.Start();            Window.MakeKeyAndVisible();            return true;        }    }}AndroidOn Android, we don’t normally have any Application to override. Instead of this, MvvmCross by default provides a SplashScreen - this typically looks like:using Android.App;using Android.Content.PM;using MvvmCross.Droid.Views;namespace MyName.Droid{    [Activity(         Label = \"CustomBinding.Droid\"                 , MainLauncher = true         , Icon = \"@drawable/icon\"         , Theme = \"@style/Theme.Splash\"         , NoHistory = true         , ScreenOrientation = ScreenOrientation.Portrait)]    public class SplashScreen : MvxSplashScreenActivity    {        public SplashScreen()        : base(Resource.Layout.SplashScreen)        {        }    }}Importantly, please note that this class is marked with MainLauncher = true to ensure that this is the first thing created when the native platform starts.WPFOn WPF, a new project will contain a native App.xaml.cs.  After adding the MvvmCross libraries via NuGet a new file is added called ‘App.Xam.Mvx.cs’.  This file contains -using System;using System.Windows;using MvvmCross.Core;using MvvmCross.Core.ViewModels;using MvvmCross.Wpf.Views;namespace MyName.Wpf{    public partial class App : Application    {        private bool _setupComplete;        private void DoSetup()        {            LoadMvxAssemblyResources();            var setup = new Setup(Dispatcher, MainWindow);            setup.Initialize();            var start = Mvx.Resolve&lt;IMvxAppStart&gt;();            start.Start();            _setupComplete = true;        }        protected override void OnActivated(EventArgs e)        {            if (!_setupComplete)                DoSetup();            base.OnActivated(e);        }        private void LoadMvxAssemblyResources()        {            for (var i = 0;; i++)            {                string key = \"MvxAssemblyImport\" + i;                var data = TryFindResource(key);                if (data == null)                    return;            }        }    }}A default MainWindow should also exist.UWPOn UWP, a new project will again contain a native App.xaml.csTo adapt this for MvvmCross, we simply find the method OnLaunched and replace the if (rootFrame.Content == null) block with:var setup = new Setup(rootFrame);setup.Initialize();var start = Mvx.Resolve&lt;IMvxAppStart&gt;();start.Start();Setup.csThe Setup class is the bootstrapper for the MvvmCross system.This bootstrapper goes through a lot of steps, and almost all of these are virtual allowing you to customize MvvmCross.Some key ones you should be aware of are:  CreateApplication - your Setup must override this one in order to provide a new instance of your App object from your core project  InitializeFirstChance - a “first blood” placeholder for any steps you want to take before any of the later steps happen  CreateDebugTrace - a chance to customise where application trace is placed - see http://stackoverflow.com/a/17234083/373321 for an example  InitializeLastChance - a “last ditch” placeholder for any steps you want to take after all of earlier steps have happened.  Note that the Android and iOS base Setup classes use ‘last chance’ for initializing the UI data-binding system, so it’s important to always call base.InitializeLastChance() in your override.Beyond this, a larger list of Setup customisation options is discussed in https://github.com/slodge/MvvmCross/wiki/Customising-using-App-and-SetupMinimal Setup - Androidusing Android.Content;using MvvmCross.Droid.Platform;using MvvmCross.Core.ViewModels;namespace MyName.Droid{    public class Setup : MvxAndroidSetup    {        public Setup(Context applicationContext) : base(applicationContext)        {        }        protected override IMvxApplication CreateApp()        {            return new Core.App();        }    }}Minimal Setup - iOSusing UIKit;using MvvmCross.iOS.Platform;namespace MyName.iOS{    public class Setup : MvxIosSetup    {        public Setup(MvxApplicationDelegate applicationDelegate, UIWindow window)        : base(applicationDelegate, window)        {        }        protected override IMvxApplication CreateApp ()        {            return new Core.App();        }    }}Minimal Setup - WPFusing System.Windows.Threading;using MvvmCross.Platform;using MvvmCross.Core.ViewModels;using MvvmCross.Wpf.Platform;using MvvmCross.Wpf.Views;namespace MyName.Wpf{    public class Setup : MvxWpfSetup    {        public Setup(Dispatcher uiThreadDispatcher, ContentControl root)            : base(uiThreadDispatcher, root)        {        }        protected override IMvxApplication CreateApp()        {            return new Core.App();        }    }}Setup - UWPusing MvvmCross.ViewModels;using MvvmCross.Uwp.Platform;using Windows.UI.Xaml.Controls;namespace MyName.Store{    public class Setup : MvxWindowsSetup    {        public Setup(Frame rootFrame) : base(rootFrame)        {        }        protected override IMvxApplication CreateApp()        {            return new Core.App();        }    }}ViewsEach UI Platform needs a set of ViewsEach View is normally databound to a single ViewModel for its entire lifetime.On each platform, Views in the Mvvm sense are typically implemented using data-bound versions of:  On Windows platforms a UserControl - for UWP is very often specialized into a Page  On Android, an Activity or Fragment  On iOS, a UIViewControllerWithin this introduction we won’t go further into how these Views are actually written - instead see the introductions to data-binding on each platform within the TipCalc tutorial.One important thing to note, is that by default Views are associated with ViewModels using a naming convention in MvvmCross. This can be overridden if required (see the https://github.com/slodge/MvvmCross/wiki/Customising-using-App-and-Setup#overriding-view-viewmodel-associations) - but by default the MvvmCross system links a View called FooView to a ViewModel called FooViewModelA PresenterEach UI Platform provides a Presenter which implements IMvxViewPresenter.In default applications, the Presenter used normally fills the entire screen with a Page and allows back button navigation to previous pages.When more advanced screen layouts are needed - e.g. flyouts, tabs, pivots, split-screens, etc - then these can be supplied by using a custom presenter. For more on this, see http://slodge.blogspot.co.uk/2013/06/presenter-roundup.html",
            "url": "/documentation/fundamentals/mvvmcross-overview"
          }
          ,
        
          "documentation-fundamentals-mvxinteraction" :{
            "title": "ViewModel to View Interaction",
            "content": "Sometimes when interacting between a View and ViewModel, you want to offload some responsibility to the View. In other words, you wantto request interaction from the View.However, you still want to keep the View and ViewModel separate from each other. This is where IMvxInteraction comes into the picture.IMvxInteraction lets the ViewModel interact with the View. Similarly to how a View would interact with a ViewModel through MvxCommand.IMvxInteraction allows the dev to pass along an arbitrary payload, which in complex scenarios also could have callbacks into the ViewModel.It decouples the View and ViewModel from knowing each other directly. The only thing the View sees is a IMvxInteraction instance, which itcan listen to the Requested event to know when an interaction is requested.ExampleLet us start with a simple example. The scenario is that you want to signal the View to show a dialog with a couple of options, before youwant to proceed executing a Command.So the flow would be:  Press a button or something that triggers a MvxCommand  The command needs interaction from the user, yes/no  Command finishes based on interactionLets start by defining our interaction object in our core project.Interaction classpublic class YesNoQuestion{    public Action&lt;bool&gt; YesNoCallback { get; set; }    public string Question { get; set; }}This seems pretty simple enough. We have a callback when the user presses yes or no, and a text for the question in the dialog.ViewModel definitionIn our ViewModel we need to define a MvxInteractionprivate MvxInteraction&lt;YesNoQuestion&gt; _interaction =    new MvxInteraction&lt;YesNoQuestion&gt;();    // need to expose it as a public property for binding (only IMvxInteraction is needed in the view)public IMvxInteraction&lt;YesNoCancel&gt; Interaction =&gt; _interaction;Now lets imagine we have a MvxCommand the user triggers to finish creating their profile. Here we want this interaction to happen,to ask if they are sure.private void DoFinishProfileCommand(){    // 1. do cool stuff with profile data    // ...        // 2. request interaction from view    // 3. execution continues in callbacks    var request = new YesNoQuestion    {        YesNoCallback = async (ok) =&gt;         {            if (ok)                await SaveProfile();            else                await Cancel();        },        Question = \"Do you want to save your profile?\"    };        _interaction.Raise(request);}View definitionNow that we can request an interaction from the ViewModel, we need to react to it from the View. A small bit of boiler plate is neededhere. To keep this example simple we subscribe directly to the Requested event. However, you may prefer to use WeakSubscribe or use Rx.Net’sObservable.FromEventPattern.private IMvxInteraction&lt;YesNoQuestion&gt; _interaction;public IMvxInteraction&lt;YesNoQuestion&gt; Interaction{    get =&gt; _interaction;    set    {        if (_interaction != null)            _interaction.Requested -= OnInteractionRequested;                    _interaction = value;        _interaction.Requested += OnInteractionRequested;    }}Now we just need to react to the interaction request when triggered by the event.private async void OnInteractionRequested(object sender, MvxValueEventArgs&lt;YesNoQuestion&gt; eventArgs){    var yesNoQuestion = eventArgs.Value;    // show dialog    var status = await ShowDialog(yesNoQuestion.Question);    yesNoQuestion.YesNoCallback(status == DialogStatus.Yes);}Wiring up Interaction between View and ViewModelNow that we have all the behavior defined, we just need to wire the View up to the ViewModel. As always this is done through bindings, which we will leverage here as well.As per usual, we just need to create a binding set and apply the binding.var set = this.CreateBindingSet&lt;OurView, OurViewModel&gt;();set.Bind(this).For(view =&gt; view.Interaction).To(viewModel =&gt; viewModel.Interaction).OneWay();set.Apply();This is it. You should now be able to interact with the View from your ViewModel.",
            "url": "/documentation/fundamentals/mvxinteraction"
          }
          ,
        
          "documentation-fundamentals-navigation" :{
            "title": "Navigation",
            "content": "MvvmCross uses ViewModel first navigation. Meaning the we navigate from ViewModel to ViewModel and not from View to View. In MvvmCross the ViewModel will lookup its corresponding View. By doing so we don’t have to write platform specific navigation and we can manage everything from within our core.MvvmCross 5.x and higher navigationMvvmCross 5 introduces a new NavigationService! The new navigation enables you to inject it into your ViewModels, which makes it more testable, and gives you the ability to implement your own navigation! Other main features are that it is fully async and type safe.For more details see #1634The following Api is available to use:public interface IMvxNavigationService{    event BeforeNavigateEventHandler BeforeNavigate;    event AfterNavigateEventHandler AfterNavigate;    event BeforeCloseEventHandler BeforeClose;    event AfterCloseEventHandler AfterClose;    Task Navigate(IMvxViewModel viewModel, IMvxBundle presentationBundle = null);    Task Navigate&lt;TParameter&gt;(IMvxViewModel&lt;TParameter&gt; viewModel, TParameter param, IMvxBundle presentationBundle = null);    Task&lt;TResult&gt; Navigate&lt;TResult&gt;(IMvxViewModelResult&lt;TResult&gt; viewModel, IMvxBundle presentationBundle = null, CancellationToken cancellationToken = default(CancellationToken));    Task&lt;TResult&gt; Navigate&lt;TParameter, TResult&gt;(IMvxViewModel&lt;TParameter, TResult&gt; viewModel, TParameter param, IMvxBundle presentationBundle = null, CancellationToken cancellationToken = default(CancellationToken));    Task Navigate(Type viewModelType, IMvxBundle presentationBundle = null);    Task Navigate&lt;TParameter&gt;(Type viewModelType, TParameter param, IMvxBundle presentationBundle = null);    Task&lt;TResult&gt; Navigate&lt;TResult&gt;(Type viewModelType, IMvxBundle presentationBundle = null, CancellationToken cancellationToken = default(CancellationToken));    Task&lt;TResult&gt; Navigate&lt;TParameter, TResult&gt;(Type viewModelType, TParameter param, IMvxBundle presentationBundle = null, CancellationToken cancellationToken = default(CancellationToken));    Task Navigate(string path, IMvxBundle presentationBundle = null);    Task Navigate&lt;TParameter&gt;(string path, TParameter param, IMvxBundle presentationBundle = null);    Task&lt;TResult&gt; Navigate&lt;TResult&gt;(string path, IMvxBundle presentationBundle = null, CancellationToken cancellationToken = default(CancellationToken));    Task&lt;TResult&gt; Navigate&lt;TParameter, TResult&gt;(string path, TParameter param, IMvxBundle presentationBundle = null, CancellationToken cancellationToken = default(CancellationToken));    Task&lt;bool&gt; CanNavigate(string path);    Task&lt;bool&gt; Close(IMvxViewModel viewModel);    Task&lt;bool&gt; Close&lt;TResult&gt;(IMvxViewModelResult&lt;TResult&gt; viewModel, TResult result);    bool ChangePresentation(MvxPresentationHint hint);}Some extension methods make it easier to use your already existing code:public static class MvxNavigationExtensions{    public static Task&lt;bool&gt; CanNavigate(this IMvxNavigationService navigationService, Uri path)    public static Task Navigate(this IMvxNavigationService navigationService, Uri path, IMvxBundle presentationBundle = null)    public static Task Navigate&lt;TParameter&gt;(this IMvxNavigationService navigationService, Uri path, TParameter param, IMvxBundle presentationBundle = null)    public static Task Navigate&lt;TResult&gt;(this IMvxNavigationService navigationService, Uri path, IMvxBundle presentationBundle = null, CancellationToken cancellationToken = default(CancellationToken))    public static Task Navigate&lt;TParameter, TResult&gt;(this IMvxNavigationService navigationService, Uri path, TParameter param, IMvxBundle presentationBundle = null, CancellationToken cancellationToken = default(CancellationToken))    public static Task Navigate&lt;TViewModel&gt;(this IMvxNavigationService navigationService, IMvxBundle presentationBundle = null) where TViewModel : IMvxViewModel    public static Task Navigate&lt;TViewModel, TParameter&gt;(this IMvxNavigationService navigationService, TParameter param, IMvxBundle presentationBundle = null) where TViewModel : IMvxViewModel&lt;TParameter&gt;    public static Task&lt;TResult&gt; Navigate&lt;TViewModel, TResult&gt;(this IMvxNavigationService navigationService, IMvxBundle presentationBundle = null, CancellationToken cancellationToken = default(CancellationToken)) where TViewModel : IMvxViewModelResult&lt;TResult&gt;    public static Task&lt;TResult&gt; Navigate&lt;TViewModel, TParameter, TResult&gt;(this IMvxNavigationService navigationService, TParameter param, IMvxBundle presentationBundle = null, CancellationToken cancellationToken = default(CancellationToken)) where TViewModel : IMvxViewModel&lt;TParameter, TResult&gt;}In your ViewModel this could look like:public class MyViewModel : MvxViewModel{    private readonly IMvxNavigationService _navigationService;    public MyViewModel(IMvxNavigationService navigationService)    {        _navigationService = navigationService;    }        public override void Prepare()    {        //Do anything before navigating to the view    }    public async Task SomeMethod()    {        await _navigationService.Navigate&lt;NextViewModel, MyObject&gt;(new MyObject());    }}public class NextViewModel : MvxViewModel&lt;MyObject&gt;{    public override void Prepare(MyObject parameter)    {        //Do anything before navigating to the view        //Save the parameter to a property if you want to use it later    }        public override async Task Initialize()    {        //Do heavy work and data loading here    }}When you want to return a result to the place where you navigated from you can do:public class MyViewModel : MvxViewModel{    private readonly IMvxNavigationService _navigationService;    public MyViewModel(IMvxNavigationService navigation)    {        _navigationService = navigationService;    }        public override async Task Initialize()    {        //Do heavy work and data loading here    }    public async Task SomeMethod()    {        var result = await _navigationService.Navigate&lt;NextViewModel, MyObject, MyReturnObject&gt;(new MyObject());        //Do something with the result MyReturnObject that you get back    }}public class NextViewModel : MvxViewModel&lt;MyObject, MyReturnObject&gt;{    private readonly IMvxNavigationService _navigationService;    public MyViewModel(IMvxNavigationService navigation)    {        _navigationService = navigationService;    }        public override void Prepare(MyObject parameter)    {        //Do anything before navigating to the view        //Save the parameter to a property if you want to use it later    }        public override async Task Initialize()    {        //Do heavy work and data loading here    }        public async Task SomeMethodToClose()    {        await _navigationService.Close(this, new MyReturnObject());    }}You can provide a CancellationToken to abort waiting for a Result. This will close the ViewModel and cancel the Task.If you have a BaseViewModel you might not be able to inherit MvxViewModel&lt;TParameter&gt; or MvxViewModel&lt;TParameter, TResult&gt; because you already have the BaseViewModel as base class. In this case you can implement the following interface:IMvxViewModel&lt;TParameter&gt;, IMvxViewModelResult&lt;TResult&gt; or IMvxViewModel&lt;TParameter, TResult&gt;To implement returning your own result add the following to your (Base)ViewModel:public override TaskCompletionSource&lt;object&gt; CloseCompletionSource { get; set; }public override void ViewDestroy(){    if (CloseCompletionSource != null &amp;&amp; !CloseCompletionSource.Task.IsCompleted &amp;&amp; !CloseCompletionSource.Task.IsFaulted)        CloseCompletionSource?.TrySetCanceled();    base.ViewDestroy();}To check if you are able to navigate to a certain ViewModel you can use the CanNavigate method.if (Mvx.Resolve&lt;IMvxNavigationService&gt;().CanNavigate&lt;NextViewModel&gt;()){    //Do something}If you want to intercept ViewModel navigation changes you can hook into the events of the NavigationService.Mvx.Resolve&lt;IMvxNavigationService&gt;().AfterClose += (object sender, NavigateEventArgs e) =&gt; {    //Do something with e.ViewModel};The events available are:  BeforeNavigate  AfterNavigate  BeforeClose  AfterCloseYou might be using Init() or Start() methods in your ViewModels when updating from MvvmCross 4.x. This is now deprecated because it was done using reflection and therefor not very safe. With the new navigation a method called Task Initialize() will be called. This method is typed and async.Uri navigationThe Uri navigation of the NavigationService will build the navigation stack if required. This will also enable deeplinking and building up the navigationstack for it. Every ViewModel added to the stack can split up into multiple paths of it’s own backstack. This will enable all kinds of layout structures as Hamburger, Tab or Top navigation.The NavigationService supports multiple URIs per ViewModel as well as “NavigationFacades” that return the right ViewModel + parameters depending on the URI.The solution is composed of:  Navigation Attribute (ViewModel/Facade, URI regex)  NavigationFacades are constructed via Mvx.IocConstruct to profit from dependency injection  NavigationService, registered as a singleton, uses IMvxViewDispatcher to show the viewmodels  Necessary additions to Android (Activity.OnNewIntent) + iOS (AppDelegate.OpenUrl) (look a the example project for more infos)You can also use this solution for triggering deeplink from outside the app:Register a custom scheme (i.e. “foo”) in our app (look a the example project for me info)Push-Messages: Depending on the status of the app you can pass a uri as the Notification Parameter, so when the app starts you can deep link directly to the view you want.Supply your routings as assembly attributes. We would recommend putting them in the same file as the referenced ViewModel.[assembly: MvxNavigation(typeof(ViewModelA), @\"mvx://test/\\?id=(?&lt;id&gt;[A-Z0-9]{32})$\")]namespace *.ViewModels{    public class ViewModelA        : MvxViewModel    {    \tpublic void Init(string id) // you can use captured groups defined in the regex as parameters here        {        }    }}Routing in a ViewModel.public class MainViewModel : MvxViewModel{    private readonly IMvxNavigationService _navigationService;    public MainViewModel(IMvxNavigationService navigationService)    {        _navigationService = navigationService;    }    private IMvxAsyncCommand _showACommand;    public IMvxAsyncCommand ShowACommand    {        get        {            return _showACommand ?? (_showACommand = new MvxAsyncCommand(async () =&gt;            {                await _navigationService.Navigate(\"mvx://test/?id=\" + Guid.NewGuid().ToString(\"N\"));            }));        }    }}FacadesSay you are building a task app and depending on the type of task you want to show a different view. This is where NavigationFacades come in handy (there is only so much regular expressions can do for you).mvx://task/?id=00000000000000000000000000000000 &lt;– this task is done, show read-only view (ViewModelA) mvx://task/?id=00000000000000000000000000000001 &lt;– this task isn’t, go straight to edit view (ViewModelB)[assembly: MvxRouting(typeof(SimpleNavigationFacade), @\"mvx://task/\\?id=(?&lt;id&gt;[A-Z0-9]{32})$\")]namespace *.NavigationFacades{\tpublic class SimpleNavigationFacade\t    : IMvxNavigationFacade\t{\t    public Task&lt;MvxViewModelRequest&gt; BuildViewModelRequest(string url,\t        IDictionary&lt;string, string&gt; currentParameters, MvxRequestedBy requestedBy)\t    {\t    \t// you can load data from a database etc.\t    \t// try not to do a lot of work here, as the user is waiting for the UI to do something ;)\t        var viewModelType = currentParameters[\"id\"] == Guid.Empty.ToString(\"N\") ? typeof(ViewModelA) : typeof(ViewModelB);\t        return Task.FromResult(new MvxViewModelRequest(viewModelType, new MvxBundle(), null, requestedBy));\t    }\t}}Upgrading from 4.x to 5.xTo make sure your navigation stays up-to-date change all your ShowViewModel&lt;&gt;() calls to the new navigation methods.Example before:private IMvxCommand _navigateCommand;public IMvxCommand NavigateCommand{    get    {        _navigateCommand = _navigateCommand ?? new MvxCommand(() =&gt; ShowViewModel&lt;TViewModel&gt;());        return _navigateCommand;    }}After:private IMvxAsyncCommand _navigateCommand;public IMvxAsyncCommand NavigateCommand{    get    {        _navigateCommand = _navigateCommand ?? new MvxAsyncCommand(() =&gt; _navigationService.Navigate&lt;TViewModel&gt;());        return _navigateCommand;    }}MvvmCross 4.x navigationSimple ViewModel navigationTo navigate from a ViewModel to another ViewModel you can use ShowViewModel command.The ShowViewModel command will take a Generic type which should represent the ViewModel that you want to navigate to.ShowViewModel&lt;TViewModel&gt;();If we want to for example navigate to the DetailViewModel we only have to call the command from within another ViewModel.ShowViewModel&lt;DetailViewModel&gt;();To move back to the previous ViewModel we can call Close(this); on the ViewModel that we want to close.Navigation with parameters - using a complex parameter objectEvery object can be passed to another ViewModel as a parameter. If its is desired to pass data along in the form of a more complex parameter it can be done like so:ShowViewModel&lt;TViewModel, TParameter&gt;(new TParameter());To be able to retrieve this the receiving class should implement the expected parameter on a class level and implement the correct init:public class MyViewModel : MvxViewModel&lt;TParameter&gt;{    protected override Task Init(TParameter parameter)    {        // use the parameters here    }}If you have a BaseViewModel you might not be able to inherit MvxViewModel&lt;TParameter&gt; because you already have the BaseViewModel as base class. In this case you can implement the following interface:IMvxViewModel&lt;TParameter&gt;MvvmCross uses JSON to serialize the object and to use complex parameters you should have the MvvmCross Json plugin installed or register your own IMvxJsonConverter.Navigation with parameters - using a simple parameter objectAs you write apps, you may frequently find that you want to parameterize a ViewModel navigation.For example, you may encounter List-Detail situations - where:  The Master view shows a list of items.  When the user selects one of these, then the app will navigate to a Detail view  The Detail view will then shows that specific selected item.To achieve this, the navigation from MasterViewModel to DetailViewModel will normally be achieved by:  we declare a class DetailParameters for the navigation:public class DetailParameters{    public int Index {        get;        set;    }}  the MasterViewModel makes ShowViewModel a call like:ShowViewModel&lt;DetailViewModel&gt;(new DetailParameters() { Index = 2 });  the DetailViewModel declares an Init method in order to receive this DetailParameters:public void Init(DetailParameters parameters){    // use the parameters here}Note that the DetailParameters class used here must be a ‘simple’ class used only for these navigations:  it must contain a parameterless constructor  it should contain only public properties with both get and set access  these properties should be only of types:          bool      Integral types: sbyte, short, int, long, byte, ushort, uint, ulong      Floating-point types: float, double      decimal      char      string      DateTime      Guid      Enumeration values      Navigation with parameters - using an anonymous parameter objectFor simple navigations, declaring a formal Parameters object can feel like ‘overkill’ - like ‘hard work’.In these situations you can instead use anonymous classes and named method arguments.For example, you can:  use a call to ShowViewModel like:ShowViewModel&lt;DetailViewModel&gt;(new { index = 2 });  in the DetailViewModel declare an Init method in order to receive this index as:public void Init(int index){    // use the index here}Note that due to serialization requirements, the only available parameter types used within this technique are only:  bool  Integral types: sbyte, short, int, long, byte, ushort, uint, ulong  Floating-point types: float, double  decimal  char  string  DateTime  Guid  Enumeration values",
            "url": "/documentation/fundamentals/navigation"
          }
          ,
        
          "documentation-fundamentals-portable-class-library-pcl" :{
            "title": "Portable Class Library (PCL)",
            "content": "Why PCL and not Shared Project?With C# Views it is possible to write the MvvM either as a PCL or as a shared project. It is not possible to do that with XAML, you must use a PCL. You might think that this would be a disadvantage because in C# shared projects you can use “#ifdef” statements to conditionally compile code dependent on target platform. Thus you might reason that this would make maintaining and understanding the coding more productive.However Xamarin PCL achieves a similar outcome using a class known as the Device. This class although part of the Portable Class Library has methods that return different values depending on the native platform your App is installed on.The Device static class is available in both C# and XAML coding if you know how to use it.In our opinion then, the MvvM should always be coded in a PCL. In a later example though we will demonstrate how a solution based on PCL can also make use of a shared project to native platform interfacing.Examples of Device function usage:      Device.OS returns an enum so you know what Operating system you are on. enum TargetPlatform {Other, iOS, Android, WinPhone, Windows}        Device.OnPlatform this allows you to choose an appropriate value dependent on platform. This function can be used directly in XAML coding whereas most Device functions will require you to interface to CSharp to access.        Device.Idiom another enum that will tell you if you are on a Tablet or a Phone.        Device.GetNamedSize used for getting fonts using device relative sizing.  With the exception of OnPlatform these static functions cannot be used directly in XAML. However you can write a small static class and then use them in XAML Resource dictionaries. We should demonstrate this later.Shared Project though can be useful when writing platform level code that needs to be varied slightly depending on the target platform. For example if you need to create a file to hold a database or a secret each OS has a different file system location for that, and if you need to apply encryption while the device is code locked to protect a secret and exposure via Jailbreaking, again each OS is different. But all platforms can be coded in a shared project including “#ifdef” sections where the platforms differ. This makes the code more maintainable because you can then see all of your platforms at once.Again we should demonstrate this later.",
            "url": "/documentation/fundamentals/portable-class-library-pcl"
          }
          ,
        
          "documentation-fundamentals-value-combiners" :{
            "title": "Value combiners",
            "content": "ValueCombinersTibet binding (see wiki/Databinding) introduced a new interface into binding - IMvxValueCombiner - this interface allows multiple binding sources to be combined together within a single target expression. This interface is used in, for example, the MvxFormatValueCombiner in order to enable binding expressions like:     local:MvxBind=\"Text Format('{0} {1} {2}', Greeting(Gender), FirstName, LastName)\"The rules and mechanisms for registering ValueCombiners are similar to those for registering ValueConverters. However, because combiners are not commonly declared in user code, MvvmCross doesn’t current perform a Reflection sweep across your Core or UI assemblies. If you do want to add is used by default on the , then a ValueCombiner class named FooValueCombiner will be registered under the name Foo.Please be aware that withing the MvvmCross Tibet binding syntax, ValueCombiners and ValueConverters share the same ‘registered name’ space - because both of them are expressed as ‘functions’ then it’s impossible to have both a Foo ValueConverter and a Foo ValueCombiner - if both are registered then the ValueConverter will always be used rather than the ValueCombiner.The API for IMvxValueCombiner is significantly more complicated than IMvxValueConverter at present and it’s tied to ImvxSubStep - which is part of the internal structure of the MvvmCross binding evaluation engine.public interface IMvxValueCombiner{    Type SourceType(IEnumerable&lt;IMvxSourceStep&gt; steps);    void SetValue(IEnumerable&lt;IMvxSourceStep&gt; steps, object value);    bool TryGetValue(IEnumerable&lt;IMvxSourceStep&gt; steps, out object value);    IEnumerable&lt;Type&gt; SubStepTargetTypes(IEnumerable&lt;IMvxSourceStep&gt; subSteps, Type overallTargetType);}To assist with authoring ValueCombiners, a number of helper classes are available including the base MvxValueCombiner class which provides default implementations for all methods in the interface.An example ValueCombiner which counts the number of non-null inputs bound to it might be:public class CountingValueCombiner    : MvxValueCombiner{    public override Type SourceType (IEnumerable&lt;IMvxSourceStep&gt; steps)    {        return typeof(int);    }    public override System.Boolean TryGetValue (IEnumerable&lt;IMvxSourceStep&gt; steps, out Object value)    {        var count = 0;        foreach (var input in steps)        {            object innerResult;            if (!input.TryGetValue (out innerResult))            {                // one of our input bindings is missing so we can't work out our answer                value = null;                return false;            }            if (innerResult != null)                count++;        }        value = count;        return true;    }}This could be used in a binding to count (for example) how many peoples have been picked for a band:local:MvxBind=\"Text Counting(Guitarist, Drummer, Bass, Vocalist)\"Note that it’s unusual for a ValueCombiner to meaningfully implement SetValue - this is because it’s unusual (but not unheard of) for multi-bindings to support updating of the multiple source elements from changes in the View.Developers are very welcome to write their own ValueCombiners if they wish to - please do - but please also be aware that it’s likely that this internal IMvxValueCombiner API will change in future MvvmCross revisions - we are looking at ways to either simplify this Tibet binding interface and/or ways to make the binding structure more Type-aware so that conversions can be performed at more places within the binding engine. (Developers are also very welcome to suggest improvements for this API!)Available ValueCombinersThe ‘standard’ ValueCombiners available in MvvmCross are:      If - used for if-else conditional display with syntax      If(boolean-test, value-if-true, value-if-false)        For example:      If(HasProAccount, ExtendedName, PromotionalMessage)            Format - used for displaying strings using the standard C# CLR string.Format syntax.      Format(format-string, input-arguments...)        For example:      Format(\"{0:ddMMMyyyy} - {1} - {2:0.000}\", Entry.Date, Entry.Location, Entry.Reading)            And and Or - used for logical combinations. Also available as operators - &amp;&amp; and ||      And(test-one, test-two, ...)  test-one &amp;&amp; test-two  Or(test-one, test-two, ...)  test-one || test-two        For example:      And(HasProAccount, HasCreditCardDetails)  HasProAccount &amp;&amp; HasCreditCardDetails            Add - used for concatenation or addition - works with string, int, double Types (other input types may be accepted, but will be converted to one of these types). Also available as the + operator      Add(item-one, item-two, ...)   item-one + item-two        For example:       Add(SubTotal, Tax)   FirstName + ' ' + LastName            To be continued… Subtract, Multiply, Divide, Modulus, etc        To be continued… GreaterThan, EqualTo, LessThan, GreaterThanOrEqualTo, LessThanOrEqualTo etc        To be continued… RGB from the Color plugin  ",
            "url": "/documentation/fundamentals/value-combiners"
          }
          ,
        
          "documentation-fundamentals-value-converters" :{
            "title": "Value converters",
            "content": "Value Converters in MvvmCross are used to provide mappings to/from logical values in the view models and presented values in the user interface.A Value Converter is any class which implements the IMvxValueConverter interfaceThe IMvxValueConverter interface provides:  a Convert method - for changing ViewModel values into View values  a ConvertBack method - for changing View values into ViewModel valuespublic interface IMvxValueConverter{    object Convert(object value, Type targetType, object parameter, CultureInfo culture);    object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);}For value converters which are used with non-editable UI fields (e.g. labels, images, etc), it is very common for Value Converters to implement only the Convert method - with the ConvertBack left as throw new NotImplementedException();Within MvvmCross, we try to encourage the use of cross-platform value converters wherever possible - but it is also possible and straight-forward to implement platform specific value converters.Note: this article assumes the reader has an understanding already of MvvmCross data-binding syntax - see wiki/DatabindingValueConverter SamplesFor several good ValueConverter samples, including Strings, Dates, Colors, Visibility and Two-Way conversion, please see:  Value Conversion sample - https://github.com/slodge/MvvmCross-Tutorials/tree/master/ValueConversion  N+1 Video - http://slodge.blogspot.ca/2013/04/n4-valueconverters-n1-days-of-mvvmcross.htmlA first ValueConverterTo implement a ValueConverter from the ‘raw interface’ you could implement something like:public class PlusOneValueConverter : IMvxValueConverter{    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)    {        return ((int)value) + 1;    }    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)    {        return ((int)value) - 1;    }}Notice how this ‘raw’ value converter provides you with object-level input parameters and output values.Using the MvxValueConverter&lt;TFrom,TTo&gt; helperWhile allowing you the maximum flexibility, the object level IMvxValueConverter is a little tedious to work with - it always requires you to cast your input value to the expected type and it requires you to declare both Convert and ConvertBack functions.In many cases, the MvxValueConverter&lt;TFrom, TTo&gt; helper class can do this casting and can also provide default placeholder NotImplemented methods for you.For example, a value converter for converting DateTimes in the ViewModel to ‘time ago’ strings in the View might look like:public class MyTimeAgoValueConverter : MvxValueConverter&lt;DateTime, string&gt;{    protected override string Convert(DateTime value, Type targetType, object parameter, CultureInfo cultureInfo)    {        var timeAgo = DateTime.UtcNow - value;        if (timeAgo.TotalSeconds &lt; 30)        {            return \"just now\";        }        if (timeAgo.TotalMinutes &lt; 10)        {            return \"a few minutes ago\";        }        if (timeAgo.TotalMinutes &lt; 60)        {            return \"in the last hour\";        }        if (timeAgo.TotalMinutes &lt; 24*60)        {            return \"in the last day\";        }        return \"previously\";    }}Note:  this class doesn’t need to provide a ConvertBack override - but can if you need it to.  there is also a less frequently used MvxValueConverter&lt;TFrom&gt; helper class which is equivalent to MvxValueConverter&lt;TFrom, object&gt;Using the TargetType, CultureInfo, and Parameter argumentsThe Type targetType parameter provides you with an indication of the type expected as the output of each call to the Convert or ConvertBack method. This isn’t generally that useful when writing application specific value converters, but can be useful if you are writing general purpose value converters which you expect to be reused in a wide range of scenarios.The CultureInfo cultureInfo parameter provides you with the culture used in the UI. Within MvvmCross binding this is always the current value of System.Globalization.CultureInfo.CurrentUICultureThe object parameter parameter is a general purpose field which you can use in your binding declarations. For example:      you might choose to use a binding in Droid like:    local:MvxBind=\"Value Power(CurrentValue, 2)\"        or:    local:MvxBind=\"Value CurrentValue, Converter=Power, ConverterParameter=2\"        Both of these would result in the Power ValueConverter being passed a parameter value of long 2.        you might choose to use a binding in iOS like:      set.Bind(label).For(l =&gt; l.Text).To(vm =&gt; vm.FullName).WithConversion(\"AbbreviateIfLongerThan\", 12L);        or:     set.Bind(label).Described(\"Text AbbreviateIfLongerThan(FullName, 12)\");        Both of these would result in the AbbreviateIfLongerThan ValueConverter being called with parameter of long 12  Note that the only types that are used when parameters are parsed from text binding descriptions are: long, double, bool or string (for more on the binding parsing engine, see wiki/Databinding)Referencing Value Converters in iOS and DroidData-Binding syntax including how to specify ValueConverters using Swiss, Fluent and Tibet binding is discussed in wiki/Databinding. This covers all syntax including:      Swiss      local:MvxBind=\"Value CurrentValue, Converter=Power, ConverterParameter=2\"            Tibet      local:MvxBind=\"Value Power(CurrentValue, 2)\"            Fluent      set.Bind(field)     .For(l =&gt; l.Value)     .To(vm =&gt; vm.CurrentValue)     .WithConversion(\"Power\", 2);      Within this syntax, ValueConverters are generally referred to by a name - e.g. PowerTo find the specified ValueConverter, MvvmCross maintains a registry of ValueConverter instances indexed by name.Typically, this registry is created using a one-pass Reflection sweep on your application’s Core and UI (platform-specific) projects. This sweep:  locates all instantiable classes which implement IMvxValueConverter within your assemblies  creates an instance of each one  registers the instance with the name stripped of any Mvx prefix and any ValueConverter or Converter postfix.So, for example, the following class names will all be registered with the same ValueConverter name of “Foo”:  Foo  FooValueConverter  FooConverter  MvxFooValueConverter  MvxFooConverterWhere multiple classes with the same ValueConverter name are encountered, then the last one found will be the one which remains registered.To prevent value converter classes being registered during this reflection sweep, you can use the [MvxUnconventional] attribute on the ValueConverter class.To include additional assemblies in the ValueConverter reflection sweep, you can do this in your Setup class using an override of the protected virtual List&lt;Assembly&gt; ValueConverterAssemblies { get; } property - e.g.:protected override List&lt;Assembly&gt; ValueConverterAssemblies{    get    {        var toReturn = base.ValueConverterAssemblies;        toReturn.Add(typeof(SomeValueConverter).Assembly);        return toReturn;    }}To manually register additional value converters, you can do this in your Setup class using an override of the FillValueConverters method - e.g.protected override FillValueConverters (IMvxValueConverterRegistry registry){    base.FillValueConverters(registry);    registry.AddOrOverwrite(\"CustomName\", new MyVerySpecialValueConverter(42));    registry.AddOrOverwrite(\"CustomName2\", new AnotherVerySpecialValueConverter(\"Summer\"));}Finally, ValueConverters can also be registered using a technique called “ValueConverter holders”. This technique uses Reflection against individual Types which then hold ValueConverters in public instance or static fields. This technique was common in earlier MvvmCross versions, but is not recommended within v3 - it’s kept only for backwards compatibility.Preventing the ValueConverter Reflection Sweeps in iOS and DroidThe ValueConverter sweeps do use a small amount of Reflection and so can add a very small amount of lag to application start time. If you’d prefer to minimize this small startup lag in your application, then you can, of course, disable the sweeps and can use direct registration instead.To do this, override the FillValueConverters method in your Setup class, do not call the base class method and instead use just register your own value converters - e.g.protected override FillValueConverters (IMvxValueConverterRegistry registry){    // avoid the reflection overhead - do not call base class    // base.FillValueConverters(registry);    registry.AddOrOverwrite(\"Foo\", new FooValueConverter());    registry.AddOrOverwrite(\"Bar\", new BarValueConverter());}Note: unless your application is very large, this is most likely only a micro-optimization and will most likely not significantly change your app’s startup time.Using Value Converters in Windows (conventional Xaml binding)The IMvxValueConverter interface is closely based on the IValueConverter interface used in Windows WPF and Silverlight Xaml binding. This interface is also similar (but slightly different) to the IValueConverter interface used in Windows WinRT Xaml binding.Because these Xaml IValueConverter interfaces are not 100% identical to each other, nor to the IMvxValueConverter version, shared Mvx ValueConverters cannot be used directly in Windows Xaml binding - they must instead be wrapped for use in Xaml.The steps to do this are similar on each Windows platform:  for each IMvxValueConverter class, e.g. forpublic class TheTruthValueConverter    : MvxValueConverter&lt;bool, string&gt;{    public string Convert(bool value, Type targetType, CultureInfo cultureInfo, object parameter)    {        return value ? \"Yay\" : \"Nay\";    }}  in your UI project, create a ‘native’ wrapper using the MvxNativeValueConverter class:public class TheNativeTruthValueConverter    : MvxNativeValueConverter&lt;TheTruthValueConverter&gt;{}  in your Xaml, include an instance of your ValueConverter as a static resource - this can be done in the Resources at App, Page or Control Xaml level, e.g.:       &lt;converters:TheNativeTruthValueConverter x:Key=\"TheTruth\" /&gt;  now your converter can be used - e.g.:       &lt;TextBlock Text=\"{Binding HasAccepted, Converter={StaticResource TheTruth}}\" /&gt;Using Value Converters in Windows (Tibet binding)In addition to ‘traditional’ Xaml bindings, MvvmCross also allows ‘Tibet’ binding within Windows - for more on this see wiki/Databinding.When Tibet binding is used, then Value Converters can be accessed by name - exactly as in Droid and iOS binding - without the above native Xaml wrapping.Further, if using ‘Tibet’ binding then an entire assembly’s worth of value converters can be registered using the Reflection sweep technique and this can be specified at the Xaml level - meaning it can be used in both design and run-time.To include all value converters within an Assembly at the Xaml level, then use an mvx:Import block with an inner From attribute which contains an instance of a class from that Assembly.This may sound complicated… but actually it is quite simple.  Suppose you have an Assembly MyTools containing FooValueConverter, BarValueConverter, etc  Within this Assembly add a simple, instantiable public Class which we will use only for the import - e.g. public class MarkerClass {}  Then within the xaml, you can include a static resource import block like:\t     &lt;mvx:Import x:Key=\"MvxAssemblyImport0\"&gt;\t       &lt;mvx:Import.From&gt;\t         &lt;myTools:MarkerClass /&gt;\t       &lt;mvx:Import.From&gt;\t     &lt;/mvx:Import&gt;  After this is done, then the ValueConverters Foo and Bar will be available for use within ‘Tibet’ bindings - e.g. as:     \t &lt;TextBlock mvx:Bi.nd=\"Text Foo(Name)\" /&gt;Using platform-specific Value ConvertersMost of the discussions so far have assumed that ValueConverters are placed in shared PCL code and are shared between platforms.Beyond this, ValueConverters can also of course be used within UI projects for platform specific functionality. This is seen particularly often for things like loading images and resources or for performing platform specific layout adjustments.The Mvx Visibility ValueConvertersThe Visibility plugin contains a couple of simple value converters which assist with Visibility on each platform.These are MvxVisibilityValueConverter and MvxInvertedVisibilityValueConverter registered under the names “Visibility” and “InvertedVisibility”.On each platform, these allow ViewModel properties to be mapped to ui visibility properties. The basic logic of the Visibility test catches many common cases:  string - any non-null non-empty string is visible  int or double - any &gt;0 value is visible  bool - a true value is visible  any other Type - a non-null value is visibleThe logic of the “InvertedVisibility” is the inverse of this.If you require other visibility logic - e.g. if you need a mapping for a nullable&lt;float&gt; to Visibility on each platform, then you can easily implement your own Visibility ValueConverter using the MvxBaseVisibilityValueConverter base class.To use these converters on each platform, use:      Droid (not that in Droid there is no support for the Invisible state - cross platform, we only support Visible and Gone):      local:MvxBind=\"Visibility Visibility(VMProperty)\"            iOS:      set.Bind(field)     .For(\"Visibility\")     .To(vm =&gt; vm.VMProperty)     .WithConversion(\"Visibility\");            Windows - use Native wrappers or Tibet Binding as described above:      Visibility=\"{Binding VMProperty, Converter={StaticResource Visibility}}\"        or:      mvx:Bi.nd=\"Visibility Visibility(VMProperty)\"      Note: to use the Visibility converters at design-time on the Windows platforms, you can include the design-time helper objects - MvxVisibilityDesignTimeHelper - these can be used as:    &lt;visibility:MvxVisibilityDesignTimeHelper x:Key=\"DesignTimeVisibility\" /&gt;If you need to create your own Visibility ValueConverter’s then the MvxBaseVisibilityValueConverter&lt;T&gt; and MvxBaseVisibilityValueConverter base classes can assist with this - e.g.:public class SayPleaseVisibilityValueConverter : MvxBaseVisibilityValueConverter&lt;string&gt;{    protected override MvxVisibility Convert(string value, object parameter, CultureInfo culture)    {        return (value == \"Please) ? MvxVisibility.Visible : MvxVisibility.Collapsed;    }}Note: In addition to the Visibility properties that are available on all UIElements within Xaml, MvvmCross also provides a Visible custom binding - allowing ViewModel properties of type Boolean to be bound directly to the UI visibility without using the VisibilityConverter - e.g.:    mvx:Bi.nd=\"Visible VMProperty\"The Mvx Color ValueConvertersThe Color plugin contains a couple of simple value converters which assist with MvxColor on each platform.These are:  MvxNativeColorValueConverter registered as “NativeColor” - this converts MvxColor properties on the ViewModel to a native color format.  MvxRGBAValueConverter registered as “RGBA” - this converts Hex ViewModel string properties like “RGB”, “RRGGBB” and “RRGGBBAA” with optional leading “#” characters into native color formats.  MvxRGBIntColorConverter registered under the name “RGBIntColor” - this converters int ViewModel properties into native color formats.The Color plugin also provides a base class - MvxColorValueConverter which you can inherit from in order to define your own cross-platform Color converters.On each platform, the native color format output from these converters is:  Windows - a SolidColorBrush for the appropriate Windows flavor  Droid - an Android.Graphics.Color  iOS - an UIKit.UIColorOn Droid, the Color plugin also includes a couple of custom bindings to assist with binding. These are:  TextView TextColor binding  View BackgroundColor bindingTo use Color on each platform - for example, with a ViewModel property public MvxColor CurrentColor { get; set; } you can use:      Droid:      local:MvxBind=\"BackgroundColor NativeColor(CurrentColor)\"            iOS:      set.Bind(field)     .For(field =&gt; field.BackgroundColor)     .To(vm =&gt; vm.CurrentColor)     .WithConversion(\"NativeColor\");            Windows - use Native wrappers or Tibet Binding as described above:      Fill=\"{Binding CurrentColor, Converter={StaticResource NativeColor}}\"        or:      mvx:Bi.nd=\"Fill NativeColor(CurrentColor)\"      Note: to use the Color converters at design-time on the Windows platforms, you can include the design-time helper objects - MvxColorDesignTimeHelper - these can be used as:    &lt;color:MvxColorDesignTimeHelper x:Key=\"DesignTimeColor\" /&gt;The Mvx Language ValueConverterThe MvvmCross internationalization (i18n) techniques are based on the JsonLocalisation plugin with TextSource properties in each ViewModel and with mvxLang binding attributes.Under the covers, these mvxLang bindings are actually just normal bindings which make use of the MvxLanguageValueConverter. This is automatically registered using the name Language.This consumes the TextSource as it’s value and the Key as its parameter.So a language binding: local:mvxLang='Text HelloWorld,TextSource=SharedTextSource'Is actually equivalent to a normal binding: local:mvxBind='Text SharedTextSource, Converter=Language, ConverterParameter=\"HelloWorld\", Mode=OneTime'Using internationalised text in your ValueConvertersEarlier we considered a MyTimeAgoValueConverter which returned strings like “just now” from it’s Convert implementation,If using the MvvmCross JsonLocalisation system, then that same value converter could be rewritten to make use of a IMvxTextProvider reference.For example, it could be rewritten:public class MyTimeAgoValueConverter : MvxValueConverter&lt;DateTime, string&gt;{    private IMvxTextProvider _textProvider;    private IMvxTextProvider TextProvider    {        get        {            _textProvider = _textProvider ?? Mvx.Resolve&lt;IMvxTextProvider&gt;();            return _textProvider;        }    }    protected override string Convert(DateTime value, Type targetType, CultureInfo culruteInfo, object parameter)    {        var timeAgo = DateTime.UtcNow - value;        var key = \"unknown\";        if (timeAgo.TotalSeconds &lt; 30)        {            key = \"just.now\";        }        else if (timeAgo.TotalMinutes &lt; 10)        {            key = \"a.few.minutes.ago\";        }        else if (timeAgo.TotalMinutes &lt; 60)        {            key = \"in.the.last.hour\";        }        else if (timeAgo.TotalMinutes &lt; 24*60)        {            key = \"in.the.last.day\";        }        else        {            key = \"previously\";        }        return TextProvider.GetText(Constants.GeneralNamespace, Constants.TimeAgoStrings, key)    }}Where Constants.TimeAgoStrings refers to JSON content loaded (for EN-US) as:{\t'unknown':'oops',\t'just.now':'just now',\t'a.few.minutes.ago':'a few minutes ago',\t'in.the.last.hour':'in the last hour',\t'in.the.last.day':'in the last day',\t'previously':'previously'}The Mvx CommandParameter ValueConverterMvvmCross v3 added a special CommandParameter parse step to allow the binding to specify fixed values (strings, longs, bools) to ICommand parameter bindings.This can be used as:    local:MvxBind=\"Click MyCommand,CommandParameter=Thursday\"which uses the MvxCommandParameterValueConverter ValueConverter to turn a Click into a call on:   MyCommand.Execute(\"Thursday\")So this can be received in the ViewModel as:   new MvxCommand(day =&gt; DoAction(day));This helps where you want to reuse a single ICommand implementation across multiple buttons.Please note that this cannot be used currently with other ValueConverters - as it itself uses a ValueConverter to achieve it’s effect.ValueConverters are evil?Some Mvvm commentators have been known to say “ValueConverters are evil”I’m not 100% sure why they’ve said this, but I believe the main reasons are based around:  concerns with people hiding too much application logic within ValueConverters  concerns with performance - especially in list situations where ValueConverters can be executed rapidly for every list item during scrolling.I personally suspect these concerns are valid - that there can be situations where putting the conversion functionality directly into the ViewModels rather than into the ValueConverters can make apps easier to understand and can help avoid performance issues. However, I also suspect that these concerns are over-stated. I can’t see any reason why a developer who makes use of value converters should be any more prone to architectural or performance problems than another deverloper who doesn’t. Indeed I’d suspect the reverse.In summary - ValueConverters are good - use them.ValueConverters and FallbackValuesWhen specifying a binding, you can also provide a FallbackValue - see wiki/Databinding. This FallbackValue is used within the View:  whenever the binding source path is missing - e.g. if you specify a Path of Child.Property and Child is currently null  whenever the value converter throws an exception during the Convert conversionNote that in ‘normal binding’ FallbackValues are not themselves passed through the ValueConverter. So, this conversion is not correct: local:MvxBind=\"Text Visibility(IsEnabled), FallbackValue=false\"If you do want to pass a FallbackValue through the Value Converter then you can do this using recursive binding syntax within the Tibet binding engine - e.g. local:MvxBind=\"Text Visibility((IsEnabled, FallbackValue=false))\"Tibet: ValueCombinersTibet binding (see wiki/Databinding) introduced a new interface into binding - IMvxValueCombiner - this interface allows multiple binding sources to be combined together within a single target expression. This interface is used in, for example, the MvxFormatValueCombiner in order to enable binding expressions like:     local:MvxBind=\"Text Format('{0} {1} {2}', Greeting(Gender), FirstName, LastName)\"The rules and mechanisms for registering ValueCombiners are similar to those for registering ValueConverters. However, because combiners are not commonly declared in user code, MvvmCross doesn’t current perform a Reflection sweep across your Core or UI assemblies. If you do want to add is used by default on the , then a ValueCombiner class named FooValueCombiner will be registered under the name Foo.Please be aware that withing the MvvmCross Tibet binding syntax, ValueCombiners and ValueConverters share the same ‘registered name’ space - because both of them are expressed as ‘functions’ then it’s impossible to have both a Foo ValueConverter and a Foo ValueCombiner - if both are registered then the ValueConverter will always be used rather than the ValueCombiner.The API for IMvxValueCombiner is significantly more complicated than IMvxValueConverter at present and it’s tied to ImvxSubStep - which is part of the internal structure of the MvvmCross binding evaluation engine.public interface IMvxValueCombiner{    Type SourceType(IEnumerable&lt;IMvxSourceStep&gt; steps);    void SetValue(IEnumerable&lt;IMvxSourceStep&gt; steps, object value);    bool TryGetValue(IEnumerable&lt;IMvxSourceStep&gt; steps, out object value);    IEnumerable&lt;Type&gt; SubStepTargetTypes(IEnumerable&lt;IMvxSourceStep&gt; subSteps, Type overallTargetType);}To assist with authoring ValueCombiners, a number of helper classes are available including the base MvxValueCombiner class which provides default implementations for all methods in the interface.An example ValueCombiner which counts the number of non-null inputs bound to it might be:public class CountingValueCombiner    : MvxValueCombiner{    public override Type SourceType (IEnumerable&lt;IMvxSourceStep&gt; steps)    {        return typeof(int);    }    public override System.Boolean TryGetValue (IEnumerable&lt;IMvxSourceStep&gt; steps, out Object value)    {        var count = 0;        foreach (var input in steps)        {            object innerResult;            if (!input.TryGetValue (out innerResult))            {                // one of our input bindings is missing so we can't work out our answer                value = null;                return false;            }            if (innerResult != null)                count++;        }        value = count;        return true;    }}This could be used in a binding to count (for example) how many peoples have been picked for a band:local:MvxBind=\"Text Counting(Guitarist, Drummer, Bass, Vocalist)\"Note that it’s unusual for a ValueCombiner to meaningfully implement SetValue - this is because it’s unusual (but not unheard of) for multi-bindings to support updating of the multiple source elements from changes in the View.Developers are very welcome to write their own ValueCombiners if they wish to - please do - but please also be aware that it’s likely that this internal IMvxValueCombiner API will change in future MvvmCross revisions - we are looking at ways to either simplify this Tibet binding interface and/or ways to make the binding structure more Type-aware so that conversions can be performed at more places within the binding engine. (Developers are also very welcome to suggest improvements for this API!)Available ValueCombinersTODO - this section is draft - a work in progress.The ‘standard’ ValueCombiners available in MvvmCross are:      If - used for if-else conditional display with syntax      If(boolean-test, value-if-true, value-if-false)        For example:      If(HasProAccount, ExtendedName, PromotionalMessage)            Format - used for displaying strings using the standard C# CLR string.Format syntax.      Format(format-string, input-arguments...)        For example:      Format(\"{0:ddMMMyyyy} - {1} - {2:0.000}\", Entry.Date, Entry.Location, Entry.Reading)            And and Or - used for logical combinations. Also available as operators - &amp;&amp; and ||      And(test-one, test-two, ...)  test-one &amp;&amp; test-two  Or(test-one, test-two, ...)  test-one || test-two        For example:      And(HasProAccount, HasCreditCardDetails)  HasProAccount &amp;&amp; HasCreditCardDetails            Add - used for concatenation or addition - works with string, int, double Types (other input types may be accepted, but will be converted to one of these types). Also available as the + operator      Add(item-one, item-two, ...)   item-one + item-two        For example:       Add(SubTotal, Tax)   FirstName + ' ' + LastName            To be continued… Subtract, Multiply, Divide, Modulus, etc        To be continued… GreaterThan, EqualTo, LessThan, GreaterThanOrEqualTo, LessThanOrEqualTo etc        To be continued… RGB from the Color plugin  ",
            "url": "/documentation/fundamentals/value-converters"
          }
          ,
        
          "documentation-fundamentals-viewmodel-lifecycle" :{
            "title": "ViewModel Lifecycle",
            "content": "MvvmCross 5.x ViewModels lifecycleAlongside a new Navigation Service, MvvmCross provides a new lifecycle for ViewModels with many enhancements such as async initialization. The current lifecycle includes:  Construction  InitializationAlso note that starting from MvvmCross 5.0 ViewModels will be coupled to the lifecycle of the view. This means that the ViewModel has the following methods available:void ViewCreated();void ViewAppearing();void ViewAppeared();void ViewDisappearing();void ViewDisappeared();void ViewDestroy();The MvxViewController, MvxFragment(s), MvxActivity and the UWP views will call those methods open the platform specific events that are fired. This will give us a more refined control of the ViewModel and the state of its lifecycle. There may be binding that you want to update or resources to clean up, these lifecycle events can help with that.It should be noted however that it is not 100% reliable but it should work for most of the apps. We don’t know what you do in the lifecycle of your app and what could interfere with the called order of the viewmodel lifecycle events.Mapping view event to viewmodel eventsThere has been a thread going on on the Xamarin forums where the implementation is discussed of this functionality. MvvmCross has based its lifecycle support on this thread and those events.                   Appearing      Appeared      Disappearing      Disappeared              iOS      ViewWillAppear      ViewDidAppear      ViewWillDisappear      ViewDidDisappear              Android      OnAttachedToWindow      OnGlobalLayout      OnPause      OnDetachedToWindow              UWP      Loading      OnLoaded      Unloaded      OnUnloaded      For more information on the implementation of this functionality please see GithubMvvmCross 4.x and 3.x ViewModels lifecycleViewModel CreationIn MvvmCross v3 - Hot Tuna - the default ViewModel location and construction was overhauled in order to provide 3 new features:  constructor based Dependency Injection  navigation using Typed navigation classes  saving and reloading VM state for ‘tombstoning’These changes were breaking changes for existing v1 and vNext apps, but provide significant testability and usability advantages for MvvmCross developers.How ViewModels are CreatedThe default ViewModelLocator builds new ViewModel instances using a 4-step process - CIRS:  Construction - using IoC for Dependency Injection  Init() - initialization of navigation parameters  ReloadState() - rehydration after tombstoning  Start() - called when initialization and rehydration are complete1 ConstructionIn MvvmCross, you can navigate to a ViewModel using parameter like:ShowViewModel&lt;DetailViewModel&gt;(     new     {        First=\"Hello\",        Second=\"World\",        Answer=42    });In older version of MvvmCross, these navigation parameters were passed to the constructor of the ViewModel.However, from v3 moving forwards, these navigation parameters are instead passed to the Init() method, and the constructor is now free to be used for Dependency Injection.This means that, for example, a DetailViewModel constructor might now look like:public class DetailViewModel : MvxViewModel{    private readonly IDetailRepository _repository;    public DetailViewModel(IDetailRepository repository)    {        _repository = repository;    }    // ...}This Dependency Injection is, of course, optional - your code can instead continue to use ServiceLocation if you prefer:public class DetailViewModel : MvxViewModel{    private readonly IDetailRepository _repository;    public DetailViewModel()    {        repository = Mvx.Resolve&lt;IDetailRepository&gt;();    }    // ...}2. Init()Now that the construction is used for Dependency Injection, the navigation parameters move to a new method - Init()Init() will always be called after construction and before ReloadState() and Start()Init() can come in several flavors:.  individual simply-Typed parameters  a single Typed parameter object with simply-Typed properties  as InitFromBundle() with an IMvxBundle parameter - this last flavor is always supported via the IMvxViewModel interface.You can declare zero or more of each of these types, but generally you will probably only want to use one within your application.So, for example, to support the navigation:RequestNavigate&lt;DetailViewModel&gt;(new { First=\"Hello\", Second=\"World\", Answer=42 });you could implement any of:public class DetailViewModel : MvxViewModel{    // ...        public void Init(string First, string Second, int Answer)    {        // use the values    }    // ...}or:public class DetailViewModel : MvxViewModel{    // ...        public class NavObject    {        public string First {get;set;}        public string Second {get;set;}        public int Answer {get;set;}    }        public void Init(NavObject navObject)    {    // use navObject    }        // ...}or:public class DetailViewModel : MvxViewModel{      // ...        public override void InitFromBundle(IMvxBundle bundle)    {        // use bundle - e.g. bundle.Data[\"First\"]    }        // ...}Note that multiple calls can be used together if required. This allows for some separation of logic in your code. However, the separate objects cannot share field names and generally this approach is confusing… so is not really recommended:public class DetailViewModel : MvxViewModel{    // ...        public class FirstNavObject    {        public string First {get;set;}        public string Second {get;set;}    }    public class SecondNavObject    {        public int Answer {get;set;}    }    public void Init(FirstNavObject firstNavObject)    {        // use firstNavObject    }    public void Init(SecondNavObject secondNavObject)    {        // use secondNavObject    }    // ...}3. ReloadStateIf the View/ViewModel is recovering from a Tombstoned state, then ReloadState will be called with the data needed for rehydration.If there is no saved state then no ReloadState() methods will be called.Exactly as with Init(), ReloadState can be called in several different ways.  individual simply-Typed parameters  a single Typed parameter object with simply-Typed properties  as ReloadStateFromBundle() using an IMvxBundle parameter - this last flavor is always supported via the IMvxViewModel interface.Normally, I’d expect this to be called as:public class DetailViewModel : MvxViewModel{    // ...        public class SavedState    {        public string Name {get;set;}        public int Position {get;set;}    }        public void ReloadState(SavedState savedState)    {        // use savedState    }    // ...}Aside: where does the SavedState come from?One of the new ViewModel APIs available in Hot Tuna is a SaveState pattern.This can be implemented in one of two ways:  using one or more paremeterless methods that return Typed state objects  using the override SavedStateToBundle(IMvxBundle bundle)Using a Typed state object:public class DetailViewModel : MvxViewModel{    // ...        public class SavedState    {        public string Name {get;set;}        public int Position {get;set;}    }    public SavedState SaveState()    {        return new SavedState()        {        Name = _name,        Position = _position        };    }    // ...}Using SavedStateToBundle:public class DetailViewModel : MvxViewModel{    // ...    protected override void SaveStateToBundle(IMvxBundle bundle)    {        bundle.Data[\"Name\"] = _name;        bundle.Data[\"Position\"] = _position.ToString();    }        // ...}4. Start()After all of Construction, Init, and ReloadState is complete, then the Start() method will be called.This method is simply:public class DetailViewModel : MvxViewModel{    // ...        public override void Start()    {        // do any start    }    // ...}Putting it all togetherFor a real app, I would expect the navigation, construction and state saving/loading code to actually look like:ShowViewModel&lt;DetailViewModel&gt;(    new DetailViewMode.NavObject    {        First = \"Hello\",        Second = \"World\",        Answer = 42    });andpublic class DetailViewModel : MvxViewModel{    public class SavedState    {        public string Name {get;set;}        public int Position {get;set;}    }        public class NavObject    {        public string First {get;set;}        public string Second {get;set;}        public int Answer {get;set;}    }    private readonly IDetailRepository _repository;        public DetailViewModel(IDetailRepository repository)    {        _repository = repository;    }    public void Init(NavObject navObject)    {        // use navObject    }        public void ReloadState(SavedState savedState)    {        // use savedState    }        public override void Start()    {        // do any start    }        public SavedState SaveState()    {        return new SavedState()        {        Name = _name,        Position = _position        };    }        // ...}Overriding CIRS.If you don’t like this CIRS (Construction-Init-ReloadState-Start) flow for building your ViewModels, then the good news is that you can easily override the ViewModelLocator within v3, just as you could within earlier MvvmCross versions. For more on this see LINK-TODOViewModel Deactivation, Activation and DestructionMonitoring other View/ViewModel lifecycle event across multiple platforms is fairly tricky, especially once developers start experimenting beyond the ‘basic’ presentation models and start using tabs, splitviews, popups, flyouts, etcFor most viewmodels, it’s common to not try to monitor other lifecyle events. This is OK since most viewmodels don’t perform any actions and don’t consume any resources when the view is not present - so these can just be left to be garbage collected when the system needs the memory back.For ViewModels which consume low-intensity resources - like timer ticks - then these can generally use the MvxMessenger to connect the ViewModel to those resources. This messenger uses weak referencing by default and itself sends out subscription change messages when clients subscribe/unsubscribe. Using this method, a developer can allow the background resources to monitor whether the viewmodels are in memory (and referenced by views) - and so the background resources can manage themselves.For those rare situations where resource monitoring is actively needed - e.g. for the SpheroViewModel which needs to maintain an active BlueTooth SPP channel - then it is possible to implement a custom interface on the ViewModel - e.g. IActiveViewModel - and this interface can be called from each of the views on each of the client platforms.Generally this involves being hooked up from ViewDidAppear/Disappear on iOS, OnNavigatedTo/From on Windows, and OnRestart/Pause on Android, although this may vary depending on the exact presentation of your views (eg whether they are whole pages, tabs, flyouts, etc).",
            "url": "/documentation/fundamentals/viewmodel-lifecycle"
          }
          
        
        ,
    
        
          "documentation-contribute-acknowledgements" :{
            "title": "Acknowledgements",
            "content": "Owners            who      contact                        Stuart Lodge@slodgeBlog                    Martijn van Dijk@mhvdijkBlog                    Tomasz Cielecki@CheesebaronBlog      And over 175 contributors!   Thanks everyone for their contributions!General  Thanks to McCannLondon for sponsoring the initial part of this work  Thanks to JetBrains for a community Resharper license to use on this project  Thanks to Infragistics for a control license for Nuclios and .Net",
            "url": "/documentation/contribute/acknowledgements"
          }
          ,
        
          "documentation-contribute-contribute" :{
            "title": "New contributions",
            "content": "Some of the best ways to contribute are to try things out, file bugs, and join conversations.  Pull requests: Open / Closed  Issues: Open / ClosedIf you would like to help make MvvmCross even better, then please do:  new code - including pull requests via GitHub - or you can fork the project and build your own extensions  new plugins - can be hosted in your own repositories  please do blog about your adventures with MvvmCross!  please suggest editions for the documentation files - we’re currently light on documentation!  if you use the framework, then please let us know - we love to see what people are doing with it",
            "url": "/documentation/contribute/contribute"
          }
          ,
        
          "documentation-contribute-mvvmcross-docs-style-guide" :{
            "title": "Style Guide",
            "content": "This document provides an overview of how articles published on docs.mvvmcross.com should be formatted. You can actually use this file, itself, as a template when contributing articles.Article StructureWe are using Jekyll for our documentation, which means that each page needs to have a YAML front matter, which would look something like:---layout: documentationtitle: Cool Docscategory: Some Category---Edit an existing documentation page, to find out what the current frontmatter looks like.Please reuse categories and make sure the name of the category is spelled the same and has same casing as in the menu. If you are creating a new category, please make a new folder for it and put your new document in there.Layout is always documentation, unless you are editing a page or blog post.There are no strict rules about documentation. However a few guidelines to keep in mind when writing documentation:  Keep titles an sentences, short and concise. For titles a maximum of 3 or 4 words is the optimal length.  Describe the topic in chronological order.  Do not stray from the topic being described too much.  Do your best at using punctuation and proper grammar.  Use a spelling checker.In the end contributions will be reviewed to iron out any issues.Documentation SyntaxThe documentation uses the same markdown as GitHub uses. Please refer to this markdown reference for information on how to format a post.Adding relative linksTo reference other pages inside the documentation use the following syntax:[Getting started](http://localhost:4000/documentation/getting-started/getting-started)Adding imagesPlease add any images for the documentation in the assets/docs folder. Then you can reference you image like:![My helpful screenshot](http://localhost:4000/assets/docs/screenshot.jpg)SummaryThis style guide is intended to help contributors quickly create new articles for mvvmcross.com. It includes the most common syntax elements that are used, as well as overall document organization guidance. If you discover mistakes or gaps in this guide, please submit an issue.",
            "url": "/documentation/contribute/mvvmcross-docs-style-guide"
          }
          
        
        ,
    
    
      "hello-world": {
        "title": "Hello World 0.1",
        "author": "",
        "category": "",
        "content": "Announcing MvvmCross 5.2!Hi guys, I just created a new place where we can meet, discuss and share our knowledge about our IT work.",
        "url": "/hello-world/"
      }
      ,
    
      "hello-python": {
        "title": "Hello Python 0.1",
        "author": "",
        "category": "",
        "content": "Announcing MvvmCross 5.2!Hi guys, I just created a new place where we can meet, discuss and share our knowledge about our IT work.",
        "url": "/hello-python/"
      }
      ,
    
      "hello-java": {
        "title": "Hello Java 0.1",
        "author": "",
        "category": "",
        "content": "Announcing MvvmCross 5.2!Hi guys, I just created a new place where we can meet, discuss and share our knowledge about our IT work.",
        "url": "/hello-java/"
      }
      
    
  };
</script>

<script src="/assets/js/jquery-3.2.1.min.js"></script>

<script src="/assets/js/lunr.min.js"></script>

<script src="/assets/js/search.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/3.2.2/anchor.min.js"></script>

<script>anchors.add('h1, h2, h3, h4, h5, h6');</script>


        <div id="back-to-top" role="button" aria-label="Back to top">
            <i class="fa fa-angle-double-up" aria-hidden="true"></i>
        </div>
    </main>
    <!-- footer -->
    
<footer class="footer" role="contentinfo" aria-label="Site footer">
    <div class="navigation" role="navigation" aria-label="Footer links">
        <a href="http://localhost:4000" class="avatar" role="link" aria-label="MvvmCross"></a>
        <ul role="menubar" aria-label="Footer links menubar">
            <!-- <li class="footer-products" role="menuitem" aria-label="Products">
                Products
                <ul role="menu" aria-hidden="true" aria-label="Products link">
                    <li role="listitem" aria-label="Products link item"><a href="http://github.com/MvvmCross/MvvmCross" target="_blank" role="link" aria-label="MvvmCross">MvvmCross</a></li>
                    <li role="listitem" aria-label="Products link item"><a href="/documentation/plugins/3rd-party-plugins" role="link" aria-label="Plugins">Plugins</a></li>
                    <li role="listitem" aria-label="Products link item"><a href="/documentation/samples/samples" role="link" aria-label="Samples">Samples</a></li>
                </ul>
            </li>
            <li class="footer-blog" role="menuitem" aria-label="Blog">
                Blog
                <ul role="menu" aria-hidden="true" aria-label="Blog link">
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/hello-world/" role="link" aria-label="Hello World 0.1">Hello World 0.1</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/hello-python/" role="link" aria-label="Hello Python 0.1">Hello Python 0.1</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/hello-java/" role="link" aria-label="Hello Java 0.1">Hello Java 0.1</a></li>
                    
                    <li role="listitem" aria-label="Blog link item"><a href="/blog" role="link" aria-label="Read more">Read More</a></li>
                </ul>
            </li>
            <li class="footer-organization" role="menuitem" aria-label="Organization">
                Organization
                <ul role="menu" aria-hidden="true" aria-label="Organization link">
                    <li role="listitem" aria-label="Organization link item"><a href="/about" role="link" aria-label="About MvvmCross">About MvvmCross</a></li>
                    <li role="listitem" aria-label="Organization link item"><a href="/branding" role="link" aria-label="Branding">Branding</a></li>
                    <li role="listitem" aria-label="Organization link item"><a href="http://github.com/MvvmCross/MvvmCross/blob/master/CONTRIBUTING.md" role="link" target="_blank" aria-label="Contributing">Contributing</a></li>
                    <li role="listitem" aria-label="Organization link item"><a href="http://github.com/MvvmCross/MvvmCross/blob/master/LICENSE" role="link" target="_blank" aria-label="License">License</a></li>
                    <li role="listitem" aria-label="Organization link item"><a href="http://github.com/MvvmCross/MvvmCross/blob/master/CODE_OF_CONDUCT.md" target="_blank" role="link" aria-label="CodeOfConduct">Code of Conduct</a></li>
                    <li role="listitem" aria-label="Organization link item"><a href="https://opencollective.com/mvvmcross" target="_blank" role="link" aria-label="DonationsSponsors">Donations & Sponsors</a></li>
                </ul>
            </li> -->
            <!-- <li class="footer-connect" role="menuitem" aria-label="Connect">
                Connect
                <ul role="menu" aria-hidden="true" aria-label="Connect link">
                    <li role="listitem" aria-label="Connect link item"><a href="http://github.com/MvvmCross/MvvmCross" target="_blank" role="link" aria-label="GitHub">GitHub</a></li>
                    <li role="listitem" aria-label="Connect link item"><a href="http://github.com/MvvmCross/MvvmCross/issues" target="_blank" role="link" aria-label="GitHub Issues">GitHub Issues</a></li>
                    <li role="listitem" aria-label="Connect link item"><a href="https://xamarinchat.herokuapp.com/" target="_blank" role="link" aria-label="Slack">Slack</a></li>
                    <li role="listitem" aria-label="Connect link item"><a href="https://stackoverflow.com/questions/tagged/mvvmcross" target="_blank" role="link" aria-label="Stack Overflow">Stack Overflow</a></li>
                    <li role="listitem" aria-label="Connect link item"><a href="https://forums.xamarin.com" target="_blank" role="link" aria-label="Xamarin Forums">Xamarin Forums</a></li>
                    <li role="listitem" aria-label="Connect link item"><a href="https://www.linkedin.com/in/andrei-mihai-rad-08a244b2/" target="_blank" role="link" aria-label="Linkedin">Linkedin</a></li>
                    <li role="listitem" aria-label="Connect link item"><a href="https://twitter.com/rad_andrei29" target="_blank" role="link" aria-label="Twitter">Twitter</a></li>
                </ul>
            </li> -->
        </ul>
    </div>
    <div class="socials"  role="navigation" aria-label="Social links">
        <ul role="menu" aria-hidden="true" aria-label="Social link">
            <li role="listitem" aria-label="Social link item"><a href="http://github.com/MvvmCross/MvvmCross" target="_blank" role="link" aria-label="GitHub"><i class="fa fa-github" aria-hidden="true"></i></a></li>
            <li role="listitem" aria-label="Social link item"><a href="https://twitter.com/rad_andrei29" target="_blank" role="link" aria-label="Twitter"><i class="fa fa-twitter" aria-hidden="true"></i></a></li>
            <!-- <li role="listitem" aria-label="Social link item"><a href="https://xamarinchat.herokuapp.com/" target="_blank" role="link" aria-label="Slack"><i class="fa fa-slack" aria-hidden="true"></i></a></li> -->
            <!-- <li role="listitem" aria-label="Social link item"><a href="https://stackoverflow.com/questions/tagged/mvvmcross" target="_blank" role="link" aria-label="Stack Overflow"><i class="fa fa-stack-overflow" aria-hidden="true"></i></a></li> -->
            <li role="listitem" aria-label="Social link item"><a href="https://www.linkedin.com/in/andrei-mihai-rad-08a244b2/" target="_blank" role="link" aria-label="Linkedin"><i class="fa fa-linkedin-square" aria-hidden="true"></i></a></li>
            <!-- <li role="listitem" aria-label="Social link item"><a href="/feed.xml" role="link" aria-label="RSS"><i class="fa fa-rss-square" aria-hidden="true"></i></a></li> -->
        </ul>
    </div>
    <div class="copyright" role="contentinfo" aria-label="Copyright">
        <p>&copy; <script type="text/javascript">document.write(new Date().getFullYear());</script> AndreiMihaiRad</p>
        <!-- <div class="right">
            <a href="/sitemap.xml" target="_blank" role="link" aria-label="Site map">Site Map</a>
        </div> -->
    </div>
</footer>

    <!-- scripts -->
    <script src="/assets/js/hamburger-menu.js"></script>
<script src="/assets/js/elevator.min.js"></script>
<script src="/assets/js/back-to-top.js"></script>
    <!-- google analytics -->
    
</body>
</html>